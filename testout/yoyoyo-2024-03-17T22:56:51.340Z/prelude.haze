let String.starts_with: (String, String) -> Bool =
  fun string, prefix ->
      if string_length(string) >= string_length(prefix) then
          let string_prefix = string_sub(string, 0, string_length(prefix)) in
          string_prefix $== prefix
      else
          false
in

let String.reverse: String -> String =
  fun string ->
      if string_length(string) <= 1 then
          string
      else
          string_sub(string, string_length(string) - 1, 1) ++ String.reverse(string_sub(string, 0, string_length(string) - 1))
in

type StringTransform =
  + Reverse
  + Trim
in

let String.transform: (String, [StringTransform]) -> String =
  fun string, transforms ->
      case transforms
      | [] => string
      | transform::rest =>
          let result =
              case transform
              | Reverse => String.reverse(string)
              | Trim =>
                  let starts_with_space = String.starts_with(string, " ") in
                  let ends_with_space = String.starts_with(String.reverse(string), " ") in
                  if starts_with_space && ends_with_space then
                      string_sub(string, 1, string_length(string) - 2)
                  else if starts_with_space then
                      string_sub(string, 1, string_length(string) - 1)
                  else if ends_with_space then
                      string_sub(string, 0, string_length(string) - 2)  
                  else
                      string
              end
          in
          String.transform(result, rest)
  end
in

type Term =
  + Var(String)
  + Abs(String, Term)
  + App(Term, Term)
in

let term_to_string: Term -> String =
  fun term ->
      case term
          | Var(x) => x
          | Abs(x, body) => "(lambda " ++ x ++ ". " ++ term_to_string(body) ++ ")"
          | App(func, arg) => "(" ++ term_to_string(func) ++ " " ++ term_to_string(arg) ++ ")"
      end
in

let parse_term: String -> (Term, String) =
  fun string ->
      if String.starts_with(string, "(lambda ") then
          let keyword_length = string_length("(lambda ") in
          let var = string_sub(string, keyword_length, 1) in
          let body, rest_string = parse_term(string_sub(string, keyword_length + 3, string_length(string) - keyword_length - 3)) in
          # Skip the closing ) #
          let rest_string = string_sub(rest_string, 1, string_length(rest_string) - 1) in
          (Abs(var, body), rest_string)
      else
          if String.starts_with(string, "(") then
              let func, rest_string = parse_term(string_sub(string, 1, string_length(string) - 1)) in
              # Skip the space between func and arg #
              let rest_string = string_sub(rest_string, 1, string_length(rest_string) - 1) in
              let arg, rest_string = parse_term(rest_string) in
              # Skip the closing ) after arg #
              let rest_string = string_sub(rest_string, 1, string_length(rest_string) - 1) in
              (App(func, arg), rest_string)
          else
              (Var(string_sub(string, 0, 1)), string_sub(string, 1, string_length(string) - 1))
in

# Add an element to the front of a list. #
let List.cons: (?, [?]) -> [?] = fun x, xs -> x::xs in

# Determine the length of a list. #
let List.length: [?] -> Int =
fun xs ->
  case xs
  | [] => 0
  | _::xs => 1 + List.length(xs) end in

# Extract the rest of the list. #
let List.tl: [?] -> [?] =
fun l ->
  case l
  | [] => []
  | x::xs => xs end in

# Determine if a list is empty. #
let List.is_empty: [?] -> Bool =
fun xs ->
  case xs
  | [] => true
  | _::_ => false end in

# Reverse a List. #
let List.rev: [?] -> [?] =
fun l -> 
let go: ([?], [?]) -> [?] =
fun xs, acc -> 
  case xs 
  | [] => acc 
  | x::xs => go(xs, x::acc) end in
go(l, []) in

# Check if two lists are equal #
let List.eq: ((?, ?) -> Bool, [?], [?]) -> Bool =
  fun p, xs, ys ->
  case xs, ys
  | [], [] => true
  | x::xs, y::ys => p(x, y) && List.eq(p, xs, ys)
  | _ => false end
in

# Initialize a list with a given length using an initializer function #
let List.init: (Int, Int -> ?) -> [?] =
  fun len, f ->
      let go: (Int, [?]) -> [?] =
      fun idx, xs ->
          if idx < len 
          then go(idx + 1, xs @ [f(idx)])   
          else xs
      in
      go(0, [])
in

# Reduce a list from the left. #
let List.fold_left: ((?, ?) -> ?, ?, [?]) -> ? =
fun f, acc, xs ->
  case xs 
  | [] => acc
  | hd::tl => List.fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let List.fold_right: ((?, ?) -> ?, [?], ?) -> ? =
fun f, xs, acc ->
  case xs
  | [] => acc
  | hd::tl => f(hd, List.fold_right(f, tl, acc)) end in

# Keep elements that satisfy the test. #
let List.filter: (? -> Bool, [?]) -> [?] =
fun f, xs ->
  case xs
  | [] => []
  | hd::tl => if f(hd) then hd::List.filter(f, tl) else List.filter(f, tl)
  end
in

# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in
