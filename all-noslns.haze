# Hazel Language Builtin Functions #

# infinity: Float #
# neg_infinity: Float #
# nan: Float #
# epsilon_float: Float #
# pi: Float #
# max_int: Int #
# min_int: Int #
# is_finite: Float -> Bool #
# is_infinite: Float -> Bool #
# is_nan: Float -> Bool #
# int_of_float: Float -> Int #
# float_of_int: Int -> Float #
# string_of_int: Int -> String #
# string_of_float: Float -> String #
# string_of_bool: Bool -> String #
# int_of_string: String -> Int #
# float_of_string: String -> Float #
# bool_of_string: String -> Bool #
# abs: Int -> Int #
# abs_float: Float -> Float #
# ceil: Float -> Float #
# floor: Float -> Float #
# exp: Float -> Float #
# log: Float -> Float #
# log10: Float -> Float #
# sqrt: Float -> Float #
# sin: Float -> Float #
# cos: Float -> Float #
# tan: Float -> Float #
# asin: Float -> Float #
# acos: Float -> Float #
# atan: Float -> Float #
# mod: (Int, Int) -> Int #
# string_length: String -> Int #
# string_compare: (String, String) -> Int #
# string_trim: String -> String #
# string_concat: (String, [String]) -> String #
# string_sub: (String, Int, Int) -> String #

# Hazel MVU Builtin Styles #

# AlignItems: String #
# BackgroundColor: String #
# Border: String #
# BorderRadius: String #
# BoxShadow: String #
# Color: String #
# Cursor: String #
# Display: String #
# FlexDirection: String #
# FontFamily: String #
# FontSize: String #
# FontStyle: String #
# Gap: String #
# Height: String #
# JustifyContent: String #
# Margin: String #
# Opacity: String #
# Outline: String #
# Overflow: String #
# Padding: String #
# Position: String #
# Width: String #
# S: (String, String) #

# Hazel Language Quick Reference #

# Empty holes stand for missing expressions, patterns, or types #
let empty_hole =   in

# Integers #
let int_lits : Int = 1 in
let negation = -1 in
let arithmetic = 1*2 + 8/4 in
let int_comparison = (10 == 10, 1 < 2, 2 <= 3, 3 > 2, 2 >= 1) in

# Floating Point Numbers #
let float_lits : Float = 1.5 in
let float_artih = 1. *. 2. +. 8. /. 4. in
let float_comparison = (10. ==.10., 1. <.2., 2. <=.3., 3. >.2., 2. >=.1.) in

# Booleans #
let booleans : (Bool, Bool) = (true, false) in
let conditionals =
  let (x, y) = (2 + 2, 3 + 3) in
  if y > x then 1
  else 2
in

# Tuples #
let tuples : (Int, Bool, (Bool, Int)) = (1, true, (false, 3)) in
let (a, b, (c, d)) = tuples in

# Functions #
let y : (Int, Int, Int) -> Int =
  fun (m, x, b) -> m * x + b
in

# Recursive Functions (arrow type annotation required) #
let double_recursively : Int -> Int =
  fun n ->
    if n == 0 then 0
    else double_recursively(n - 1) + 2
in

# Mutual Recursion (bind tuples of functions) #
let (even : Int -> Bool, odd : Int -> Bool) = 
  (fun n -> if n == 0 then true else odd(n - 1), 
fun n -> if n == 0 then false else even(n - 1)) in 

# Lists #
let empty_list : [Int] = [] in
let non_empty_list : [Int] = 1::2::3::[] in
let list_literals : [Int] = [1, 2, 3] in
let length : [Int] -> Int =
  fun xs ->
    case xs
      | [] => 0
      | hd::tl => 1 + length(tl)     
    end
in
let has_at_least_two_elements : [Int] -> Bool =
  fun xs ->
    case xs
      | [] => false
      | hd::[] => false
      | a::b::[] => true     
    end
in

# Strings #
let string_lits = "Hello, world!" in 
let string_equality = string_lits $== "Hello, world!" in 

# Non-empty holes are the red dotted boxes around errors #
# (you can still run programs with non-empty holes) #
let non_empty_hole : Int = true in 

# Tests, separated by semicolons #
test 2 + 2 == 4 end;
test 3 + 3 == 6 end;
test 2 + 2 == 5 end;

2 + 2


# BASICS #

type Option = None + Some(?) in

let fst: (?, ?) -> ? = fun a, b -> a in
let snd: (?, ?) -> ? = fun a, b -> b in

let not: Bool -> Bool = fun b -> !b in

let bool_eq: (Bool, Bool) -> Bool =
  fun a, b -> a && b \/ !a && !b in


# Lists #

# Add an element to the front of a list. #
let List.cons: (?, [?]) -> [?] =
  fun x, xs -> x::xs in

# Determine the length of a list. #
let List.length: [?] -> Int =
  fun xs ->
    case xs
    | [] => 0
    | _::xs => 1 + List.length(xs) end in

# Extract the head of the list. #
let List.hd: [?] -> ? =
  fun l -> 
    case l  
    | [] => ?
    | x::xs => x end in

# Extract the rest of the list. #
let List.tl: [?] -> [?] =
  fun l ->
    case l 
    | [] => ?
    | x::xs => xs end in

# Determine if a list is empty. #
let List.is_empty: [?] -> Bool =
  fun xs ->
    case xs
    | [] => true
    | _::_ => false end in

let List.nth: ([?], Int) -> ? =
  fun xs, n ->
    case xs, n
    | x::_, 0 => x
    | _::xs, n => List.nth(xs, n - 1)
    | [], _ => ? end in

# Reverse a List. #
let List.rev: [?] -> [?] =
  fun l -> 
    let go: ([?], [?]) -> [?] =
      fun xs, acc -> 
        case xs 
        | [] => acc 
        | x::xs => go(xs, x::acc) end in
   go(l, []) in

# Initialize a list with a given length using an initializer function #
let List.init: (Int, Int -> ?) -> [?] =
  fun len, f ->
    let go: (Int, [?]) -> [?] =
      fun idx, xs ->
        if idx < len 
        then go(idx+ 1, xs @ [f(idx)])   
        else xs in
    go(0, []) in

# Check if two lists are equal #
let List.equal: (? -> Bool, [?], [?]) -> Bool =
  fun p, xs, ys ->
    case xs, ys
    | [], [] => true
    | x::xs, y::ys => p(x, y) && List.equal(p, xs, ys)
    | _ => false end in

let List.eq = List.equal in

# Reduce a list from the left. #
let List.fold_left: ((?, ?)-> ?, ?, [?])-> ?   =
  fun f, acc, xs ->
    case xs 
    | [] => acc
    | hd::tl => List.fold_left(f, f(acc, hd), tl) end in

# Reduce a list from the right. #
let List.fold_right: ((?, ?)-> ?, [?], ?)-> ? =
  fun f, xs, acc ->
    case xs
    | [] => acc
    | hd::tl => f(hd, List.fold_right(f, tl, acc)) end in

let List.fold_left2: ((?, ?, ?) -> ?, ?, [?], [?]) -> [?] = 
  fun f, acc, xs, ys ->
    case xs, ys
    | [], [] => acc
    | x::xs, y::ys =>
      List.fold_left2(f, f(acc, x, y), xs, ys)
    | _ => ? end in

let List.fold_right2: ((?, ?, ?) -> ?, [?], [?], ?) -> [?] =
  fun f, acc, xs, ys ->
    case xs, ys
    | [], [] => acc
    | x::xs, y::ys =>
       f(x, y, List.fold_right2(f, xs, ys, acc))
    | _ => ? end in

let List.map: (? -> ?, [?]) -> ? =
  fun f, xs ->
    List.fold_right(fun x, acc -> f(x)::acc, xs, []) in

let List.map2: ((?,?) -> ?, [?], [?]) -> [?] =
  fun f, xs, ys ->
    List.fold_left2(
      fun x, y, acc -> f(x, y)::acc, xs, ys, []) in

# Keep elements that satisfy the test. #
let List.filter: (? -> Bool, [?]) -> [?] =
  fun p, xs ->
    case xs
    | [] => []
    | x::xs =>
      let xs = List.filter(p, xs) in 
      if p(x) then x :: xs else xs end in

let List.append: (([?], [?]) -> [?]) =
  fun xs, ys -> List.fold_right(List.cons, xs, ys) in

let List.concat: [[?]] -> [?] =
  fun xss -> List.fold_right(List.append, xss, [])  in

let List.flatten = List.concat in

let List.mapi: ((Int, ?) -> ?, [?]) -> [?] =
  fun f, xs ->
    let go: ? -> ? = fun idx, xs ->
      case xs
      | [] => []
      | hd::tl => f(idx, hd)::go(idx + 1, tl) end in
    go(0, xs) in

let List.filteri: ((Int, ?) -> Bool, [?]) -> [?] =
  fun f, xs ->
    List.concat(List.mapi(
      fun i, x -> if f(i, x) then [x] else [], xs)) in

let List.exists: (? -> Bool, [?]) -> Bool =
  fun p, xs ->
    case xs
    | [] => false
    | x::xs => p(x) \/ List.exists(p, xs) end in

let List.for_all: (? -> Bool, [?]) -> Bool =
  fun p, xs -> not(List.exists(fun x -> not(p(x)), xs)) in

let List.mem = fun eq, xs, y ->
  List.exists(fun x -> eq(x, y), xs) in

# Strings #

let String.starts_with: (String, String) -> Bool =
  fun string, prefix ->
    if string_length(string) >= string_length(prefix)
    then
      let string_prefix = string_sub(string, 0, string_length(prefix)) in
      string_prefix $== prefix
    else
      false in

let String.reverse: String -> String =
  fun string ->
    if string_length(string) <= 1
    then string
    else
      string_sub(string, string_length(string) - 1, 1)
      ++ String.reverse(string_sub(string, 0, string_length(string) - 1)) in

type StringTransform =
  + Reverse
  + Trim in

let String.transform: (String, [StringTransform]) -> String =
  fun string, transforms ->
    case transforms
    | [] => string
    | transform::rest =>
      let result =
        case transform
        | Reverse => String.reverse(string)
        | Trim =>
          let starts_with_space = String.starts_with(string, " ") in
          let ends_with_space = String.starts_with(String.reverse(string), " ") in
          if starts_with_space && ends_with_space then
            string_sub(string, 1, string_length(string) - 2)
          else if starts_with_space then
            string_sub(string, 1, string_length(string) - 1)
          else if ends_with_space then
            string_sub(string, 0, string_length(string) - 2)  
          else
            string
        end in
      String.transform(result, rest) end in


# Terms #

type Term =
  + Var(String)
  + Abs(String, Term)
  + App(Term, Term)
in

let term_to_string: Term -> String =
  fun term ->
    case term
    | Var(x) => x
    | Abs(x, body) => "(lambda " ++ x ++ ". " ++ term_to_string(body) ++ ")"
    | App(func, arg) => "(" ++ term_to_string(func) ++ " " ++ term_to_string(arg) ++ ")"
  end
in

let parse_term: String -> (Term, String) =
  fun string ->
    if String.starts_with(string, "(lambda ") then
      let keyword_length = string_length("(lambda ") in
      let var = string_sub(string, keyword_length, 1) in
      let body, rest_string = parse_term(string_sub(string, keyword_length + 3, string_length(string) - keyword_length - 3)) in
      # Skip the closing ) #
      let rest_string = string_sub(rest_string, 1, string_length(rest_string) - 1) in
      (Abs(var, body), rest_string)
    else
      if String.starts_with(string, "(")
      then
        let func, rest_string = parse_term(string_sub(string, 1, string_length(string) - 1)) in
        # Skip the space between func and arg #
        let rest_string = string_sub(rest_string, 1, string_length(rest_string) - 1) in
        let arg, rest_string = parse_term(rest_string) in
        # Skip the closing ) after arg #
        let rest_string = string_sub(rest_string, 1, string_length(rest_string) - 1) in
        (App(func, arg), rest_string)
      else
        (Var(string_sub(string, 0, 1)), string_sub(string, 1, string_length(string) - 1))
in

# LAMBDA CALCULUS #

# Lambda Calculus via evaluation by substitution #

# An Expression is a variable, function, or application #
type Exp =
  + Var(String)
  + Lam(String, Exp)
+ Ap(Exp, Exp) in

# Syntatic Equality of Expressions #
let exp_equal: (Exp, Exp) -> Bool =
  fun es ->
    case es
      | Var(x), Var(y) => x $== y
      | Lam(x1, e1), Lam(x2, e2) =>
        x1 $== x2 && exp_equal(e1, e2)
      | Ap(e1, e2), Ap(e3, e4) =>
        exp_equal(e1, e3) && exp_equal(e2, e4)
| _ => false end in

# Substitute Exp v for variable name in Exp e #
let subst: (Exp, String, Exp) -> Exp=
  fun v, name, e ->
    case e
      | Var(n) =>
        (if n $== name then v else e)
      | Lam(x, body) =>
        Lam(x, subst(v,name, body))
      | Ap(e1,e2) =>
  Ap(subst(v, name, e1), subst(v, name, e2)) end in

# Evaluation can result in either an Exp or an Error #
type Result =
  + Error(String)
  + Ok(Exp)  
in

let result_equal: (Result, Result) -> Bool =
  fun rs ->
    case rs
      | Ok(e1), Ok(e2) => exp_equal(e1, e2)
      | Error(e1), Error(e2) => e1 $== e2
| _ => false end in

# Evaluation by substitution #
let eval: Exp -> Result =
  fun e ->
    case e
      | Var(n) => Error("Free Variable")
      | Lam(x, body) => Ok(Lam(x, body))
      | Ap(e1,e2) =>
      case eval(e1)
        | Ok(Lam(x, body))=>
        case eval(e2)
          | Error(err) => Error(err)
        | Ok(arg) => eval(subst(arg, x, body)) end
| _ => Error("Not a Function") end end in

test result_equal(
  eval(Var("yo")),
Error("Free Variable")) end;

test result_equal(
  eval(Ap(Var("no"), Lam("bro", Var("bro")))),
Error("Not a Function")) end;

test result_equal(
  eval(Lam("yo", Var("yo"))),
Ok(Lam("yo", Var("yo")))) end;

test result_equal(
  eval(Ap(Lam("yo", Var("yo")), Lam("bro", Var("bro")))),
Ok(Lam("bro", Var("bro")))) end


# TODO MVU PRELUDE #

# A todo has a description and a status #
type Todo = (String, Bool) in

# A description input buffer and a todo list #
type Model = (String, [Todo]) in

type Update = (Model, Action) -> Model in

let Todo.eq: (Todo, Todo) -> Bool =
  fun (d1, s1), (d2, s2) ->
  d1 $== d2 && bool_eq(s1, s2) in

let Model.eq: (Model, Model) -> Bool =
  fun (b1, ts1), (b2, ts2) ->
    b1 $== b2 && List.equal(Todo.eq, ts1, ts2) in

let Model.init: Model = ("", []) in

type Action =
  + AddTodo
  + RemoveTodo(Int)
  + ToggleTodo(Int)
  + UpdateBuffer(String) in
  
# TODO MVU SOLUTION #

let update: (Model, Action) -> Model =
  let add: Model -> [Todo] =
    fun (description, todos) ->
      if description $== ""      
      then todos     
      else (description, false) :: todos in
  let remove: (Int, [Todo]) -> [Todo]=
     fun (index, todos) ->
      List.filteri(fun i, _ -> i!= index, todos) in
  let toggle: (Int, [Todo]) -> [Todo]=
    fun (index, todos) ->
      List.mapi(
        fun i, (description, done) ->
          (description, if i == index then !done else done),
          todos) in
  fun ((input: String, todos: [Todo]), action) ->
    case action
    | AddTodo => ("", add(input, todos))
    | ToggleTodo(idx) => (input, toggle(idx, todos))
    | RemoveTodo(idx) => (input, remove(idx, todos))
    | UpdateBuffer(description) => (description, todos) end in


# TODO MVU EPILOGUE #    

let eq = Model.eq in
let num_todos = fun m:Model -> List.length(snd(m)) in

test  # Add adds #
  num_todos(update(("Breath", []), AddTodo))
  > num_todos(("Breath", [])) end;

test  # Add uses name, initial status set #
  eq(
  update(("Breath", []), AddTodo),
  ("", [("Breath", false)])) end;

test  # Add nonempty (too impl spec? test add + remove eqs)#
  eq(
  update(("Chop wood", [("Carry water", false)]), AddTodo),
    ("", [("Chop wood", false), ("Carry water", false)])) end;
      
test  # add then remove doesn't change todos #
  let todos = [("Breath", false)] in
  eq(
    update(update(("Remove this", todos), AddTodo), RemoveTodo(0)),
    ("", todos)) end;
      
test  # Toggle preserves length #
  let model = ("", [("1", false), ("2", false)]) in
  num_todos(update(model, ToggleTodo(1)))
    == num_todos(model) end;
    
test  # Toggle toggles right index #
  eq(
    update(("", [("Chop", false), ("Carry", true)]), ToggleTodo(1)),
    ("", [("Chop", false), ("Carry", false)])) end;
  
test  # Toggle out of bounds #
  let model = ("", [("Chop", false), ("Carry", false)]) in
  eq(
    update(model, ToggleTodo(2)),
    model) end;
  
test  # Remove removes #
  let model = ("", [("1", false)]) in
  num_todos(update(model, RemoveTodo(0)))
  < num_todos(model) end;

test  # Remove removes right index #
  eq(
    update(("", [("1", false), ("2", false)]), RemoveTodo(1)),
    ("", [("1", false)])) end;
  
test  # Remove out of bounds #
  let model = ("", [("1", false)]) in
  eq(
    update(model, RemoveTodo(2)),
    model) end;

test  # Update Input #
eq(
  update(("", []), UpdateBuffer("Breath")),
  ("Breath", [])) end;
      
test  # Don't add blank description #
  let model = ("", [("1", false)]) in
  eq(
    update(model, AddTodo),
    model) end


# TODO MVU VIEW #

let todo_card : (Int, Todo) -> Node =
  fun (idx, (descr: String, status: Bool)) ->
    Div([
      Style([
        Display("flex"),
        Gap("1em")]),
      OnClick(fun () -> ToggleTodo(idx))],
      [
        Checkbox([OnClick(fun () -> RemoveTodo(idx))], []),
        Div([], [Text(descr)]),
        Text(if status then "Completed" else "Pending")]) in

let todos_deck = fun todos: [Todo] ->
  if (List.is_empty(todos))           
  then Text("You're caught up")           
  else Div(
    [Create("class", "todos")],
    [Text("todos:")] @ List.mapi(todo_card, todos)) in

let add_button: Node =
  Div([
    Style([
      Display("flex"),
      JustifyContent("center"),
      BackgroundColor("#986"),
      BorderRadius("0.3em"),
      Cursor("pointer")]),
    OnClick(fun () -> AddTodo)],
    [Text("Add Todo")]) in

let buffer: Node =
  Div([],
      [TextInput([OnInput(UpdateBuffer)], [])]) in
    
let view: Model -> Node =
  fun input: String, todos: [Todo] ->
    Div(
      [Style([
        BackgroundColor("#543"),
        BorderRadius("0.3em"),
        Color("white"),
        Display("flex"),
        FlexDirection("column"),
        Width("9.2em"),
        Gap("0.5em"),
        Padding("0.3em")])],
      [
        Text("Hazel Todos"),
        buffer,
        add_button,
        todos_deck(todos)]) in
        
Render("todo_app", Model.init, view, update)


# Playlist MVU PRELUDE #

# Non-negative ID for songs #
type Id = Int in

# Actions user can do in a playlist #
type PlayListAction =
  + PlaySong(Id)
  + PauseCurrentSong
  + RemoveSong(Id)
  # Add to the front of the playList, ignore duplication #
  + AddSong(Id)
in

# The state of the playlist #
type PlayListState =
  + Playing(Id)
  + PausedOn(Id)
  + NoSongSelected
in

# A playlist with a list of songs and the current state of the playlist #
type PlayList = ([Id], PlayListState) in

# Get all the song ids in the playlist #
let get_songs: PlayList -> [Id] =
  fun playlist ->
    let songs, current = playlist in
    songs 
in

# Get the id of the currently playing song #
let get_state: PlayList -> PlayListState =
  fun playlist ->
    let songs, state = playlist in
    state
in

# Playlist MVU SOLUTION #

# Update playlist based on action #
let update: (PlayList, PlayListAction) -> PlayList =
  fun playlist, action ->
    case action
      | PlaySong(id) => (get_songs(playlist), Playing(id))
      | PauseCurrentSong =>
        case get_state(playlist)
        | Playing(id) =>
          (get_songs(playlist), PausedOn(id))
        | state =>
          (get_songs(playlist), state)
        end
      | RemoveSong(id) =>
        let new_songs = 
          List.filter((fun x -> x != id), get_songs(playlist))
        in
        let new_state =
          case get_state(playlist)
          | Playing(current_id) =>
            if id == current_id then
              NoSongSelected
            else
              Playing(current_id)
          | PausedOn(current_id) =>
            if id == current_id then
              NoSongSelected
            else
              PausedOn(current_id)
          | NoSongSelected =>
            NoSongSelected
          end
        in
        (new_songs, new_state)
      | AddSong(id) => (id::get_songs(playlist), get_state(playlist))
    end
in


# Playlist MVU EPILOGUE #

let PlayListState.eq: (PlayListState, PlayListState) -> Bool =
  fun s1, s2 ->
    case s1, s2
    | Playing(i1), Playing(i2) => i1 == i2
    | PausedOn(i1), PausedOn(i2) => i1 == i2
    | NoSongSelected, NoSongSelected => true
    | _ => false
    end
in

let PlayList.eq: (PlayList, PlayList) -> Bool =
  fun p1, p2 ->
    PlayListState.eq(get_state(p1), get_state(p2)) &&
    List.eq(fun i1, i2 -> i1 == i2, get_songs(p1), get_songs(p2))
in

# Testing PlaySong #

test PlayList.eq(update(([0, 1, 2], NoSongSelected), PlaySong(0)), ([0, 1, 2], Playing(0))) end;
test PlayList.eq(update(([0, 1, 2], PausedOn(1)), PlaySong(1)), ([0, 1, 2], Playing(1))) end;
test PlayList.eq(update(([0, 1, 2], PausedOn(0)), PlaySong(1)), ([0, 1, 2], Playing(1))) end;

# Testing PauseCurrentSong #
test PlayList.eq(update(([0, 1, 2], NoSongSelected), PauseCurrentSong) ,([0, 1, 2], NoSongSelected)) end;
test PlayList.eq(update(([0, 1, 2], PausedOn(1)), PauseCurrentSong), ([0, 1, 2], PausedOn(1))) end;
test PlayList.eq(update(([0, 1, 2], Playing(0)), PauseCurrentSong), ([0, 1, 2], PausedOn(0))) end;

# Testing RemoveSong #
test PlayList.eq(update(([0, 1, 2], NoSongSelected), RemoveSong(0)), ([1, 2], NoSongSelected)) end;
test PlayList.eq(update(([0, 1, 2], Playing(0)), RemoveSong(0)), ([1, 2], NoSongSelected)) end;
test PlayList.eq(update(([0, 1, 2], PausedOn(0)), RemoveSong(0)), ([1, 2], NoSongSelected)) end;
test PlayList.eq(update(([0, 1, 2], Playing(1)), RemoveSong(0)), ([1, 2], Playing(1))) end;
test PlayList.eq(update(([0, 1, 2], PausedOn(1)), RemoveSong(0)), ([1, 2], PausedOn(1))) end;
test PlayList.eq(update(([0, 1, 2], Playing(1)), RemoveSong(3)), ([0, 1, 2], Playing(1))) end;

# Testing AddSong #
test PlayList.eq(update(([0, 1, 2], NoSongSelected), AddSong(3)), ([3, 0, 1, 2], NoSongSelected)) end;
test PlayList.eq(update(([0, 1, 2], Playing(0)), AddSong(3)), ([3, 0, 1, 2], Playing(0))) end;
test PlayList.eq(update(([0, 1, 2], PausedOn(0)), AddSong(3)), ([3, 0, 1, 2], PausedOn(0))) end;


# ROOM BOOKING MVU #

type Weekday = M + T + W + R + F in
type TimeOfDay = AM + PM in
type Time = (Weekday, TimeOfDay) in
type User = String in
type BookingID = Int in
type Booking = (Time, User, BookingID) in
type BookingFormData = (Time, User) in
type Model = (BookingFormData, [Booking], BookingID) in

type Action =
  + AddBooking(User, Weekday, TimeOfDay)
  + CancelBooking(User, Int)
  + ClearBookings
  + ClearRange(Time, Time) 
in
    
let initFormState = ((M, AM), "") in
let Model.init: Model = (initFormState, [], 0) in

let getBookings: Model -> [Booking] =
  fun _, bs,_ -> bs in
      
let bookingExists: (Model, Booking) -> Bool =
  fun model, booking ->
    List.exists(fun b -> b == booking, getBookings(model))  
in
  
let getUserBookings: (Model, User) -> [Booking] =
  fun model, user ->
    List.filter(fun (_, u:User,_) -> u == user, getBookings(model)) 
in

let getBookingById: (Model, BookingID) -> Booking =
  fun model, id ->
    case List.filter(fun (_, _, i:BookingID) -> i == id, getBookings(model))
      | [booking] => booking
      | _ => ?  
    end  
in

let weekdayIndex: Weekday -> Int =
  fun day ->
    case day
      | M => 0
      | T => 1
      | W => 2
      | R => 3
      | F => 4   
    end   
in

let isBeforeOrEqual: (TimeOfDay, TimeOfDay) -> Bool =
  fun t1, t2 ->
    case t1, t2
      | AM, _ => true
      | PM, PM => true
      | _ => false   
    end 
in
  
let compareTimeRange: (Time, Time, Time) -> Bool =
  fun (weekday, timeOfDay), (startWeekday, startTime), (lastWeekday, lastTime) ->
    let bookingIndex = weekdayIndex(weekday) in
    let startIndex = weekdayIndex(startWeekday) in
    let lastIndex = weekdayIndex(lastWeekday) in
    if bookingIndex > startIndex && bookingIndex < lastIndex then
      true   
    else if bookingIndex == startIndex && bookingIndex == lastIndex then
      isBeforeOrEqual(startTime, timeOfDay)
      && isBeforeOrEqual(timeOfDay, lastTime)  
    else if bookingIndex == startIndex then
      isBeforeOrEqual(startTime, timeOfDay)  
    else if bookingIndex == lastIndex then
      isBeforeOrEqual(timeOfDay, lastTime)  
    else
      false   
in

# ROOM BOOKING MVU SOLUTION #

let update: (Model, Action) -> Model =
  fun (formState, bookings, nextId), action ->
    case action
      | AddBooking(user, weekday, timeOfDay) =>
        let newBooking = ((weekday, timeOfDay), user, nextId) in
        (((weekday, timeOfDay), user), newBooking :: bookings, nextId + 1)
      | CancelBooking(user, id) =>
        let updatedBookings = List.filter(
          fun (_, u: User, i: BookingID) -> (u != user) \/ (i != id), bookings) in
        (formState, updatedBookings, nextId)
      | ClearBookings =>
        (formState, [], nextId)
      | ClearRange(startTime, lastTime) =>
        let updatedBookings = List.filter(
          fun ((weekday, timeOfDay), _, _):Booking ->
            !compareTimeRange((weekday,timeOfDay), startTime, lastTime), bookings) in
        (formState, updatedBookings, nextId)  
    end  
in


# ROOM BOOKING MVU EPILOGUE #

test
  getBookings(update(Model.init, AddBooking("Charles",M, AM)))
  == [((M, AM),"Charles",0)]  
end;
      
test
  let model = update(Model.init, AddBooking("Alice", T, PM)) in
  getBookings(model) == [((T, PM), "Alice", 0)] 
end;

test
  let model = update(Model.init, AddBooking("Bob", W, AM)) in
  getUserBookings(model, "Bob") == [((W, AM), "Bob", 0)]  
end;
      
test
  let model = update(Model.init, AddBooking("Alice", R, PM)) in
  let model = update(model, CancelBooking("Alice", 0)) in
  getUserBookings(model, "Alice") == []  
end;
      
test
  let model = update(Model.init, AddBooking("Alice", F, AM)) in
  let model = update(model, AddBooking("Bob", F, AM)) in
  getBookingById(model, 1) == ((F, AM), "Bob", 1)   
end;
      
test
  let model = update(Model.init, AddBooking("Alice", M, AM)) in
  let model = update(model, AddBooking("Bob", M, PM)) in
  let model = update(model, AddBooking("Alice", T, AM)) in
  let model = update(model, AddBooking("Bob", T, PM)) in
  let model = update(model, AddBooking("Alice", W, AM)) in
  let model = update(model, CancelBooking("Alice", 0)) in
  let model = update(model, CancelBooking("Bob", 3)) in
  getBookings(model) == [((W, AM), "Alice", 4), ((T, AM), "Alice", 2), ((M, PM), "Bob", 1)]  
end;
  
test
  let model = update(Model.init, AddBooking("Alice", M, AM)) in
  let model = update(model, AddBooking("Bob", M, AM)) in
  let model = update(model, AddBooking("Charlie", M, AM)) in
  let model = update(model, AddBooking("Dave", M, PM)) in
  let model = update(model, AddBooking("Eve", M, PM)) in
  let model = update(model, CancelBooking("Bob", 1)) in
  let model = update(model, CancelBooking("Dave", 3)) in
  let model = update(model, CancelBooking("Alice", 0)) in
  getBookings(model) == [((M, PM), "Eve", 4), ((M, AM), "Charlie", 2)]  
end;
  
test
  let model = update(Model.init, AddBooking("Alice", M, AM)) in
  let model = update(model, ClearBookings) in
  getBookings(model) == []  
end;
  
test
  let model = update(Model.init, AddBooking("Alice", M, AM)) in
  let model = update(model, AddBooking("Bob", M, PM)) in
  let model = update(model, ClearRange((M, AM), (M, PM))) in
  getBookings(model) == []   
end;
  
test
  let model = update(Model.init, AddBooking("Alice", M, AM)) in
  let model = update(model, AddBooking("Bob", T, PM)) in
  let model = update(model, AddBooking("Charlie", W, AM)) in
  let model = update(model, ClearRange((M, AM), (T, AM))) in
  getBookings(model) == [((W, AM), "Charlie", 2),((T, PM), "Bob", 1) ]  
end;
  
test
  let model = update(Model.init, AddBooking("Alice", M, AM)) in
  let model = update(model, AddBooking("Bob", M, PM)) in
  let model = update(model, AddBooking("Charlie", T, AM)) in
  let model = update(model, ClearRange((M, PM), (T, PM))) in
  getBookings(model) == [((M, AM), "Alice", 0)]  
end;
  
test
  let model = update(Model.init, AddBooking("Alice", M, AM)) in
  let model = update(model, AddBooking("Bob", T, AM)) in
  let model = update(model, AddBooking("Charlie", W, PM)) in
  let model = update(model, AddBooking("Dave", R, AM)) in
  let model = update(model, ClearRange((T, PM), (W, AM))) in
  List.length(getBookings(model)) == 4   
end;


# PASSWORDS MVU #

type PasswordCriteria =
  + RequireUppercase
  + RequireLowercase
  + MinimumLength(Int)
  + RequireNumber
  + RequireSpecialChar in

type PasswordStrength =
  + Weak
  + Moderate
  + Strong in
      
type Password = String in
type Criteria = [PasswordCriteria] in
type Strength = PasswordStrength in
  
type Model = (Password, Criteria, Strength) in
  
let initialModel: Model = (
  "",
  [
    MinimumLength(8),
    RequireUppercase,
    RequireLowercase,
    RequireNumber,
    RequireSpecialChar
  ],
  Weak
) in

type Action =
  + UpdatePassword(String)
  + ClearCriteria
  + AddCriterion(PasswordCriteria)
  + RemoveCriterion(PasswordCriteria) in
    
let meetsMinLength: (String, Int) -> Bool =
  fun password, len ->
    string_length(password) >= len in
  
let hasFromSet: (String, String) -> Bool =
  fun password: Password, set: String ->
    let loop: String -> Bool =
      fun s: String ->
        if string_length(s) == 0 
        then false 
        else
          let first = string_sub(s, 0, 1) in
          if string_contains(set, first) 
          then true 
          else loop(string_sub(s, 1, string_length(s) - 1)) 
  in loop(password)
in

let hasUppercase: String -> Bool =
  fun password: Password ->
    hasFromSet(password, "ABCDEFGHIJKLMNOPQRSTUVWXYZ") in
    
let hasLowercase: Password -> Bool =
  fun password: Password ->
    hasFromSet(password, "abcdefghijklmnopqrstuvwxyz") in
        
let hasNumber: Password -> Bool =
  fun password: Password ->
    hasFromSet(password, "0123456789") in
          
let hasSpecialChar: Password -> Bool =
  fun password: Password ->
    hasFromSet(password, "!@#$%^&*()-_=+[]{}|;:,.<>?") in
  
let meetsCriterion: (Password, PasswordCriteria) -> Bool =
  fun password, criterion ->
    case criterion
    | RequireUppercase => hasUppercase(password)
    | RequireLowercase => hasLowercase(password)
    | MinimumLength(len) => meetsMinLength(password, len)
    | RequireNumber => hasNumber(password)
    | RequireSpecialChar => hasSpecialChar(password) 
  end in

let metCriteria: (Password, [PasswordCriteria]) -> [Bool] =
  fun password, criteria ->
    List.filter(
      fun c: PasswordCriteria -> meetsCriterion(password, c),
      criteria
    ) in
    
let strength_of: Int -> PasswordStrength =
  fun num_criteria_met ->
    case num_criteria_met
    | 0 => Weak
    | 1 => Weak
    | 2 => Weak
    | 3 => Moderate
    | 4 => Strong
    | _ => Strong 
    end in
      
let calculateStrength: (Password, [PasswordCriteria]) -> PasswordStrength =
  fun password, criteria ->
    strength_of(List.length(metCriteria(password, criteria))) in


# PASSWORDS MVU SOLUTION#

let update: (Model, Action) -> Model =
  fun model, action ->
    case action
    | ClearCriteria =>
      let (password, criteria, strength) = model in
      (password, [], strength)
    | UpdatePassword(newPassword) =>
      let (_, criteria, _) = model in
      let newStrength = calculateStrength(newPassword, criteria) in
      (newPassword, criteria, newStrength)
    | AddCriterion(newCriterion) =>
      let (password, criteria, _) = model in
      let newCriteria = newCriterion :: criteria in
      let newStrength = calculateStrength(password, newCriteria) in
      (password, newCriteria, newStrength)
    | RemoveCriterion(criterionToRemove) =>
      let (password, criteria, _) = model in
      let newCriteria = List.filter(
        fun c: PasswordCriteria -> c!= criterionToRemove, criteria
      ) in
      let newStrength = calculateStrength(password, newCriteria) in
      (password, newCriteria, newStrength) 
    end in

# PASSWORDS MVU EPILOGUE#

test
  let model = update(initialModel, ClearCriteria) in
  let (_, criteria, _) = model in
  List.length(criteria) == 0   
end;

test
  let model = update(initialModel, ClearCriteria) in
  let model = update(model, AddCriterion(RequireUppercase)) in
  let (password, criteria, strength) = model in
  List.length(criteria) == 1  
end;

test
  let model = update(initialModel, UpdatePassword("pass")) in
  let (password, _, strength) = model in
  password == "pass" && strength == Weak 
end;
  
test
  let model = update(initialModel, UpdatePassword("password")) in
  let (password, _, strength) = model in
  password == "password" && strength == Weak 
end;

test
  let model = update(initialModel, UpdatePassword("Password123")) in
  let (password, _, strength) = model in
  password == "Password123" && strength == Strong 
end;

test
  let model = update(initialModel, UpdatePassword("Password123!")) in
  let (password, _, strength) = model in
  password == "Password123!" && strength == Strong 
end;
    
test
  let model = update(initialModel, UpdatePassword("password")) in
  let model = update(model, AddCriterion(RequireUppercase)) in
  let (password, criteria, strength) = model in
  password == "password" && List.length(criteria) == 6 && strength == Weak 
end;

test
  let model = update(initialModel, UpdatePassword("Password123!")) in
  let model = update(model, RemoveCriterion(RequireUppercase)) in
  let (password, criteria, strength) = model in
  password == "Password123!" && List.length(criteria) == 4 && strength == Strong 
end;

test
  let model = update(initialModel, UpdatePassword("pass")) in
  let model = update(model, RemoveCriterion(MinimumLength(8))) in
  let (password, criteria, strength) = model in
  password == "pass" && List.length(criteria) == 4 && strength == Weak 
end;
      
test
  let model = update(initialModel, UpdatePassword("Passw0rd!")) in
  let model = update(model, RemoveCriterion(RequireSpecialChar)) in
  let (password, criteria, strength) = model in
  password == "Passw0rd!" && List.length(criteria) == 4 && strength == Strong 
end;
          
test
  let model = update(initialModel, UpdatePassword("password123")) in
  let model = update(model, AddCriterion(RequireSpecialChar)) in
  let (password, criteria, strength) = model in
  password == "password123" && List.length(criteria) == 6 && strength == Moderate 
end;

test
  let model = update(initialModel, UpdatePassword("P@ssw0rd!")) in
  let model = update(model, RemoveCriterion(RequireUppercase)) in
  let model = update(model, RemoveCriterion(RequireSpecialChar)) in
  let (password, criteria, strength) = model in
  password == "P@ssw0rd!" && List.length(criteria) == 3 && strength == Moderate 
end;


# EMOJIPAINT MVU #

type Emoji = String in 
type Row = Int in 
type Col = Int in 
type Grid = [[Emoji]] in

type Model = (
  Grid,     # The 2D grid of emojis #
  Emoji,    # The currently selected emoji #
  [Emoji]   # The list of available emojis #
) in

type Action =
  + SelectEmoji(Emoji)    # Set the currently selected emoji #
  + StampEmoji(Row, Col)  # Stamp the current emoji at the specified position #
  + ClearCell(Row, Col)   # Clear the emoji at the specified position #
  + ClearGrid             # Clear the entire grid #
  + FillRow(Row)          # Fill the specified row with the current emoji #
in

let model_init: Model = (
  [["","",""],["","",""],["","",""]], # Initial 3x3 empty grid #
  "ðŸ˜„",                               # Initial selected emoji #
  ["ðŸ˜„", "ðŸ˜…", "ðŸ˜†", "ðŸ˜‰", "ðŸ˜Š"]        # Available emojis #
) in
  
let updateGrid: (Grid, Row, Col, Emoji) -> Grid =
  fun grid, row, col, emoji ->
    List.mapi(
      fun i, r -> 
        if i == row  
        then List.mapi(fun j, c -> if j == col then emoji else c, r) 
        else r, 
      grid
   ) in
  
let clearGrid: Grid -> Grid =
  fun grid -> List.map(fun row -> List.map(fun _ -> "", row), grid) 
in
  
let fillRowInGrid: (Grid, Row, Emoji) -> Grid =
  fun grid, rowToFill, emoji ->
    List.mapi(
      fun i, row -> 
        if i == rowToFill 
        then List.map(fun _ -> emoji, row) 
        else row,
      grid  
  ) in

# EMOJIPAINT MVU SOLUTION #

let update: (Model, Action) -> Model =
  fun (grid, selectedEmoji, emojiList), action ->
    case action 
    | SelectEmoji(emoji) =>
      (grid, emoji, emojiList)
    | StampEmoji(row, col) =>
      (updateGrid(grid, row, col, selectedEmoji), selectedEmoji, emojiList)
    | ClearCell(row, col) =>
      (updateGrid(grid, row, col, ""), selectedEmoji, emojiList)
    | ClearGrid =>
      (clearGrid(grid), selectedEmoji, emojiList)
    | FillRow(row) =>
      (fillRowInGrid(grid, row, selectedEmoji), selectedEmoji, emojiList) 
    end in

# EMOJIPAINT MVU EPILOGUE #

test 
  let (grid, _, _) = update(model_init, StampEmoji(0, 0)) in
  grid == [["ðŸ˜„","",""],["","",""],["","",""]] 
end;

test
  let (grid, _, _) = update(model_init, FillRow(1)) in
  grid == [["","",""],["ðŸ˜„","ðŸ˜„","ðŸ˜„"],["","",""]] 
end;

test
  let model = update(model_init, SelectEmoji("ðŸ˜…")) in
  let (grid, selectedEmoji, _) = update(model, StampEmoji(2, 2)) in
  grid == [["","",""],["","",""],["","","ðŸ˜…"]] && selectedEmoji == "ðŸ˜…" 
end;
    
test
  let model = update(model_init, FillRow(0)) in
  let (grid, _, _) = update(model, ClearCell(0, 1)) in
  grid == [["ðŸ˜„","","ðŸ˜„"],["","",""],["","",""]] 
end;

test
  let model = update(model_init, StampEmoji(1, 1)) in
  let (grid, _, _) = update(model, ClearGrid) in
  grid == [["","",""],["","",""],["","",""]] 
end;

test
  let (_, selectedEmoji, _) = update(model_init, SelectEmoji("ðŸ˜Š")) in
  let (grid_init, _, emojiList_init) = model_init in
  let (grid, _, _) = update((grid_init, selectedEmoji, emojiList_init), StampEmoji(1, 2)) in
  grid == [["","",""],["","","ðŸ˜Š"],["","",""]] 
end;
  
test
  let (_, selectedEmoji, emojiList) = model_init in
  let model = update(model_init, FillRow(2)) in
  let (grid, _, _) = update(model, ClearCell(2, 0)) in
  grid == [["","",""],["","",""],["","ðŸ˜„","ðŸ˜„"]] 
end;

test
  let model = update(model_init, StampEmoji(0, 0)) in
  let model = update(model, StampEmoji(1, 1)) in
  let model = update(model, StampEmoji(2, 2)) in
  let (grid, _, _) = update(model, ClearGrid) in
  grid == [["","",""],["","",""],["","",""]] 
end;
        
test
  let (grid_init, _, emojiList_init) = model_init in
  let model = update(model_init, FillRow(0)) in
  let (_, selectedEmoji, _) = update(model, SelectEmoji("ðŸ˜†")) in
  let (grid,_,_) = model in
  let (grid, _, _) = update((grid, selectedEmoji, emojiList_init), StampEmoji(1, 1)) in
  grid == [["ðŸ˜„","ðŸ˜„","ðŸ˜„"],["","ðŸ˜†",""],["","",""]] 
end;
  
test
  let model = update(model_init, StampEmoji(0, 0)) in
  let model = update(model, FillRow(2)) in
  let (grid, _, emojiList) = model in
  let model = update(model, SelectEmoji("ðŸ˜‰")) in
  let model = update(model, StampEmoji(1, 1)) in
  let model = update(model, ClearCell(2, 2)) in
  let (grid, selectedEmoji, _) = model in
  grid == [["ðŸ˜„","",""],["","ðŸ˜‰",""],["ðŸ˜„","ðŸ˜„",""]] && selectedEmoji == "ðŸ˜‰" 
end;
