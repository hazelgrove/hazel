open Util;
open OptUtil.Syntax;

/* STATICS

     This module determines the statics semantics of the language.
     It takes a term and returns a map which associates the unique
     ids of each term to an Info.t data structure which reflects that
     term's statics. The statics collected depend on the term's sort,
     but every term has a syntactic class (The cls types from Term),
     except Invalid terms which Term could not parse.

     The map generated by this module is intended to be generated once
     from a given term and then reused anywhere there is logic which
     depends on static information.
   */

[@deriving (show({with_path: false}), sexp, yojson)]
type map = Id.Map.t(Info.t);

let exp_id = Term.UExp.rep_id;
let pat_id = Term.UPat.rep_id;
let typ_id = Term.UTyp.rep_id;
let utpat_id = Term.UTPat.rep_id;

/* The type of an expression after hole wrapping */
let fixed_exp_typ = (ctx, m: map, e: Term.UExp.t): option(Typ.t) => {
  let* info = Id.Map.find_opt(exp_id(e), m);
  Info.typ_after_fix_opt(ctx, info);
};

/* The type of a pattern after hole wrapping */
let fixed_pat_typ = (ctx, m: map, e: Term.UPat.t): option(Typ.t) => {
  let* info = Id.Map.find_opt(pat_id(e), m);
  Info.typ_after_fix_opt(ctx, info);
};

let pat_self_typ = (ctx, m: map, p: Term.UPat.t): option(Typ.t) => {
  let* info = Id.Map.find_opt(pat_id(p), m);
  Info.typ_of_self_info(ctx, info);
};

let union_m = List.fold_left(Id.Map.disj_union, Id.Map.empty);

let add_info = (ids: list(Id.t), info: Info.t, m: map): map =>
  ids
  |> List.map(id => Id.Map.singleton(id, info))
  |> List.fold_left(Id.Map.disj_union, m);

let extend_let_def_ctx =
    (ctx: Ctx.t, pat: Term.UPat.t, pat_ctx: Ctx.t, def: Term.UExp.t): Ctx.t =>
  if (Term.UPat.is_tuple_of_arrows(pat)
      && Term.UExp.is_tuple_of_functions(def)) {
    pat_ctx;
  } else {
    ctx;
  };

let typ_exp_binop_bin_int: Term.UExp.op_bin_int => Typ.t =
  fun
  | (Plus | Minus | Times | Power | Divide) as _op => Int
  | (LessThan | GreaterThan | LessThanOrEqual | GreaterThanOrEqual | Equals) as _op =>
    Bool;

let typ_exp_binop_bin_float: Term.UExp.op_bin_float => Typ.t =
  fun
  | (Plus | Minus | Times | Power | Divide) as _op => Float
  | (LessThan | GreaterThan | LessThanOrEqual | GreaterThanOrEqual | Equals) as _op =>
    Bool;

let typ_exp_binop_bin_string: Term.UExp.op_bin_string => Typ.t =
  fun
  | Equals as _op => Bool;

let typ_exp_binop: Term.UExp.op_bin => (Typ.t, Typ.t, Typ.t) =
  fun
  | Bool(And | Or) => (Bool, Bool, Bool)
  | Int(op) => (Int, Int, typ_exp_binop_bin_int(op))
  | Float(op) => (Float, Float, typ_exp_binop_bin_float(op))
  | String(op) => (String, String, typ_exp_binop_bin_string(op));

let typ_exp_unop: Term.UExp.op_un => (Typ.t, Typ.t) =
  fun
  | Int(Minus) => (Int, Int);

let rec any_to_info_map = (~ctx: Ctx.t, any: Term.any): (Ctx.co, map) =>
  switch (any) {
  | Exp(e) =>
    let (_, co, map) = uexp_to_info_map(~ctx, e);
    (co, map);
  | Pat(p) =>
    let (_, _, map) = upat_to_info_map(~is_synswitch=false, ~ctx, p);
    (VarMap.empty, map);
  | TPat(tp) =>
    let map = utpat_to_info_map(~ctx, tp);
    (VarMap.empty, map);
  | Typ(ty) =>
    let (_, map) = utyp_to_info_map(~ctx, ty);
    (VarMap.empty, map);
  | Rul(_)
  | Nul ()
  | Any () => (VarMap.empty, Id.Map.empty)
  }
and uexp_to_info_map =
    (~ctx: Ctx.t, ~mode=Typ.Syn, {ids, term} as uexp: Term.UExp.t)
    : (Typ.t, Ctx.co, map) => {
  /* Maybe switch mode to syn */
  let mode =
    switch (mode) {
    | Ana(Unknown(SynSwitch)) => Typ.Syn
    | _ => mode
    };
  let cls = Term.UExp.cls_of_term(term);
  let go = uexp_to_info_map(~ctx);
  let add = (~self, ~free, m) => (
    Info.typ_after_fix(ctx, mode, self),
    free,
    add_info(ids, InfoExp({cls, self, mode, ctx, free, term: uexp}), m),
  );
  let atomic = self => add(~self, ~free=[], Id.Map.empty);
  switch (term) {
  | Invalid(msg) => (
      Unknown(Internal),
      [],
      add_info(ids, Invalid(msg), Id.Map.empty),
    )
  | MultiHole(tms) =>
    let (free, maps) = tms |> List.map(any_to_info_map(~ctx)) |> List.split;
    add(~self=SelfMultiHole, ~free=Ctx.union(free), union_m(maps));
  | EmptyHole => atomic(Just(Unknown(Internal)))
  | Triv => atomic(Just(Prod([])))
  | Bool(_) => atomic(Just(Bool))
  | Int(_) => atomic(Just(Int))
  | Float(_) => atomic(Just(Float))
  | String(_) => atomic(Just(String))
  | ListLit([]) => atomic(Just(List(Unknown(Internal))))
  | ListLit(es) =>
    let modes = List.init(List.length(es), _ => Typ.matched_list_mode(mode));
    let e_ids = List.map(exp_id, es);
    let infos = List.map2((e, mode) => go(~mode, e), es, modes);
    let tys = List.map(((ty, _, _)) => ty, infos);
    let self: Info.self =
      switch (Typ.join_all(ctx, tys)) {
      | None => NoJoin(List.map2((id, ty) => Info.{id, ty}, e_ids, tys))
      | Some(ty) => Just(List(ty))
      };
    let free = Ctx.union(List.map(((_, f, _)) => f, infos));
    let m = union_m(List.map(((_, _, m)) => m, infos));
    add(~self, ~free, m);
  | Cons(e1, e2) =>
    let mode_e = Typ.matched_list_mode(mode);
    let (ty1, free1, m1) = go(~mode=mode_e, e1);
    let (_, free2, m2) = go(~mode=Ana(List(ty1)), e2);
    add(
      ~self=Just(List(ty1)),
      ~free=Ctx.union([free1, free2]),
      union_m([m1, m2]),
    );
  | Var(name) =>
    let self: Info.self = SelfVar(name);
    /*switch (Ctx.lookup_var(ctx, name)) {
      | None => Self(Free)
      | Some(var) => Just(var.typ)
      };*/
    add(~self, ~free=[(name, [{id: exp_id(uexp), mode}])], Id.Map.empty);
  | Parens(e) =>
    let (ty, free, m) = go(~mode, e);
    add(~self=Just(ty), ~free, m);
  | UnOp(op, e) =>
    let (ty_in, ty_out) = typ_exp_unop(op);
    let (_, free, m) = go(~mode=Ana(ty_in), e);
    add(~self=Just(ty_out), ~free, m);
  | BinOp(op, e1, e2) =>
    let (ty1, ty2, ty_out) = typ_exp_binop(op);
    let (_, free1, m1) = go(~mode=Ana(ty1), e1);
    let (_, free2, m2) = go(~mode=Ana(ty2), e2);
    add(
      ~self=Just(ty_out),
      ~free=Ctx.union([free1, free2]),
      union_m([m1, m2]),
    );
  | Tuple(es) =>
    let modes = Typ.matched_prod_mode(mode, List.length(es));
    let infos = List.map2((e, mode) => go(~mode, e), es, modes);
    let free = Ctx.union(List.map(((_, f, _)) => f, infos));
    let self = Info.Just(Prod(List.map(((ty, _, _)) => ty, infos)));
    let m = union_m(List.map(((_, _, m)) => m, infos));
    add(~self, ~free, m);
  | Test(test) =>
    let (_, free_test, m1) = go(~mode=Ana(Bool), test);
    add(~self=Just(Prod([])), ~free=free_test, m1);
  | If(cond, e1, e2) =>
    let (_, free_e0, m1) = go(~mode=Ana(Bool), cond);
    let (ty_e1, free_e1, m2) = go(~mode, e1);
    let (ty_e2, free_e2, m3) = go(~mode, e2);
    let self: Info.self =
      switch (Typ.join(ctx, ty_e1, ty_e2)) {
      | None =>
        NoJoin([{id: exp_id(e1), ty: ty_e1}, {id: exp_id(e2), ty: ty_e2}])
      | Some(ty) => Just(ty)
      };
    add(
      ~self,
      ~free=Ctx.union([free_e0, free_e1, free_e2]),
      union_m([m1, m2, m3]),
    );
  | Seq(e1, e2) =>
    let (_, free1, m1) = go(~mode=Syn, e1);
    let (ty2, free2, m2) = go(~mode, e2);
    add(
      ~self=Just(ty2),
      ~free=Ctx.union([free1, free2]),
      union_m([m1, m2]),
    );
  | Tag(name) => atomic(SelfTag(name))
  | Ap(fn, arg) =>
    let fn_mode =
      switch (fn) {
      | {term: Tag(name), _} => Typ.tag_ap_mode(ctx, mode, name)
      | _ => Typ.ap_mode
      };
    let (ty_fn, free_fn, m_fn) = uexp_to_info_map(~ctx, ~mode=fn_mode, fn);
    let (ty_in, ty_out) = Typ.matched_arrow(ty_fn);
    let (_, free_arg, m_arg) =
      uexp_to_info_map(~ctx, ~mode=Ana(ty_in), arg);
    add(
      ~self=Just(ty_out),
      ~free=Ctx.union([free_fn, free_arg]),
      union_m([m_fn, m_arg]),
    );
  | Fun(pat, body) =>
    let (mode_pat, mode_body) = Typ.matched_arrow_mode(mode);
    let (ty_pat, ctx_pat, m_pat) =
      upat_to_info_map(~is_synswitch=false, ~ctx, ~mode=mode_pat, pat);
    let (ty_body, free_body, m_body) =
      uexp_to_info_map(~ctx=ctx_pat, ~mode=mode_body, body);
    add(
      ~self=Just(Arrow(ty_pat, ty_body)),
      ~free=Ctx.free_in(ctx, ctx_pat, free_body),
      union_m([m_pat, m_body]),
    );
  | Let(pat, def, body) =>
    let (ty_pat, ctx_pat, _m_pat) =
      upat_to_info_map(~is_synswitch=true, ~ctx, ~mode=Syn, pat);
    let def_ctx = extend_let_def_ctx(ctx, pat, ctx_pat, def);
    let (ty_def, free_def, m_def) =
      uexp_to_info_map(~ctx=def_ctx, ~mode=Ana(ty_pat), def);
    /* Analyze pattern to incorporate def type into ctx */
    let (_, ctx_pat_ana, m_pat) =
      upat_to_info_map(~is_synswitch=false, ~ctx, ~mode=Ana(ty_def), pat);
    let (ty_body, free_body, m_body) =
      uexp_to_info_map(~ctx=ctx_pat_ana, ~mode, body);
    add(
      ~self=Just(ty_body),
      ~free=Ctx.union([free_def, Ctx.free_in(ctx, ctx_pat_ana, free_body)]),
      union_m([m_pat, m_def, m_body]),
    );
  | TyAlias(typat, utyp, body) =>
    let m_typat = utpat_to_info_map(~ctx, typat);
    let ty = Term.UTyp.to_typ(ctx, utyp);
    switch (typat.term) {
    | Var(name) =>
      let ty_rec =
        List.mem(name, Typ.free_vars(ty)) ? Typ.Rec(name, ty) : ty;
      let ctx = Ctx.add_alias(ctx, name, utpat_id(typat), ty_rec);
      let ctx =
        switch (ty_rec) {
        | Sum(sm)
        | Rec(_, Sum(sm)) => Ctx.add_tags(ctx, name, typ_id(utyp), sm)
        | _ => ctx
        };
      let (ty_body, free, m_body) = uexp_to_info_map(~ctx, ~mode, body);
      let ty_escape = Typ.subst(ty_rec, name, ty_body);
      let m_typ = utyp_to_info_map(~ctx, utyp) |> snd;
      add(~self=Just(ty_escape), ~free, union_m([m_typat, m_body, m_typ]));
    | _ =>
      let (ty_body, free, m_body) = uexp_to_info_map(~ctx, ~mode, body);
      let m_typ = utyp_to_info_map(~ctx, utyp) |> snd;
      add(~self=Just(ty_body), ~free, union_m([m_typat, m_body, m_typ]));
    };
  | Match(scrut, rules) =>
    let (ty_scrut, free_scrut, m_scrut) = go(~mode=Syn, scrut);
    let (pats, branches) = List.split(rules);
    let pat_infos =
      List.map(
        upat_to_info_map(~is_synswitch=false, ~ctx, ~mode=Typ.Ana(ty_scrut)),
        pats,
      );
    let branch_infos =
      List.map2(
        (branch, (_, ctx_pat, _)) =>
          uexp_to_info_map(~ctx=ctx_pat, ~mode, branch),
        branches,
        pat_infos,
      );
    let branch_sources =
      List.map2(
        (e: Term.UExp.t, (ty, _, _)) => Info.{id: exp_id(e), ty},
        branches,
        branch_infos,
      );
    let pat_ms = List.map(((_, _, m)) => m, pat_infos);
    let branch_ms = List.map(((_, _, m)) => m, branch_infos);

    let branch_frees =
      List.map2(
        ((_, free, _), (_, ctx_pat, _)) => Ctx.free_in(ctx, ctx_pat, free),
        branch_infos,
        pat_infos,
      );
    let self: Info.self =
      switch (Typ.join_all(ctx, Info.source_tys(branch_sources))) {
      | None => NoJoin(branch_sources)
      | Some(ty) => Just(ty)
      };
    let free = Ctx.union([free_scrut] @ branch_frees);
    add(~self, ~free, union_m([m_scrut] @ pat_ms @ branch_ms));
  };
}
and upat_to_info_map =
    (
      ~is_synswitch,
      ~ctx,
      ~mode: Typ.mode=Typ.Syn,
      {ids, term} as upat: Term.UPat.t,
    )
    : (Typ.t, Ctx.t, map) => {
  let upat_to_info_map = upat_to_info_map(~is_synswitch);
  let unknown = Typ.Unknown(is_synswitch ? SynSwitch : Internal);
  let cls = Term.UPat.cls_of_term(term);
  let add = (~self, ~ctx, m) => (
    Info.typ_after_fix(ctx, mode, self),
    ctx,
    add_info(ids, InfoPat({cls, self, mode, ctx, term: upat}), m),
  );
  let atomic = self => add(~self, ~ctx, Id.Map.empty);
  switch (term) {
  | Invalid(msg) => (
      Unknown(Internal),
      ctx,
      add_info(ids, Invalid(msg), Id.Map.empty),
    )
  | MultiHole(tms) =>
    let (_, maps) = tms |> List.map(any_to_info_map(~ctx)) |> List.split;
    add(~self=SelfMultiHole, ~ctx, union_m(maps));
  | EmptyHole => atomic(Just(unknown))
  | Int(_) => atomic(Just(Int))
  | Float(_) => atomic(Just(Float))
  | Triv => atomic(Just(Prod([])))
  | Bool(_) => atomic(Just(Bool))
  | String(_) => atomic(Just(String))
  | ListLit([]) => atomic(Just(List(Unknown(Internal))))
  | ListLit(ps) =>
    let modes = List.init(List.length(ps), _ => Typ.matched_list_mode(mode));
    let p_ids = List.map(pat_id, ps);
    let (ctx, infos) =
      List.fold_left2(
        ((ctx, infos), e, mode) => {
          let (_, ctx, _) as info = upat_to_info_map(~ctx, ~mode, e);
          (ctx, infos @ [info]);
        },
        (ctx, []),
        ps,
        modes,
      );
    let tys = List.map(((ty, _, _)) => ty, infos);
    let self: Info.self =
      switch (Typ.join_all(ctx, tys)) {
      | None => NoJoin(List.map2((id, ty) => Info.{id, ty}, p_ids, tys))
      | Some(ty) => Just(List(ty))
      };
    let info: Info.t = InfoPat({cls, self, mode, ctx, term: upat});
    let m = union_m(List.map(((_, _, m)) => m, infos));
    /* Add an entry for the id of each comma tile */
    let m = List.fold_left((m, id) => Id.Map.add(id, info, m), m, ids);
    (Info.typ_after_fix(ctx, mode, self), ctx, m);
  | Cons(hd, tl) =>
    let mode_e = Typ.matched_list_mode(mode);
    let (ty1, ctx, m_hd) = upat_to_info_map(~ctx, ~mode=mode_e, hd);
    let (_, ctx, m_tl) = upat_to_info_map(~ctx, ~mode=Ana(List(ty1)), tl);
    add(~self=Just(List(ty1)), ~ctx, union_m([m_hd, m_tl]));
  | Wild => atomic(Just(unknown))
  | Var(name) =>
    let typ = Info.typ_after_fix(ctx, mode, Just(Unknown(Internal)));
    let entry = Ctx.VarEntry({name, id: pat_id(upat), typ});
    add(~self=Just(unknown), ~ctx=Ctx.extend(entry, ctx), Id.Map.empty);
  | Tuple(ps) =>
    let modes = Typ.matched_prod_mode(mode, List.length(ps));
    let (ctx, infos) =
      List.fold_left2(
        ((ctx, infos), e, mode) => {
          let (_, ctx, _) as info = upat_to_info_map(~mode, ~ctx, e);
          (ctx, infos @ [info]);
        },
        (ctx, []),
        ps,
        modes,
      );
    let self = Info.Just(Prod(List.map(((ty, _, _)) => ty, infos)));
    let m = union_m(List.map(((_, _, m)) => m, infos));
    add(~self, ~ctx, m);
  | Parens(p) =>
    let (ty, ctx, m) = upat_to_info_map(~ctx, ~mode, p);
    add(~self=Just(ty), ~ctx, m);
  | Tag(name) => atomic(SelfTag(name))
  | Ap(fn, arg) =>
    /* Constructors */
    let fn_mode =
      switch (fn) {
      | {term: Tag(name), _} => Typ.tag_ap_mode(ctx, mode, name)
      | _ => Typ.ap_mode
      };
    let (ty_fn, ctx, m_fn) = upat_to_info_map(~ctx, ~mode=fn_mode, fn);
    let (ty_in, ty_out) = Typ.matched_arrow(ty_fn);
    let (_, ctx, m_arg) = upat_to_info_map(~ctx, ~mode=Ana(ty_in), arg);
    add(~self=Just(ty_out), ~ctx, union_m([m_fn, m_arg]));
  | TypeAnn(p, ty) =>
    let (ty_ann, m_typ) = utyp_to_info_map(~ctx, ty);
    let (_, ctx, m) = upat_to_info_map(~ctx, ~mode=Ana(ty_ann), p);
    add(~self=Just(ty_ann), ~ctx, union_m([m, m_typ]));
  };
}
and utyp_to_info_map =
    (~ctx, ~mode=Info.TypeExpected, {ids, term} as utyp: Term.UTyp.t)
    : (Typ.t, map) => {
  let cls: Term.UTyp.cls =
    switch (mode, Term.UTyp.cls_of_term(term)) {
    | (VariantExpected(_), Var) => Tag
    | (_, cls) => cls
    };
  let ty = Term.UTyp.to_typ(ctx, utyp);
  let add = self =>
    add_info(ids, InfoTyp({cls, ctx, mode, self, term: utyp}));
  let add = (~self, m: map): (Typ.t, map) => (ty, add(self, m));
  let add_type = add(~self=Type(ty));
  let go = utyp_to_info_map(~ctx, ~mode=TypeExpected);
  //TODO(andrew): make this return free, replacing Typ.free_vars
  switch (term) {
  | EmptyHole => add(~self=EmptyHole, Id.Map.empty)
  | Int
  | Float
  | Bool
  | String =>
    let m = Id.Map.empty;
    add_type(m);
  | List(t)
  | Parens(t) =>
    let m = go(t) |> snd;
    add_type(m);
  | Arrow(t1, t2) =>
    let m = union_m([go(t1) |> snd, go(t2) |> snd]);
    add_type(m);
  | Tuple(ts) =>
    let m = ts |> List.map(go) |> List.map(snd) |> union_m;
    add_type(m);
  | Var(name)
  | Tag(name) =>
    let m = Id.Map.empty;
    add(~self=Tag(name), m);
  | Ap(t1, t2) =>
    let t1_mode: Info.typ_mode =
      switch (mode) {
      | VariantExpected(m) => TagExpected(m)
      | _ => TagExpected(Unique)
      };
    let m =
      union_m([
        utyp_to_info_map(~ctx, ~mode=t1_mode, t1) |> snd,
        utyp_to_info_map(~ctx, ~mode=TypeExpected, t2) |> snd,
      ]);
    add(~self=Ap, m);
  | USum(ts) =>
    let (ms, _) =
      List.fold_left(
        ((acc, tags), ut) => {
          let (status, tag) =
            switch (Term.UTyp.get_tag(ctx, ut)) {
            | None => (Info.Unique, [])
            | Some(tag) when !List.mem(tag, tags) => (Unique, [tag])
            | Some(tag) => (Duplicate, [tag])
            };
          let m =
            utyp_to_info_map(~ctx, ~mode=VariantExpected(status), ut) |> snd;
          (acc @ [m], tags @ tag);
        },
        ([], []),
        ts,
      );
    add_type(union_m(ms));
  | MultiHole(tms) =>
    let (_, maps) = tms |> List.map(any_to_info_map(~ctx)) |> List.split;
    add_type(union_m(maps));
  };
}
and utpat_to_info_map = (~ctx, {ids, term} as utpat: Term.UTPat.t): map => {
  let cls = Term.UTPat.cls_of_term(term);
  add_info(ids, InfoTPat({cls, ctx, term: utpat}), Id.Map.empty);
};

let mk_map =
  Core.Memo.general(
    ~cache_size_bound=1000,
    e => {
      let (_, _, map) =
        uexp_to_info_map(~ctx=Builtins.ctx(Builtins.Pervasives.builtins), e);
      map;
    },
  );
let get_binding_site = (info: Info.t): option(Id.t) => {
  let* info_exp =
    switch (info) {
    | InfoExp(info_exp) => Some(info_exp)
    | _ => None
    };
  let+ entry =
    switch (info_exp.term.term) {
    | TermBase.UExp.Var(name) => Ctx.lookup_var(info_exp.ctx, name)
    | _ => None
    };
  entry.id;
};
