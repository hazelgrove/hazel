#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Capture/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CAPTURE_TINY';
  use 5.006;
  use strict;
  use warnings;
  package Capture::Tiny;
  # ABSTRACT: Capture STDOUT and STDERR from Perl, XS or external programs
  our $VERSION = '0.48';
  use Carp ();
  use Exporter ();
  use IO::Handle ();
  use File::Spec ();
  use File::Temp qw/tempfile tmpnam/;
  use Scalar::Util qw/reftype blessed/;
  # Get PerlIO or fake it
  BEGIN {
    local $@;
    eval { require PerlIO; PerlIO->can('get_layers') }
      or *PerlIO::get_layers = sub { return () };
  }
  
  #--------------------------------------------------------------------------#
  # create API subroutines and export them
  # [do STDOUT flag, do STDERR flag, do merge flag, do tee flag]
  #--------------------------------------------------------------------------#
  
  my %api = (
    capture         => [1,1,0,0],
    capture_stdout  => [1,0,0,0],
    capture_stderr  => [0,1,0,0],
    capture_merged  => [1,1,1,0],
    tee             => [1,1,0,1],
    tee_stdout      => [1,0,0,1],
    tee_stderr      => [0,1,0,1],
    tee_merged      => [1,1,1,1],
  );
  
  for my $sub ( keys %api ) {
    my $args = join q{, }, @{$api{$sub}};
    eval "sub $sub(&;@) {unshift \@_, $args; goto \\&_capture_tee;}"; ## no critic
  }
  
  our @ISA = qw/Exporter/;
  our @EXPORT_OK = keys %api;
  our %EXPORT_TAGS = ( 'all' => \@EXPORT_OK );
  
  #--------------------------------------------------------------------------#
  # constants and fixtures
  #--------------------------------------------------------------------------#
  
  my $IS_WIN32 = $^O eq 'MSWin32';
  
  ##our $DEBUG = $ENV{PERL_CAPTURE_TINY_DEBUG};
  ##
  ##my $DEBUGFH;
  ##open $DEBUGFH, "> DEBUG" if $DEBUG;
  ##
  ##*_debug = $DEBUG ? sub(@) { print {$DEBUGFH} @_ } : sub(){0};
  
  our $TIMEOUT = 30;
  
  #--------------------------------------------------------------------------#
  # command to tee output -- the argument is a filename that must
  # be opened to signal that the process is ready to receive input.
  # This is annoying, but seems to be the best that can be done
  # as a simple, portable IPC technique
  #--------------------------------------------------------------------------#
  my @cmd = ($^X, '-C0', '-e', <<'HERE');
  use Fcntl;
  $SIG{HUP}=sub{exit};
  if ( my $fn=shift ) {
      sysopen(my $fh, qq{$fn}, O_WRONLY|O_CREAT|O_EXCL) or die $!;
      print {$fh} $$;
      close $fh;
  }
  my $buf; while (sysread(STDIN, $buf, 2048)) {
      syswrite(STDOUT, $buf); syswrite(STDERR, $buf);
  }
  HERE
  
  #--------------------------------------------------------------------------#
  # filehandle manipulation
  #--------------------------------------------------------------------------#
  
  sub _relayer {
    my ($fh, $apply_layers) = @_;
    # _debug("# requested layers (@{$layers}) for @{[fileno $fh]}\n");
  
    # eliminate pseudo-layers
    binmode( $fh, ":raw" );
    # strip off real layers until only :unix is left
    while ( 1 < ( my $layers =()= PerlIO::get_layers( $fh, output => 1 ) ) ) {
        binmode( $fh, ":pop" );
    }
    # apply other layers
    my @to_apply = @$apply_layers;
    shift @to_apply; # eliminate initial :unix
    # _debug("# applying layers  (unix @to_apply) to @{[fileno $fh]}\n");
    binmode($fh, ":" . join(":",@to_apply));
  }
  
  sub _name {
    my $glob = shift;
    no strict 'refs'; ## no critic
    return *{$glob}{NAME};
  }
  
  sub _open {
    open $_[0], $_[1] or Carp::confess "Error from open(" . join(q{, }, @_) . "): $!";
    # _debug( "# open " . join( ", " , map { defined $_ ? _name($_) : 'undef' } @_ ) . " as " . fileno( $_[0] ) . "\n" );
  }
  
  sub _close {
    # _debug( "# closing " . ( defined $_[0] ? _name($_[0]) : 'undef' )  . " on " . fileno( $_[0] ) . "\n" );
    close $_[0] or Carp::confess "Error from close(" . join(q{, }, @_) . "): $!";
  }
  
  my %dup; # cache this so STDIN stays fd0
  my %proxy_count;
  sub _proxy_std {
    my %proxies;
    if ( ! defined fileno STDIN ) {
      $proxy_count{stdin}++;
      if (defined $dup{stdin}) {
        _open \*STDIN, "<&=" . fileno($dup{stdin});
        # _debug( "# restored proxy STDIN as " . (defined fileno STDIN ? fileno STDIN : 'undef' ) . "\n" );
      }
      else {
        _open \*STDIN, "<" . File::Spec->devnull;
        # _debug( "# proxied STDIN as " . (defined fileno STDIN ? fileno STDIN : 'undef' ) . "\n" );
        _open $dup{stdin} = IO::Handle->new, "<&=STDIN";
      }
      $proxies{stdin} = \*STDIN;
      binmode(STDIN, ':utf8') if $] >= 5.008; ## no critic
    }
    if ( ! defined fileno STDOUT ) {
      $proxy_count{stdout}++;
      if (defined $dup{stdout}) {
        _open \*STDOUT, ">&=" . fileno($dup{stdout});
        # _debug( "# restored proxy STDOUT as " . (defined fileno STDOUT ? fileno STDOUT : 'undef' ) . "\n" );
      }
      else {
        _open \*STDOUT, ">" . File::Spec->devnull;
         # _debug( "# proxied STDOUT as " . (defined fileno STDOUT ? fileno STDOUT : 'undef' ) . "\n" );
        _open $dup{stdout} = IO::Handle->new, ">&=STDOUT";
      }
      $proxies{stdout} = \*STDOUT;
      binmode(STDOUT, ':utf8') if $] >= 5.008; ## no critic
    }
    if ( ! defined fileno STDERR ) {
      $proxy_count{stderr}++;
      if (defined $dup{stderr}) {
        _open \*STDERR, ">&=" . fileno($dup{stderr});
         # _debug( "# restored proxy STDERR as " . (defined fileno STDERR ? fileno STDERR : 'undef' ) . "\n" );
      }
      else {
        _open \*STDERR, ">" . File::Spec->devnull;
         # _debug( "# proxied STDERR as " . (defined fileno STDERR ? fileno STDERR : 'undef' ) . "\n" );
        _open $dup{stderr} = IO::Handle->new, ">&=STDERR";
      }
      $proxies{stderr} = \*STDERR;
      binmode(STDERR, ':utf8') if $] >= 5.008; ## no critic
    }
    return %proxies;
  }
  
  sub _unproxy {
    my (%proxies) = @_;
    # _debug( "# unproxying: " . join(" ", keys %proxies) . "\n" );
    for my $p ( keys %proxies ) {
      $proxy_count{$p}--;
      # _debug( "# unproxied " . uc($p) . " ($proxy_count{$p} left)\n" );
      if ( ! $proxy_count{$p} ) {
        _close $proxies{$p};
        _close $dup{$p} unless $] < 5.008; # 5.6 will have already closed this as dup
        delete $dup{$p};
      }
    }
  }
  
  sub _copy_std {
    my %handles;
    for my $h ( qw/stdout stderr stdin/ ) {
      next if $h eq 'stdin' && ! $IS_WIN32; # WIN32 hangs on tee without STDIN copied
      my $redir = $h eq 'stdin' ? "<&" : ">&";
      _open $handles{$h} = IO::Handle->new(), $redir . uc($h); # ">&STDOUT" or "<&STDIN"
    }
    return \%handles;
  }
  
  # In some cases we open all (prior to forking) and in others we only open
  # the output handles (setting up redirection)
  sub _open_std {
    my ($handles) = @_;
    _open \*STDIN, "<&" . fileno $handles->{stdin} if defined $handles->{stdin};
    _open \*STDOUT, ">&" . fileno $handles->{stdout} if defined $handles->{stdout};
    _open \*STDERR, ">&" . fileno $handles->{stderr} if defined $handles->{stderr};
  }
  
  #--------------------------------------------------------------------------#
  # private subs
  #--------------------------------------------------------------------------#
  
  sub _start_tee {
    my ($which, $stash) = @_; # $which is "stdout" or "stderr"
    # setup pipes
    $stash->{$_}{$which} = IO::Handle->new for qw/tee reader/;
    pipe $stash->{reader}{$which}, $stash->{tee}{$which};
    # _debug( "# pipe for $which\: " .  _name($stash->{tee}{$which}) . " " . fileno( $stash->{tee}{$which} ) . " => " . _name($stash->{reader}{$which}) . " " . fileno( $stash->{reader}{$which}) . "\n" );
    select((select($stash->{tee}{$which}), $|=1)[0]); # autoflush
    # setup desired redirection for parent and child
    $stash->{new}{$which} = $stash->{tee}{$which};
    $stash->{child}{$which} = {
      stdin   => $stash->{reader}{$which},
      stdout  => $stash->{old}{$which},
      stderr  => $stash->{capture}{$which},
    };
    # flag file is used to signal the child is ready
    $stash->{flag_files}{$which} = scalar( tmpnam() ) . $$;
    # execute @cmd as a separate process
    if ( $IS_WIN32 ) {
      my $old_eval_err=$@;
      undef $@;
  
      eval "use Win32API::File qw/GetOsFHandle SetHandleInformation fileLastError HANDLE_FLAG_INHERIT INVALID_HANDLE_VALUE/ ";
      # _debug( "# Win32API::File loaded\n") unless $@;
      my $os_fhandle = GetOsFHandle( $stash->{tee}{$which} );
      # _debug( "# Couldn't get OS handle: " . fileLastError() . "\n") if ! defined $os_fhandle || $os_fhandle == INVALID_HANDLE_VALUE();
      my $result = SetHandleInformation( $os_fhandle, HANDLE_FLAG_INHERIT(), 0);
      # _debug( $result ? "# set no-inherit flag on $which tee\n" : ("# can't disable tee handle flag inherit: " . fileLastError() . "\n"));
      _open_std( $stash->{child}{$which} );
      $stash->{pid}{$which} = system(1, @cmd, $stash->{flag_files}{$which});
      # not restoring std here as it all gets redirected again shortly anyway
      $@=$old_eval_err;
    }
    else { # use fork
      _fork_exec( $which, $stash );
    }
  }
  
  sub _fork_exec {
    my ($which, $stash) = @_; # $which is "stdout" or "stderr"
    my $pid = fork;
    if ( not defined $pid ) {
      Carp::confess "Couldn't fork(): $!";
    }
    elsif ($pid == 0) { # child
      # _debug( "# in child process ...\n" );
      untie *STDIN; untie *STDOUT; untie *STDERR;
      _close $stash->{tee}{$which};
      # _debug( "# redirecting handles in child ...\n" );
      _open_std( $stash->{child}{$which} );
      # _debug( "# calling exec on command ...\n" );
      exec @cmd, $stash->{flag_files}{$which};
    }
    $stash->{pid}{$which} = $pid
  }
  
  my $have_usleep = eval "use Time::HiRes 'usleep'; 1";
  sub _files_exist {
    return 1 if @_ == grep { -f } @_;
    Time::HiRes::usleep(1000) if $have_usleep;
    return 0;
  }
  
  sub _wait_for_tees {
    my ($stash) = @_;
    my $start = time;
    my @files = values %{$stash->{flag_files}};
    my $timeout = defined $ENV{PERL_CAPTURE_TINY_TIMEOUT}
                ? $ENV{PERL_CAPTURE_TINY_TIMEOUT} : $TIMEOUT;
    1 until _files_exist(@files) || ($timeout && (time - $start > $timeout));
    Carp::confess "Timed out waiting for subprocesses to start" if ! _files_exist(@files);
    unlink $_ for @files;
  }
  
  sub _kill_tees {
    my ($stash) = @_;
    if ( $IS_WIN32 ) {
      # _debug( "# closing handles\n");
      close($_) for values %{ $stash->{tee} };
      # _debug( "# waiting for subprocesses to finish\n");
      my $start = time;
      1 until wait == -1 || (time - $start > 30);
    }
    else {
      _close $_ for values %{ $stash->{tee} };
      waitpid $_, 0 for values %{ $stash->{pid} };
    }
  }
  
  sub _slurp {
    my ($name, $stash) = @_;
    my ($fh, $pos) = map { $stash->{$_}{$name} } qw/capture pos/;
    # _debug( "# slurping captured $name from " . fileno($fh) . " at pos $pos with layers: @{[PerlIO::get_layers($fh)]}\n");
    seek( $fh, $pos, 0 ) or die "Couldn't seek on capture handle for $name\n";
    my $text = do { local $/; scalar readline $fh };
    return defined($text) ? $text : "";
  }
  
  #--------------------------------------------------------------------------#
  # _capture_tee() -- generic main sub for capturing or teeing
  #--------------------------------------------------------------------------#
  
  sub _capture_tee {
    # _debug( "# starting _capture_tee with (@_)...\n" );
    my ($do_stdout, $do_stderr, $do_merge, $do_tee, $code, @opts) = @_;
    my %do = ($do_stdout ? (stdout => 1) : (),  $do_stderr ? (stderr => 1) : ());
    Carp::confess("Custom capture options must be given as key/value pairs\n")
      unless @opts % 2 == 0;
    my $stash = { capture => { @opts } };
    for ( keys %{$stash->{capture}} ) {
      my $fh = $stash->{capture}{$_};
      Carp::confess "Custom handle for $_ must be seekable\n"
        unless ref($fh) eq 'GLOB' || (blessed($fh) && $fh->isa("IO::Seekable"));
    }
    # save existing filehandles and setup captures
    local *CT_ORIG_STDIN  = *STDIN ;
    local *CT_ORIG_STDOUT = *STDOUT;
    local *CT_ORIG_STDERR = *STDERR;
    # find initial layers
    my %layers = (
      stdin   => [PerlIO::get_layers(\*STDIN) ],
      stdout  => [PerlIO::get_layers(\*STDOUT, output => 1)],
      stderr  => [PerlIO::get_layers(\*STDERR, output => 1)],
    );
    # _debug( "# existing layers for $_\: @{$layers{$_}}\n" ) for qw/stdin stdout stderr/;
    # get layers from underlying glob of tied filehandles if we can
    # (this only works for things that work like Tie::StdHandle)
    $layers{stdout} = [PerlIO::get_layers(tied *STDOUT)]
      if tied(*STDOUT) && (reftype tied *STDOUT eq 'GLOB');
    $layers{stderr} = [PerlIO::get_layers(tied *STDERR)]
      if tied(*STDERR) && (reftype tied *STDERR eq 'GLOB');
    # _debug( "# tied object corrected layers for $_\: @{$layers{$_}}\n" ) for qw/stdin stdout stderr/;
    # bypass scalar filehandles and tied handles
    # localize scalar STDIN to get a proxy to pick up FD0, then restore later to CT_ORIG_STDIN
    my %localize;
    $localize{stdin}++,  local(*STDIN)
      if grep { $_ eq 'scalar' } @{$layers{stdin}};
    $localize{stdout}++, local(*STDOUT)
      if $do_stdout && grep { $_ eq 'scalar' } @{$layers{stdout}};
    $localize{stderr}++, local(*STDERR)
      if ($do_stderr || $do_merge) && grep { $_ eq 'scalar' } @{$layers{stderr}};
    $localize{stdin}++, local(*STDIN), _open( \*STDIN, "<&=0")
      if tied *STDIN && $] >= 5.008;
    $localize{stdout}++, local(*STDOUT), _open( \*STDOUT, ">&=1")
      if $do_stdout && tied *STDOUT && $] >= 5.008;
    $localize{stderr}++, local(*STDERR), _open( \*STDERR, ">&=2")
      if ($do_stderr || $do_merge) && tied *STDERR && $] >= 5.008;
    # _debug( "# localized $_\n" ) for keys %localize;
    # proxy any closed/localized handles so we don't use fds 0, 1 or 2
    my %proxy_std = _proxy_std();
    # _debug( "# proxy std: @{ [%proxy_std] }\n" );
    # update layers after any proxying
    $layers{stdout} = [PerlIO::get_layers(\*STDOUT, output => 1)] if $proxy_std{stdout};
    $layers{stderr} = [PerlIO::get_layers(\*STDERR, output => 1)] if $proxy_std{stderr};
    # _debug( "# post-proxy layers for $_\: @{$layers{$_}}\n" ) for qw/stdin stdout stderr/;
    # store old handles and setup handles for capture
    $stash->{old} = _copy_std();
    $stash->{new} = { %{$stash->{old}} }; # default to originals
    for ( keys %do ) {
      $stash->{new}{$_} = ($stash->{capture}{$_} ||= File::Temp->new);
      seek( $stash->{capture}{$_}, 0, 2 ) or die "Could not seek on capture handle for $_\n";
      $stash->{pos}{$_} = tell $stash->{capture}{$_};
      # _debug("# will capture $_ on " . fileno($stash->{capture}{$_})."\n" );
      _start_tee( $_ => $stash ) if $do_tee; # tees may change $stash->{new}
    }
    _wait_for_tees( $stash ) if $do_tee;
    # finalize redirection
    $stash->{new}{stderr} = $stash->{new}{stdout} if $do_merge;
    # _debug( "# redirecting in parent ...\n" );
    _open_std( $stash->{new} );
    # execute user provided code
    my ($exit_code, $inner_error, $outer_error, $orig_pid, @result);
    {
      $orig_pid = $$;
      local *STDIN = *CT_ORIG_STDIN if $localize{stdin}; # get original, not proxy STDIN
      # _debug( "# finalizing layers ...\n" );
      _relayer(\*STDOUT, $layers{stdout}) if $do_stdout;
      _relayer(\*STDERR, $layers{stderr}) if $do_stderr;
      # _debug( "# running code $code ...\n" );
      my $old_eval_err=$@;
      undef $@;
      eval { @result = $code->(); $inner_error = $@ };
      $exit_code = $?; # save this for later
      $outer_error = $@; # save this for later
      STDOUT->flush if $do_stdout;
      STDERR->flush if $do_stderr;
      $@ = $old_eval_err;
    }
    # restore prior filehandles and shut down tees
    # _debug( "# restoring filehandles ...\n" );
    _open_std( $stash->{old} );
    _close( $_ ) for values %{$stash->{old}}; # don't leak fds
    # shouldn't need relayering originals, but see rt.perl.org #114404
    _relayer(\*STDOUT, $layers{stdout}) if $do_stdout;
    _relayer(\*STDERR, $layers{stderr}) if $do_stderr;
    _unproxy( %proxy_std );
    # _debug( "# killing tee subprocesses ...\n" ) if $do_tee;
    _kill_tees( $stash ) if $do_tee;
    # return captured output, but shortcut in void context
    # unless we have to echo output to tied/scalar handles;
    my %got;
    if ( $orig_pid == $$ and ( defined wantarray or ($do_tee && keys %localize) ) ) {
      for ( keys %do ) {
        _relayer($stash->{capture}{$_}, $layers{$_});
        $got{$_} = _slurp($_, $stash);
        # _debug("# slurped " . length($got{$_}) . " bytes from $_\n");
      }
      print CT_ORIG_STDOUT $got{stdout}
        if $do_stdout && $do_tee && $localize{stdout};
      print CT_ORIG_STDERR $got{stderr}
        if $do_stderr && $do_tee && $localize{stderr};
    }
    $? = $exit_code;
    $@ = $inner_error if $inner_error;
    die $outer_error if $outer_error;
    # _debug( "# ending _capture_tee with (@_)...\n" );
    return unless defined wantarray;
    my @return;
    push @return, $got{stdout} if $do_stdout;
    push @return, $got{stderr} if $do_stderr && ! $do_merge;
    push @return, @result;
    return wantarray ? @return : $return[0];
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  Capture::Tiny - Capture STDOUT and STDERR from Perl, XS or external programs
  
  =head1 VERSION
  
  version 0.48
  
  =head1 SYNOPSIS
  
    use Capture::Tiny ':all';
  
    # capture from external command
  
    ($stdout, $stderr, $exit) = capture {
      system( $cmd, @args );
    };
  
    # capture from arbitrary code (Perl or external)
  
    ($stdout, $stderr, @result) = capture {
      # your code here
    };
  
    # capture partial or merged output
  
    $stdout = capture_stdout { ... };
    $stderr = capture_stderr { ... };
    $merged = capture_merged { ... };
  
    # tee output
  
    ($stdout, $stderr) = tee {
      # your code here
    };
  
    $stdout = tee_stdout { ... };
    $stderr = tee_stderr { ... };
    $merged = tee_merged { ... };
  
  =head1 DESCRIPTION
  
  Capture::Tiny provides a simple, portable way to capture almost anything sent
  to STDOUT or STDERR, regardless of whether it comes from Perl, from XS code or
  from an external program.  Optionally, output can be teed so that it is
  captured while being passed through to the original filehandles.  Yes, it even
  works on Windows (usually).  Stop guessing which of a dozen capturing modules
  to use in any particular situation and just use this one.
  
  =head1 USAGE
  
  The following functions are available.  None are exported by default.
  
  =head2 capture
  
    ($stdout, $stderr, @result) = capture \&code;
    $stdout = capture \&code;
  
  The C<capture> function takes a code reference and returns what is sent to
  STDOUT and STDERR as well as any return values from the code reference.  In
  scalar context, it returns only STDOUT.  If no output was received for a
  filehandle, it returns an empty string for that filehandle.  Regardless of calling
  context, all output is captured -- nothing is passed to the existing filehandles.
  
  It is prototyped to take a subroutine reference as an argument. Thus, it
  can be called in block form:
  
    ($stdout, $stderr) = capture {
      # your code here ...
    };
  
  Note that the coderef is evaluated in list context.  If you wish to force
  scalar context on the return value, you must use the C<scalar> keyword.
  
    ($stdout, $stderr, $count) = capture {
      my @list = qw/one two three/;
      return scalar @list; # $count will be 3
    };
  
  Also note that within the coderef, the C<@_> variable will be empty.  So don't
  use arguments from a surrounding subroutine without copying them to an array
  first:
  
    sub wont_work {
      my ($stdout, $stderr) = capture { do_stuff( @_ ) };    # WRONG
      ...
    }
  
    sub will_work {
      my @args = @_;
      my ($stdout, $stderr) = capture { do_stuff( @args ) }; # RIGHT
      ...
    }
  
  Captures are normally done to an anonymous temporary filehandle.  To
  capture via a named file (e.g. to externally monitor a long-running capture),
  provide custom filehandles as a trailing list of option pairs:
  
    my $out_fh = IO::File->new("out.txt", "w+");
    my $err_fh = IO::File->new("out.txt", "w+");
    capture { ... } stdout => $out_fh, stderr => $err_fh;
  
  The filehandles must be read/write and seekable.  Modifying the files or
  filehandles during a capture operation will give unpredictable results.
  Existing IO layers on them may be changed by the capture.
  
  When called in void context, C<capture> saves memory and time by
  not reading back from the capture handles.
  
  =head2 capture_stdout
  
    ($stdout, @result) = capture_stdout \&code;
    $stdout = capture_stdout \&code;
  
  The C<capture_stdout> function works just like C<capture> except only
  STDOUT is captured.  STDERR is not captured.
  
  =head2 capture_stderr
  
    ($stderr, @result) = capture_stderr \&code;
    $stderr = capture_stderr \&code;
  
  The C<capture_stderr> function works just like C<capture> except only
  STDERR is captured.  STDOUT is not captured.
  
  =head2 capture_merged
  
    ($merged, @result) = capture_merged \&code;
    $merged = capture_merged \&code;
  
  The C<capture_merged> function works just like C<capture> except STDOUT and
  STDERR are merged. (Technically, STDERR is redirected to the same capturing
  handle as STDOUT before executing the function.)
  
  Caution: STDOUT and STDERR output in the merged result are not guaranteed to be
  properly ordered due to buffering.
  
  =head2 tee
  
    ($stdout, $stderr, @result) = tee \&code;
    $stdout = tee \&code;
  
  The C<tee> function works just like C<capture>, except that output is captured
  as well as passed on to the original STDOUT and STDERR.
  
  When called in void context, C<tee> saves memory and time by
  not reading back from the capture handles, except when the
  original STDOUT OR STDERR were tied or opened to a scalar
  handle.
  
  =head2 tee_stdout
  
    ($stdout, @result) = tee_stdout \&code;
    $stdout = tee_stdout \&code;
  
  The C<tee_stdout> function works just like C<tee> except only
  STDOUT is teed.  STDERR is not teed (output goes to STDERR as usual).
  
  =head2 tee_stderr
  
    ($stderr, @result) = tee_stderr \&code;
    $stderr = tee_stderr \&code;
  
  The C<tee_stderr> function works just like C<tee> except only
  STDERR is teed.  STDOUT is not teed (output goes to STDOUT as usual).
  
  =head2 tee_merged
  
    ($merged, @result) = tee_merged \&code;
    $merged = tee_merged \&code;
  
  The C<tee_merged> function works just like C<capture_merged> except that output
  is captured as well as passed on to STDOUT.
  
  Caution: STDOUT and STDERR output in the merged result are not guaranteed to be
  properly ordered due to buffering.
  
  =head1 LIMITATIONS
  
  =head2 Portability
  
  Portability is a goal, not a guarantee.  C<tee> requires fork, except on
  Windows where C<system(1, @cmd)> is used instead.  Not tested on any
  particularly esoteric platforms yet.  See the
  L<CPAN Testers Matrix|http://matrix.cpantesters.org/?dist=Capture-Tiny>
  for test result by platform.
  
  =head2 PerlIO layers
  
  Capture::Tiny does its best to preserve PerlIO layers such as ':utf8' or
  ':crlf' when capturing (only for Perl 5.8.1+) .  Layers should be applied to
  STDOUT or STDERR I<before> the call to C<capture> or C<tee>.  This may not work
  for tied filehandles (see below).
  
  =head2 Modifying filehandles before capturing
  
  Generally speaking, you should do little or no manipulation of the standard IO
  filehandles prior to using Capture::Tiny.  In particular, closing, reopening,
  localizing or tying standard filehandles prior to capture may cause a variety of
  unexpected, undesirable and/or unreliable behaviors, as described below.
  Capture::Tiny does its best to compensate for these situations, but the
  results may not be what you desire.
  
  =head3 Closed filehandles
  
  Capture::Tiny will work even if STDIN, STDOUT or STDERR have been previously
  closed.  However, since they will be reopened to capture or tee output, any
  code within the captured block that depends on finding them closed will, of
  course, not find them to be closed.  If they started closed, Capture::Tiny will
  close them again when the capture block finishes.
  
  Note that this reopening will happen even for STDIN or a filehandle not being
  captured to ensure that the filehandle used for capture is not opened to file
  descriptor 0, as this causes problems on various platforms.
  
  Prior to Perl 5.12, closed STDIN combined with PERL_UNICODE=D leaks filehandles
  and also breaks tee() for undiagnosed reasons.  So don't do that.
  
  =head3 Localized filehandles
  
  If code localizes any of Perl's standard filehandles before capturing, the capture
  will affect the localized filehandles and not the original ones.  External system
  calls are not affected by localizing a filehandle in Perl and will continue
  to send output to the original filehandles (which will thus not be captured).
  
  =head3 Scalar filehandles
  
  If STDOUT or STDERR are reopened to scalar filehandles prior to the call to
  C<capture> or C<tee>, then Capture::Tiny will override the output filehandle for
  the duration of the C<capture> or C<tee> call and then, for C<tee>, send captured
  output to the output filehandle after the capture is complete.  (Requires Perl
  5.8)
  
  Capture::Tiny attempts to preserve the semantics of STDIN opened to a scalar
  reference, but note that external processes will not be able to read from such
  a handle.  Capture::Tiny tries to ensure that external processes will read from
  the null device instead, but this is not guaranteed.
  
  =head3 Tied output filehandles
  
  If STDOUT or STDERR are tied prior to the call to C<capture> or C<tee>, then
  Capture::Tiny will attempt to override the tie for the duration of the
  C<capture> or C<tee> call and then send captured output to the tied filehandle after
  the capture is complete.  (Requires Perl 5.8)
  
  Capture::Tiny may not succeed resending UTF-8 encoded data to a tied
  STDOUT or STDERR filehandle.  Characters may appear as bytes.  If the tied filehandle
  is based on L<Tie::StdHandle>, then Capture::Tiny will attempt to determine
  appropriate layers like C<:utf8> from the underlying filehandle and do the right
  thing.
  
  =head3 Tied input filehandle
  
  Capture::Tiny attempts to preserve the semantics of tied STDIN, but this
  requires Perl 5.8 and is not entirely predictable.  External processes
  will not be able to read from such a handle.
  
  Unless having STDIN tied is crucial, it may be safest to localize STDIN when
  capturing:
  
    my ($out, $err) = do { local *STDIN; capture { ... } };
  
  =head2 Modifying filehandles during a capture
  
  Attempting to modify STDIN, STDOUT or STDERR I<during> C<capture> or C<tee> is
  almost certainly going to cause problems.  Don't do that.
  
  =head3 Forking inside a capture
  
  Forks aren't portable.  The behavior of filehandles during a fork is even
  less so.  If Capture::Tiny detects that a fork has occurred within a
  capture, it will shortcut in the child process and return empty strings for
  captures.  Other problems may occur in the child or parent, as well.
  Forking in a capture block is not recommended.
  
  =head3 Using threads
  
  Filehandles are global.  Mixing up I/O and captures in different threads
  without coordination is going to cause problems.  Besides, threads are
  officially discouraged.
  
  =head3 Dropping privileges during a capture
  
  If you drop privileges during a capture, temporary files created to
  facilitate the capture may not be cleaned up afterwards.
  
  =head2 No support for Perl 5.8.0
  
  It's just too buggy when it comes to layers and UTF-8.  Perl 5.8.1 or later
  is recommended.
  
  =head2 Limited support for Perl 5.6
  
  Perl 5.6 predates PerlIO.  UTF-8 data may not be captured correctly.
  
  =head1 ENVIRONMENT
  
  =head2 PERL_CAPTURE_TINY_TIMEOUT
  
  Capture::Tiny uses subprocesses internally for C<tee>.  By default,
  Capture::Tiny will timeout with an error if such subprocesses are not ready to
  receive data within 30 seconds (or whatever is the value of
  C<$Capture::Tiny::TIMEOUT>).  An alternate timeout may be specified by setting
  the C<PERL_CAPTURE_TINY_TIMEOUT> environment variable.  Setting it to zero will
  disable timeouts.  B<NOTE>, this does not timeout the code reference being
  captured -- this only prevents Capture::Tiny itself from hanging your process
  waiting for its child processes to be ready to proceed.
  
  =head1 SEE ALSO
  
  This module was inspired by L<IO::CaptureOutput>, which provides
  similar functionality without the ability to tee output and with more
  complicated code and API.  L<IO::CaptureOutput> does not handle layers
  or most of the unusual cases described in the L</Limitations> section and
  I no longer recommend it.
  
  There are many other CPAN modules that provide some sort of output capture,
  albeit with various limitations that make them appropriate only in particular
  circumstances.  I'm probably missing some.  The long list is provided to show
  why I felt Capture::Tiny was necessary.
  
  =over 4
  
  =item *
  
  L<IO::Capture>
  
  =item *
  
  L<IO::Capture::Extended>
  
  =item *
  
  L<IO::CaptureOutput>
  
  =item *
  
  L<IPC::Capture>
  
  =item *
  
  L<IPC::Cmd>
  
  =item *
  
  L<IPC::Open2>
  
  =item *
  
  L<IPC::Open3>
  
  =item *
  
  L<IPC::Open3::Simple>
  
  =item *
  
  L<IPC::Open3::Utils>
  
  =item *
  
  L<IPC::Run>
  
  =item *
  
  L<IPC::Run::SafeHandles>
  
  =item *
  
  L<IPC::Run::Simple>
  
  =item *
  
  L<IPC::Run3>
  
  =item *
  
  L<IPC::System::Simple>
  
  =item *
  
  L<Tee>
  
  =item *
  
  L<IO::Tee>
  
  =item *
  
  L<File::Tee>
  
  =item *
  
  L<Filter::Handle>
  
  =item *
  
  L<Tie::STDERR>
  
  =item *
  
  L<Tie::STDOUT>
  
  =item *
  
  L<Test::Output>
  
  =back
  
  =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
  
  =head1 SUPPORT
  
  =head2 Bugs / Feature Requests
  
  Please report any bugs or feature requests through the issue tracker
  at L<https://github.com/dagolden/Capture-Tiny/issues>.
  You will be notified automatically of any progress on your issue.
  
  =head2 Source Code
  
  This is open source software.  The code repository is available for
  public review and contribution under the terms of the license.
  
  L<https://github.com/dagolden/Capture-Tiny>
  
    git clone https://github.com/dagolden/Capture-Tiny.git
  
  =head1 AUTHOR
  
  David Golden <dagolden@cpan.org>
  
  =head1 CONTRIBUTORS
  
  =for stopwords Dagfinn Ilmari Mannsåker David E. Wheeler fecundf Graham Knop Peter Rabbitson
  
  =over 4
  
  =item *
  
  Dagfinn Ilmari Mannsåker <ilmari@ilmari.org>
  
  =item *
  
  David E. Wheeler <david@justatheory.com>
  
  =item *
  
  fecundf <not.com+github@gmail.com>
  
  =item *
  
  Graham Knop <haarg@haarg.org>
  
  =item *
  
  Peter Rabbitson <ribasushi@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2009 by David Golden.
  
  This is free software, licensed under:
  
    The Apache License, Version 2.0, January 2004
  
  =cut
CAPTURE_TINY

$fatpacked{"Carp/Assert.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARP_ASSERT';
  package Carp::Assert;
  
  require 5.006;
  use strict qw(subs vars);
  use warnings;
  use Exporter;
  
  use vars qw(@ISA $VERSION %EXPORT_TAGS);
  
  BEGIN {
      $VERSION = '0.22';
  
      @ISA = qw(Exporter);
  
      %EXPORT_TAGS = (
                      NDEBUG => [qw(assert affirm should shouldnt DEBUG)],
                     );
      $EXPORT_TAGS{DEBUG} = $EXPORT_TAGS{NDEBUG};
      Exporter::export_tags(qw(NDEBUG DEBUG));
  }
  
  # constant.pm, alas, adds too much load time (yes, I benchmarked it)
  sub REAL_DEBUG  ()  { 1 }       # CONSTANT
  sub NDEBUG      ()  { 0 }       # CONSTANT
  
  # Export the proper DEBUG flag according to if :NDEBUG is set.
  # Also export noop versions of our routines if NDEBUG
  sub noop { undef }
  sub noop_affirm (&;$) { undef };
  
  sub import {
      my $env_ndebug = exists $ENV{PERL_NDEBUG} ? $ENV{PERL_NDEBUG}
                                                : $ENV{'NDEBUG'};
      if( grep(/^:NDEBUG$/, @_) or $env_ndebug ) {
          my $caller = caller;
          foreach my $func (grep !/^DEBUG$/, @{$EXPORT_TAGS{'NDEBUG'}}) {
              if( $func eq 'affirm' ) {
                  *{$caller.'::'.$func} = \&noop_affirm;
              } else {
                  *{$caller.'::'.$func} = \&noop;
              }
          }
          *{$caller.'::DEBUG'} = \&NDEBUG;
      }
      else {
          *DEBUG = *REAL_DEBUG;
          Carp::Assert->_export_to_level(1, @_);
      }
  }
  
  
  # 5.004's Exporter doesn't have export_to_level.
  sub _export_to_level
  {
        my $pkg = shift;
        my $level = shift;
        (undef) = shift;                  # XXX redundant arg
        my $callpkg = caller($level);
        $pkg->export($callpkg, @_);
  }
  
  
  sub unimport {
      *DEBUG = *NDEBUG;
      push @_, ':NDEBUG';
      goto &import;
  }
  
  
  # Can't call confess() here or the stack trace will be wrong.
  sub _fail_msg {
      my($name) = shift;
      my $msg = 'Assertion';
      $msg   .= " ($name)" if defined $name;
      $msg   .= " failed!\n";
      return $msg;
  }
  
  
  =head1 NAME
  
  Carp::Assert - executable comments
  
  =head1 SYNOPSIS
  
      # Assertions are on.
      use Carp::Assert;
  
      $next_sunrise_time = sunrise();
  
      # Assert that the sun must rise in the next 24 hours.
      assert(($next_sunrise_time - time) < 24*60*60) if DEBUG;
  
      # Assert that your customer's primary credit card is active
      affirm {
          my @cards = @{$customer->credit_cards};
          $cards[0]->is_active;
      };
  
  
      # Assertions are off.
      no Carp::Assert;
  
      $next_pres = divine_next_president();
  
      # Assert that if you predict Dan Quayle will be the next president
      # your crystal ball might need some polishing.  However, since
      # assertions are off, IT COULD HAPPEN!
      shouldnt($next_pres, 'Dan Quayle') if DEBUG;
  
  
  =head1 DESCRIPTION
  
  =begin testing
  
  BEGIN {
      local %ENV = %ENV;
      delete @ENV{qw(PERL_NDEBUG NDEBUG)};
      require Carp::Assert;
      Carp::Assert->import;
  }
  
  local %ENV = %ENV;
  delete @ENV{qw(PERL_NDEBUG NDEBUG)};
  
  =end testing
  
      "We are ready for any unforseen event that may or may not 
      occur."
          - Dan Quayle
  
  Carp::Assert is intended for a purpose like the ANSI C library
  L<assert.h|http://en.wikipedia.org/wiki/Assert.h>.
  If you're already familiar with assert.h, then you can
  probably skip this and go straight to the FUNCTIONS section.
  
  Assertions are the explicit expressions of your assumptions about the
  reality your program is expected to deal with, and a declaration of
  those which it is not.  They are used to prevent your program from
  blissfully processing garbage inputs (garbage in, garbage out becomes
  garbage in, error out) and to tell you when you've produced garbage
  output.  (If I was going to be a cynic about Perl and the user nature,
  I'd say there are no user inputs but garbage, and Perl produces
  nothing but...)
  
  An assertion is used to prevent the impossible from being asked of
  your code, or at least tell you when it does.  For example:
  
  =for example begin
  
      # Take the square root of a number.
      sub my_sqrt {
          my($num) = shift;
  
          # the square root of a negative number is imaginary.
          assert($num >= 0);
  
          return sqrt $num;
      }
  
  =for example end
  
  =for example_testing
  is( my_sqrt(4),  2,            'my_sqrt example with good input' );
  ok( !eval{ my_sqrt(-1); 1 },   '  and pukes on bad' );
  
  The assertion will warn you if a negative number was handed to your
  subroutine, a reality the routine has no intention of dealing with.
  
  An assertion should also be used as something of a reality check, to
  make sure what your code just did really did happen:
  
      open(FILE, $filename) || die $!;
      @stuff = <FILE>;
      @stuff = do_something(@stuff);
  
      # I should have some stuff.
      assert(@stuff > 0);
  
  The assertion makes sure you have some @stuff at the end.  Maybe the
  file was empty, maybe do_something() returned an empty list... either
  way, the assert() will give you a clue as to where the problem lies,
  rather than 50 lines down at when you wonder why your program isn't
  printing anything.
  
  Since assertions are designed for debugging and will remove themelves
  from production code, your assertions should be carefully crafted so
  as to not have any side-effects, change any variables, or otherwise
  have any effect on your program.  Here is an example of a bad
  assertation:
  
      assert($error = 1 if $king ne 'Henry');  # Bad!
  
  It sets an error flag which may then be used somewhere else in your
  program. When you shut off your assertions with the $DEBUG flag,
  $error will no longer be set.
  
  Here's another example of B<bad> use:
  
      assert($next_pres ne 'Dan Quayle' or goto Canada);  # Bad!
  
  This assertion has the side effect of moving to Canada should it fail.
  This is a very bad assertion since error handling should not be
  placed in an assertion, nor should it have side-effects.
  
  In short, an assertion is an executable comment.  For instance, instead
  of writing this
  
      # $life ends with a '!'
      $life = begin_life();
  
  you'd replace the comment with an assertion which B<enforces> the comment.
  
      $life = begin_life();
      assert( $life =~ /!$/ );
  
  =for testing
  my $life = 'Whimper!';
  ok( eval { assert( $life =~ /!$/ ); 1 },   'life ends with a bang' );
  
  
  =head1 FUNCTIONS
  
  =over 4
  
  =item B<assert>
  
      assert(EXPR) if DEBUG;
      assert(EXPR, $name) if DEBUG;
  
  assert's functionality is effected by compile time value of the DEBUG
  constant, controlled by saying C<use Carp::Assert> or C<no
  Carp::Assert>.  In the former case, assert will function as below.
  Otherwise, the assert function will compile itself out of the program.
  See L<Debugging vs Production> for details.
  
  =for testing
  {
    package Some::Other;
    no Carp::Assert;
    ::ok( eval { assert(0) if DEBUG; 1 } );
  }
  
  Give assert an expression, assert will Carp::confess() if that
  expression is false, otherwise it does nothing.  (DO NOT use the
  return value of assert for anything, I mean it... really!).
  
  =for testing
  ok( eval { assert(1); 1 } );
  ok( !eval { assert(0); 1 } );
  
  The error from assert will look something like this:
  
      Assertion failed!
              Carp::Assert::assert(0) called at prog line 23
              main::foo called at prog line 50
  
  =for testing
  eval { assert(0) };
  like( $@, '/^Assertion failed!/',       'error format' );
  like( $@, '/Carp::Assert::assert\(0\) called at/',      '  with stack trace' );
  
  Indicating that in the file "prog" an assert failed inside the
  function main::foo() on line 23 and that foo() was in turn called from
  line 50 in the same file.
  
  If given a $name, assert() will incorporate this into your error message,
  giving users something of a better idea what's going on.
  
      assert( Dogs->isa('People'), 'Dogs are people, too!' ) if DEBUG;
      # Result - "Assertion (Dogs are people, too!) failed!"
  
  =for testing
  eval { assert( Dogs->isa('People'), 'Dogs are people, too!' ); };
  like( $@, '/^Assertion \(Dogs are people, too!\) failed!/', 'names' );
  
  =cut
  
  sub assert ($;$) {
      unless($_[0]) {
          require Carp;
          Carp::confess( _fail_msg($_[1]) );
      }
      return undef;
  }
  
  
  =item B<affirm>
  
      affirm BLOCK if DEBUG;
      affirm BLOCK $name if DEBUG;
  
  Very similar to assert(), but instead of taking just a simple
  expression it takes an entire block of code and evaluates it to make
  sure its true.  This can allow more complicated assertions than
  assert() can without letting the debugging code leak out into
  production and without having to smash together several
  statements into one.
  
  =for example begin
  
      affirm {
          my $customer = Customer->new($customerid);
          my @cards = $customer->credit_cards;
          grep { $_->is_active } @cards;
      } "Our customer has an active credit card";
  
  =for example end
  
  =for testing
  my $foo = 1;  my $bar = 2;
  eval { affirm { $foo == $bar } };
  like( $@, '/\$foo == \$bar/' );
  
  
  affirm() also has the nice side effect that if you forgot the C<if DEBUG>
  suffix its arguments will not be evaluated at all.  This can be nice
  if you stick affirm()s with expensive checks into hot loops and other
  time-sensitive parts of your program.
  
  If the $name is left off and your Perl version is 5.6 or higher the
  affirm() diagnostics will include the code begin affirmed.
  
  =cut
  
  sub affirm (&;$) {
      unless( eval { &{$_[0]}; } ) {
          my $name = $_[1];
  
          if( !defined $name ) {
              eval {
                  require B::Deparse;
                  $name = B::Deparse->new->coderef2text($_[0]);
              };
              $name = 
                'code display non-functional on this version of Perl, sorry'
                  if $@;
          }
  
          require Carp;
          Carp::confess( _fail_msg($name) );
      }
      return undef;
  }
  
  =item B<should>
  
  =item B<shouldnt>
  
      should  ($this, $shouldbe)   if DEBUG;
      shouldnt($this, $shouldntbe) if DEBUG;
  
  Similar to assert(), it is specially for simple "this should be that"
  or "this should be anything but that" style of assertions.
  
  Due to Perl's lack of a good macro system, assert() can only report
  where something failed, but it can't report I<what> failed or I<how>.
  should() and shouldnt() can produce more informative error messages:
  
      Assertion ('this' should be 'that'!) failed!
              Carp::Assert::should('this', 'that') called at moof line 29
              main::foo() called at moof line 58
  
  So this:
  
      should($this, $that) if DEBUG;
  
  is similar to this:
  
      assert($this eq $that) if DEBUG;
  
  except for the better error message.
  
  Currently, should() and shouldnt() can only do simple eq and ne tests
  (respectively).  Future versions may allow regexes.
  
  =cut
  
  sub should ($$) {
      unless($_[0] eq $_[1]) {
          require Carp;
          &Carp::confess( _fail_msg("'$_[0]' should be '$_[1]'!") );
      }
      return undef;
  }
  
  sub shouldnt ($$) {
      unless($_[0] ne $_[1]) {
          require Carp;
          &Carp::confess( _fail_msg("'$_[0]' shouldn't be that!") );
      }
      return undef;
  }
  
  =back
  
  =head1 Debugging vs Production
  
  Because assertions are extra code and because it is sometimes necessary to
  place them in 'hot' portions of your code where speed is paramount,
  Carp::Assert provides the option to remove its assert() calls from your
  program.
  
  So, we provide a way to force Perl to inline the switched off assert()
  routine, thereby removing almost all performance impact on your production
  code.
  
      no Carp::Assert;  # assertions are off.
      assert(1==1) if DEBUG;
  
  DEBUG is a constant set to 0.  Adding the 'if DEBUG' condition on your
  assert() call gives perl the cue to go ahead and remove assert() call from
  your program entirely, since the if conditional will always be false.
  
      # With C<no Carp::Assert> the assert() has no impact.
      for (1..100) {
          assert( do_some_really_time_consuming_check ) if DEBUG;
      }
  
  If C<if DEBUG> gets too annoying, you can always use affirm().
  
      # Once again, affirm() has (almost) no impact with C<no Carp::Assert>
      for (1..100) {
          affirm { do_some_really_time_consuming_check };
      }
  
  Another way to switch off all asserts, system wide, is to define the
  NDEBUG or the PERL_NDEBUG environment variable.
  
  You can safely leave out the "if DEBUG" part, but then your assert()
  function will always execute (and its arguments evaluated and time
  spent).  To get around this, use affirm().  You still have the
  overhead of calling a function but at least its arguments will not be
  evaluated.
  
  
  =head1 Differences from ANSI C
  
  assert() is intended to act like the function from ANSI C fame. 
  Unfortunately, due to Perl's lack of macros or strong inlining, it's not
  nearly as unobtrusive.
  
  Well, the obvious one is the "if DEBUG" part.  This is cleanest way I could
  think of to cause each assert() call and its arguments to be removed from
  the program at compile-time, like the ANSI C macro does.
  
  Also, this version of assert does not report the statement which
  failed, just the line number and call frame via Carp::confess.  You
  can't do C<assert('$a == $b')> because $a and $b will probably be
  lexical, and thus unavailable to assert().  But with Perl, unlike C,
  you always have the source to look through, so the need isn't as
  great.
  
  
  =head1 EFFICIENCY
  
  With C<no Carp::Assert> (or NDEBUG) and using the C<if DEBUG> suffixes
  on all your assertions, Carp::Assert has almost no impact on your
  production code.  I say almost because it does still add some load-time
  to your code (I've tried to reduce this as much as possible).
  
  If you forget the C<if DEBUG> on an C<assert()>, C<should()> or
  C<shouldnt()>, its arguments are still evaluated and thus will impact
  your code.  You'll also have the extra overhead of calling a
  subroutine (even if that subroutine does nothing).
  
  Forgetting the C<if DEBUG> on an C<affirm()> is not so bad.  While you
  still have the overhead of calling a subroutine (one that does
  nothing) it will B<not> evaluate its code block and that can save
  a lot.
  
  Try to remember the B<if DEBUG>.
  
  
  =head1 ENVIRONMENT
  
  =over 4
  
  =item NDEBUG
  
  Defining NDEBUG switches off all assertions.  It has the same effect
  as changing "use Carp::Assert" to "no Carp::Assert" but it effects all
  code.
  
  =item PERL_NDEBUG
  
  Same as NDEBUG and will override it.  Its provided to give you
  something which won't conflict with any C programs you might be
  working on at the same time.
  
  =back
  
  
  =head1 BUGS, CAVETS and other MUSINGS
  
  =head2 Conflicts with C<POSIX.pm>
  
  The C<POSIX> module exports an C<assert> routine which will conflict with C<Carp::Assert> if both are used in the same namespace.  If you are using both together, prevent C<POSIX> from exporting like so:
  
      use POSIX ();
      use Carp::Assert;
  
  Since C<POSIX> exports way too much, you should be using it like that anyway.
  
  =head2 C<affirm> and C<$^S>
  
  affirm() mucks with the expression's caller and it is run in an eval
  so anything that checks $^S will be wrong.
  
  =head2 missing C<if DEBUG>
  
  It would be nice if we could warn about missing C<if DEBUG>.
  
  
  =head1 SEE ALSO
  
  L<assert.h|http://en.wikipedia.org/wiki/Assert.h> - the wikipedia
  page about C<assert.h>.
  
  L<Carp::Assert::More> provides a set of convenience functions
  that are wrappers around C<Carp::Assert>.
  
  L<Sub::Assert> provides support for subroutine pre- and post-conditions.
  The documentation says it's slow.
  
  L<PerlX::Assert> provides compile-time assertions, which are usually
  optimised away at compile time. Currently part of the L<Moops>
  distribution, but may get its own distribution sometime in 2014.
  
  L<Devel::Assert> also provides an C<assert> function, for Perl >= 5.8.1.
  
  L<assertions> provides an assertion mechanism for Perl >= 5.9.0.
  
  =head1 REPOSITORY
  
  L<https://github.com/schwern/Carp-Assert>
  
  =head1 COPYRIGHT
  
  Copyright 2001-2007 by Michael G Schwern E<lt>schwern@pobox.comE<gt>.
  
  This program is free software; you can redistribute it and/or 
  modify it under the same terms as Perl itself.
  
  See F<http://dev.perl.org/licenses/>
  
  
  =head1 AUTHOR
  
  Michael G Schwern <schwern@pobox.com>
  
  =cut
  
  return q|You don't just EAT the largest turnip in the world!|;
CARP_ASSERT

$fatpacked{"Contextual/Return.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CONTEXTUAL_RETURN';
  package Contextual::Return;
  use warnings;
  use strict;
  our $VERSION = '0.004014';
  
  my %attrs_of;
  
  # This is localized as caller to hide the interim blocks...
  my $smart_caller;
  
  # Fake out Carp::*, and Scalar::Util::blessed() very early...
  BEGIN {
      no warnings 'redefine';
  
      my $fallback_caller = *CORE::GLOBAL::caller{CODE};
      if (!defined $fallback_caller) {
          *CORE::GLOBAL::caller = sub (;$) {
              my ($height) = @_;
              $height++;
              my @caller = CORE::caller($height);
              if ( CORE::caller() eq 'DB' ) {
                  # Oops, redo picking up @DB::args
                  package DB;
                  @caller = CORE::caller($height);
              }
  
              return if ! @caller;                  # empty
              return $caller[0] if ! wantarray;     # scalar context
              return @_ ? @caller : @caller[0..2];  # extra info or regular
          };
      }
      $smart_caller = sub (;$) {
          my ($uplevels) = $_[0] || 0;
          my @caller;
          if (CORE::caller eq 'DB') {
              package DB;
              if ($fallback_caller) {
                  @caller = $fallback_caller->($uplevels + 5 + $Contextual::Return::uplevel)
                      if $Contextual::Return::uplevel;
                  @caller = $fallback_caller->($uplevels + 4);
              }
              else {
                  @caller = CORE::caller($uplevels + 5 + $Contextual::Return::uplevel)
                      if $Contextual::Return::uplevel;
                  @caller = CORE::caller($uplevels + 4);
              }
          }
          else {
              if ($fallback_caller) {
                  @caller = $fallback_caller->($uplevels + 5 + $Contextual::Return::uplevel)
                      if $Contextual::Return::uplevel;
                  @caller = $fallback_caller->($uplevels + 4);
              }
              else {
                  @caller = CORE::caller($uplevels + 5 + $Contextual::Return::uplevel)
                      if $Contextual::Return::uplevel;
                  @caller = CORE::caller($uplevels + 4);
              }
          }
          return if ! @caller;                  # empty
          return $caller[0] if ! wantarray;     # scalar context
          return @_ ? @caller : @caller[0..2];  # extra info or regular
      };
  
      use Carp;
      my $real_carp  = *Carp::carp{CODE};
      my $real_croak = *Carp::croak{CODE};
  
      *Carp::carp = sub {
          goto &{$real_carp} if !$Contextual::Return::uplevel;
          warn _in_context(@_);
      };
  
      *Carp::croak = sub {
          goto &{$real_croak} if !$Contextual::Return::uplevel;
          die _in_context(@_);
      };
  
      # Scalar::Util::blessed()...
      use Scalar::Util 'refaddr';
  
      # Remember the current blessed()...
      my $original_blessing = *Scalar::Util::blessed{CODE};
  
      # ...and replace it...
      *Scalar::Util::blessed = sub($) {
          no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
  
          # Are we operating on a CRV???
          my $attrs = $attrs_of{refaddr $_[0] or q{}};
  
          # If not, use the original code...
          goto &{$original_blessing} if !$attrs;
  
          # Does this object have a BLESSED handler???
          if (exists $attrs->{BLESSED}) {
              return $attrs->{BLESSED}->(@{$attrs->{args}});
          }
  
          # Otherwise, find the appropriate scalar handler...
          handler:
          for my $context (qw( OBJREF LAZY REF SCALAR VALUE NONVOID DEFAULT )) {
              my $handler = $attrs->{$context}
                  or next handler;
  
              my $obj_ref = eval { $handler->(@{$attrs->{args}}) };
  
              my $was_blessed = $original_blessing->($obj_ref);
              return $was_blessed if $was_blessed;
          }
  
          # Otherwise, simulate unblessed status...
          return undef;
      };
  }
  
  
  
  sub _in_context {
      my $msg = join q{}, @_;
  
      # Start looking in caller...
      my $stack_frame = 1;
      my ($package, $file, $line, $sub) = CORE::caller($stack_frame++);
  
      my ($orig_package, $prev_package) = ($package) x 2;
      my $LOC = qq{at $file line $line};
  
      # Walk up stack...
      STACK_FRAME:
      while (1) {
          my ($package, $file, $line, $sub) = CORE::caller($stack_frame++);
  
          # Fall off the top of the stack...
          last STACK_FRAME if !defined $package;
  
          # Ignore this module (and any helpers)...
          next STACK_FRAME if $package =~ m{^Contextual::Return}xms;
  
          # Track the call up the stack...
          $LOC = qq{at $file line $line};
  
          # Ignore any @CARP_NOT'ed packages
          next STACK_FRAME
              if do { no strict 'refs'; *{$package.'::CARP_NOT'}{ARRAY}; };
  
          # Ignore transitions within original caller...
          next STACK_FRAME
              if $package eq $orig_package && $prev_package eq $orig_package;
  
          # If we get a transition out of the original package, we're there...
          last STACK_FRAME;
      }
  
      # Insert location details...
      $msg =~ s/<LOC>/$LOC/g or $msg =~ s/[^\S\n]*$/ $LOC/;
      $msg =~ s/$/\n/;
      return $msg;
  }
  
  # Indentation corresponds to inherited fall-back relationships...
  my @CONTEXTS = qw(
      DEFAULT
          VOID
          NONVOID
              LIST
              SCALAR
                  VALUE
                      STR
                      NUM
                      BOOL
                          PUREBOOL
                  REF
                      SCALARREF
                      ARRAYREF
                      CODEREF
                      HASHREF
                      GLOBREF
                      OBJREF
                          METHOD
                          BLESSED
  );
  
  my @ALL_EXPORTS = (
      @CONTEXTS,
      qw(
          LAZY       RESULT      RVALUE      METHOD     FAIL
          FIXED      RECOVER     LVALUE      RETOBJ     FAIL_WITH
          ACTIVE     CLEANUP     NVALUE      STRICT     BLESSED
      )
  );
  
  my %STD_NAME_FOR = map { $_ => $_ } @ALL_EXPORTS;
  
  sub import {
      # Load utility module for failure handlers...
      if (require Contextual::Return::Failure) {
          *FAIL      = \&Contextual::Return::Failure::_FAIL;
          *FAIL_WITH = \&Contextual::Return::Failure::_FAIL_WITH;
      }
  
      # Don't need the package name...
      shift @_;
  
      # If args, export nothing by default; otherwise export all...
      my %exports = @_ ? () : %STD_NAME_FOR;
  
      # All args are export either selectors and/or renamers...
      while (my $selector = shift @_) {
          my $next_arg = $_[0];
          my $renamer = (defined $next_arg
                      && !ref $next_arg
                      && !exists $STD_NAME_FOR{$next_arg})
                          ? shift(@_)
                          : undef;
          %exports = (%exports, _add_exports_for($selector, $renamer));
      }
  
      # Loop through possible exports, exporting anything requested...
      my $caller = CORE::caller;
      EXPORT:
      for my $subname (keys %exports) {
          no strict qw( refs );
          *{$caller.'::'.$exports{$subname}} = \&{$subname};
      }
  };
  
  sub _add_exports_for {
      my ($selector, $renamer) = @_;
  
      # If no renamer, use original name...
      $renamer ||= '%s';
  
      # Handle different types of selector...
      my $selector_type = ref($selector) || 'literal';
  
      # Array selector recursively export each element...
      if ($selector_type eq 'ARRAY') {
          return map { _add_exports_for($_,$renamer) } @{$selector};
      }
      elsif ($selector_type eq 'Regexp') {
          my @selected = grep {/$selector/} @ALL_EXPORTS;
          if (!@selected) {
              Carp::carp("use Contextual::Return $selector didn't export anything");
          }
          no if $] >= 5.022, warnings => 'redundant';
          return map { $_ => sprintf($renamer, $_) } @selected;
      }
      elsif ($selector_type eq 'literal') {
          Carp::croak "Can't export $selector: no such handler"
              if !exists $STD_NAME_FOR{$selector};
          no if $] >= 5.022, warnings => 'redundant';
          return ( $selector => sprintf($renamer, $selector) );
      }
      else {
          Carp::croak "Can't use $selector_type as export specifier";
      }
  }
  
  
  # Let handlers access the result object they're inside...
  
  sub RETOBJ() {
      our $__RETOBJ__;
      return $__RETOBJ__;
  }
  
  
  use Scalar::Util qw( refaddr );
  
  # Override return value in a C::R handler...
  sub RESULT(;&) {
      my ($block) = @_;
  
      # Determine call context and arg list...
      my $context;
      my $args = do { package DB; $context=(CORE::caller 1)[5]; my $args = \@DB::args; ()=CORE::caller(1); $args };
  
      # No args -> return appropriate value...
      if (!@_) {
          return $context ? @{ $Contextual::Return::__RESULT__ || [] }
                          :    $Contextual::Return::__RESULT__->[0]
                          ;
      }
  
      # Hide from caller() and the enclosing eval{}...
  
      # Evaluate block in context and cache result...
      local $Contextual::Return::uplevel = $Contextual::Return::uplevel+1;
      no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
      $Contextual::Return::__RESULT__
          =         $context  ? [        $block->(@{$args})      ]
          : defined $context  ? [ scalar $block->(@{$args}) ]
          :                     do {     $block->(@{$args}); [] }
          ;
  
      return;
  }
  
  sub RVALUE(&;@) :lvalue;
  sub LVALUE(&;@) :lvalue;
  sub NVALUE(&;@) :lvalue;
  
  my %opposite_of = (
      'RVALUE' => 'LVALUE or NVALUE',
      'LVALUE' => 'RVALUE or NVALUE',
      'NVALUE' => 'LVALUE or RVALUE',
  );
  
  
  BEGIN {
      for my $subname (qw( RVALUE LVALUE NVALUE) ) {
          no strict 'refs';
          *{$subname} = sub(&;@) :lvalue {    # (handler, return_lvalue);
              my $handler = shift;
              my $impl;
              my $args = do{ package DB; ()=CORE::caller(1); my $args = \@DB::args; ()=CORE::caller(1); $args };
              if (@_==0) {
                  $impl = tie $_[0], 'Contextual::Return::Lvalue',
                      $subname => $handler, args=>$args;
              }
              elsif (@_==1 and $impl = tied $_[0]) {
                  die _in_context "Can't install two $subname handlers"
                      if exists $impl->{$subname};
                  $impl->{$subname} = $handler;
              }
              else {
                  my $vals = join q{, }, map { tied $_    ? keys %{tied $_}
                                             : defined $_ ? $_
                                             :              'undef'
                                             } @_;
                  die _in_context "Expected a $opposite_of{$subname} block ",
                                  "after the $subname block <LOC> ",
                                  "but found instead: $vals\n";
              }
  
              # Handle void context calls...
              if (!defined wantarray && $impl->{NVALUE}) {
                  # Fake out caller() and Carp...
                  local $Contextual::Return::uplevel = 1;
                  no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
  
                  # Call and clear handler...
                  local $Contextual::Return::__RETOBJ__ = $impl;
                  $impl->{NVALUE}( @{$impl->{args}} );
                  delete $impl->{NVALUE};
              }
              $_[0];
          }
      }
  }
  
  for my $modifier_name (qw< STRICT FIXED ACTIVE >) {
      no strict 'refs';
      *{$modifier_name} = sub ($) {
          my ($crv) = @_;
          my $attrs = $attrs_of{refaddr $crv or q{}};
  
          # Track context...
          my $wantarray = wantarray;
          use Want;
          $attrs->{want_pure_bool} ||= Want::want('BOOL');
  
          # Remember the modification...
          $attrs->{$modifier_name} = 1;
  
          # Prepare for exception handling...
          my $recover = $attrs->{RECOVER};
          local $Contextual::Return::uplevel = 2;
          no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
  
          # Handle list context directly, if possible...
          if ($wantarray) {
              local $Contextual::Return::__RESULT__;
              # List or ancestral handlers...
              handler:
              for my $context (qw(LIST VALUE NONVOID DEFAULT)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  my @rv = eval { $handler->(@{$attrs->{args}}) };
                  if ($recover) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [@rv];
                      }
                      () = $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  return @rv if !$Contextual::Return::__RESULT__;
                  return @{$Contextual::Return::__RESULT__};
              }
              # Convert to list from arrayref handler...
              if (!$attrs->{STRICT} and my $handler = $attrs->{ARRAYREF}) {
                  my $array_ref = eval { $handler->(@{$attrs->{args}}) };
  
                  if ($recover) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$array_ref];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  # Array ref may be returned directly, or via RESULT{}...
                  $array_ref = $Contextual::Return::__RESULT__->[0]
                      if $Contextual::Return::__RESULT__;
  
                  return @{$array_ref} if (ref $array_ref||q{}) eq 'ARRAY';
              }
              # Return scalar object as one-elem list, if possible...
              handler:
              for my $context (qw(BOOL STR NUM VALUE SCALAR LAZY)) {
                  last handler if $attrs->{STRICT};
                  return $crv if exists $attrs->{$context};
              }
              $@ = _in_context "Can't call $attrs->{sub} in a list context";
              if ($recover) {
                  () = $recover->(@{$attrs->{args}});
              }
              else {
                  die $@;
              }
          }
  
          # Handle void context directly...
          if (!defined $wantarray) {
              handler:
              for my $context (qw< VOID DEFAULT >) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  eval { $attrs->{$context}->(@{$attrs->{args}}) };
                  if ($recover) {
                      $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
                  last handler;
              }
              if ($attrs->{STRICT}) {
                  $@ = _in_context "Can't call $attrs->{sub} in a void context";
                  if ($recover) {
                      () = $recover->(@{$attrs->{args}});
                  }
                  else {
                      die $@;
                  }
              }
              return;
          }
  
          # Otherwise, let someone else handle it...
          return $crv;
      }
  }
  
  sub LIST (;&$) {
      my ($block, $crv) = @_;
  
      # Handle simple context tests...
      return !!(CORE::caller 1)[5] if !@_;
  
      # Ensure we have an object...
      my $attrs;
      if (!refaddr $crv) {
          my $args = do{ package DB; ()=CORE::caller(1); my $args = \@DB::args; ()=CORE::caller(1); $args };
          my $subname = (CORE::caller(1))[3];
          if (!defined $subname) {
              $subname = 'bare LIST {...}';
          }
          $crv = bless \my $scalar, 'Contextual::Return::Value';
          $attrs = $attrs_of{refaddr $crv} = { args => $args, sub => $subname };
      }
      else {
          $attrs = $attrs_of{refaddr $crv};
      }
      local $Contextual::Return::__RETOBJ__ = $crv;
  
      # Handle repetitions...
      die _in_context "Can't install two LIST handlers"
          if exists $attrs->{LIST};
  
      # Identify contexts...
      my $wantarray = wantarray;
      use Want;
      $attrs->{want_pure_bool} ||= Want::want('BOOL');
  
      # Prepare for exception handling...
      my $recover = $attrs->{RECOVER};
      local $Contextual::Return::uplevel = 2;
      no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
  
      # Handle list context directly...
      if ($wantarray) {
          local $Contextual::Return::__RESULT__;
  
          my @rv = eval { $block->(@{$attrs->{args}}) };
          if ($recover) {
              if (!$Contextual::Return::__RESULT__) {
                  $Contextual::Return::__RESULT__ = [@rv];
              }
              () = $recover->(@{$attrs->{args}});
          }
          elsif ($@) {
              die $@;
          }
  
          return @rv if !$Contextual::Return::__RESULT__;
          return @{$Contextual::Return::__RESULT__};
      }
  
      # Handle void context directly...
      if (!defined $wantarray) {
          handler:
          for my $context (qw< VOID DEFAULT >) {
              my $handler = $attrs->{$context}
                  or $attrs->{STRICT} and last handler
                  or next handler;
  
              eval { $attrs->{$context}->(@{$attrs->{args}}) };
              if ($recover) {
                  $recover->(@{$attrs->{args}});
              }
              elsif ($@) {
                  die $@;
              }
              last handler;
          }
          if ($attrs->{STRICT}) {
              $@ = _in_context "Can't call $attrs->{sub} in a void context";
              if ($recover) {
                  () = $recover->(@{$attrs->{args}});
              }
              else {
                  die $@;
              }
          }
          return;
      }
  
      # Otherwise, cache handler...
      $attrs->{LIST} = $block;
      return $crv;
  }
  
  
  sub VOID (;&$) {
      my ($block, $crv) = @_;
  
      # Handle simple context tests...
      return !defined( (CORE::caller 1)[5] ) if !@_;
  
      # Ensure we have an object...
      my $attrs;
      if (!refaddr $crv) {
          my $args = do{ package DB; ()=CORE::caller(1); my $args = \@DB::args; ()=CORE::caller(1); $args };
          my $subname = (CORE::caller(1))[3];
          if (!defined $subname) {
              $subname = 'bare VOID {...}';
          }
          $crv = bless \my $scalar, 'Contextual::Return::Value';
          $attrs = $attrs_of{refaddr $crv} = { args => $args, sub => $subname };
      }
      else {
          $attrs = $attrs_of{refaddr $crv};
      }
      local $Contextual::Return::__RETOBJ__ = $crv;
  
      # Handle repetitions...
      die _in_context "Can't install two VOID handlers"
          if exists $attrs->{VOID};
  
      # Identify contexts...
      my $wantarray = wantarray;
      use Want;
      $attrs->{want_pure_bool} ||= Want::want('BOOL');
  
      # Prepare for exception handling...
      my $recover = $attrs->{RECOVER};
      local $Contextual::Return::uplevel = 2;
      no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
  
      # Handle list context directly, if possible...
      if ($wantarray) {
          local $Contextual::Return::__RESULT__;
          # List or ancestral handlers...
          handler:
          for my $context (qw(LIST VALUE NONVOID DEFAULT)) {
              my $handler = $attrs->{$context}
                  or $attrs->{STRICT} and last handler
                  or next handler;
  
              my @rv = eval { $handler->(@{$attrs->{args}}) };
              if ($recover) {
                  if (!$Contextual::Return::__RESULT__) {
                      $Contextual::Return::__RESULT__ = [@rv];
                  }
                  () = $recover->(@{$attrs->{args}});
              }
              elsif ($@) {
                  die $@;
              }
  
              return @rv if !$Contextual::Return::__RESULT__;
              return @{$Contextual::Return::__RESULT__};
          }
          # Convert to list from arrayref handler...
          if (!$attrs->{STRICT} and my $handler = $attrs->{ARRAYREF}) {
              my $array_ref = eval { $handler->(@{$attrs->{args}}) };
  
              if ($recover) {
                  if (!$Contextual::Return::__RESULT__) {
                      $Contextual::Return::__RESULT__ = [$array_ref];
                  }
                  scalar $recover->(@{$attrs->{args}});
              }
              elsif ($@) {
                  die $@;
              }
  
              # Array ref may be returned directly, or via RESULT{}...
              $array_ref = $Contextual::Return::__RESULT__->[0]
                  if $Contextual::Return::__RESULT__;
  
              return @{$array_ref} if (ref $array_ref||q{}) eq 'ARRAY';
          }
          # Return scalar object as one-elem list, if possible...
          handler:
          for my $context (qw(BOOL STR NUM VALUE SCALAR LAZY)) {
              last handler if $attrs->{STRICT};
              return $crv if exists $attrs->{$context};
          }
          $@ = _in_context "Can't call $attrs->{sub} in a list context";
          if ($recover) {
              () = $recover->(@{$attrs->{args}});
          }
          else {
              die $@;
          }
      }
  
      # Handle void context directly...
      if (!defined $wantarray) {
          eval { $block->(@{$attrs->{args}}) };
  
          if ($recover) {
              $recover->(@{$attrs->{args}});
          }
          elsif ($@) {
              die $@;
          }
  
          return;
      }
  
      # Otherwise, cache handler...
      $attrs->{VOID} = $block;
      return $crv;
  }
  
  for my $context (qw( SCALAR NONVOID )) {
      no strict qw( refs );
      *{$context} = sub (;&$) {
          my ($block, $crv) = @_;
  
          # Handle simple context tests...
          if (!@_) {
              my $callers_context = (CORE::caller 1)[5];
              return defined $callers_context
                  && ($context eq 'NONVOID' || !$callers_context);
          }
  
          # Ensure we have an object...
          my $attrs;
          if (!refaddr $crv) {
              my $args = do{ package DB; ()=CORE::caller(1); my $args = \@DB::args; ()=CORE::caller(1); $args };
              my $subname = (CORE::caller(1))[3];
              if (!defined $subname) {
                  $subname = "bare $context {...}";
              }
              $crv = bless \my $scalar, 'Contextual::Return::Value';
              $attrs = $attrs_of{refaddr $crv}
                      = { args => $args, sub => $subname };
          }
          else {
              $attrs = $attrs_of{refaddr $crv};
          }
          local $Contextual::Return::__RETOBJ__ = $crv;
  
          # Make sure this block is a possibility too...
          die _in_context "Can't install two $context handlers"
              if exists $attrs->{$context};
          $attrs->{$context} = $block;
  
          # Identify contexts...
          my $wantarray = wantarray;
          use Want ();
          $attrs->{want_pure_bool} ||= Want::want('BOOL');
  
          # Prepare for exception handling...
          my $recover = $attrs->{RECOVER};
          local $Contextual::Return::uplevel = 2;
          no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
  
          # Handle list context directly, if possible...
          if ($wantarray) {
              local $Contextual::Return::__RESULT__;
  
              # List or ancestral handlers...
              handler:
              for my $context (qw(LIST VALUE NONVOID DEFAULT)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  my @rv = eval { $handler->(@{$attrs->{args}}) };
                  if ($recover) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [@rv];
                      }
                      () = $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  return @rv if !$Contextual::Return::__RESULT__;
                  return @{$Contextual::Return::__RESULT__};
              }
              # Convert to list from arrayref handler...
              if (!$attrs->{STRICT} and my $handler = $attrs->{ARRAYREF}) {
  
                  my $array_ref = eval { $handler->(@{$attrs->{args}}) };
                  if ($recover) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$array_ref];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  # Array ref may be returned directly, or via RESULT{}...
                  $array_ref = $Contextual::Return::__RESULT__->[0]
                      if $Contextual::Return::__RESULT__;
  
                  return @{$array_ref} if (ref $array_ref||q{}) eq 'ARRAY';
              }
              # Return scalar object as one-elem list, if possible...
              handler:
              for my $context (qw(BOOL STR NUM VALUE SCALAR LAZY)) {
                  last if $attrs->{STRICT};
                  return $crv if exists $attrs->{$context};
              }
              die _in_context "Can't call $attrs->{sub} in a list context";
          }
  
          # Handle void context directly...
          if (!defined $wantarray) {
              handler:
              for my $context (qw< VOID DEFAULT >) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  eval { $handler->(@{$attrs->{args}}) };
                  if ($recover) {
                      $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  last handler;
              }
              if ($attrs->{STRICT}) {
                  $@ = _in_context "Can't call $attrs->{sub} in a void context";
                  if ($recover) {
                      () = $recover->(@{$attrs->{args}});
                  }
                  else {
                      die $@;
                  }
              }
              return;
          }
  
          # Otherwise, defer evaluation by returning an object...
          return $crv;
      }
  }
  
  handler:
  for my $context_name (@CONTEXTS, qw< RECOVER _internal_LIST CLEANUP >) {
      next handler if $context_name eq 'LIST'       # These
                   || $context_name eq 'VOID'       #  four
                   || $context_name eq 'SCALAR'     #   handled
                   || $context_name eq 'NONVOID';   #    separately
  
      no strict qw( refs );
      *{$context_name} = sub (&;$) {
          my ($block, $crv) = @_;
  
          # Ensure we have an object...
          my $attrs;
          if (!refaddr $crv) {
              my $args = do{ package DB; ()=CORE::caller(1); my $args = \@DB::args; ()=CORE::caller(1); $args };
              my $subname = (CORE::caller(1))[3];
              if (!defined $subname) {
                  $subname = "bare $context_name {...}";
              }
              $crv = bless \my $scalar, 'Contextual::Return::Value';
              $attrs = $attrs_of{refaddr $crv}
                       = { args => $args, sub => $subname };
          }
          else {
              $attrs = $attrs_of{refaddr $crv};
          }
          local $Contextual::Return::__RETOBJ__ = $crv;
  
          # Make sure this block is a possibility too...
          if ($context_name ne '_internal_LIST') {
              die _in_context "Can't install two $context_name handlers"
                  if exists $attrs->{$context_name};
              $attrs->{$context_name} = $block;
          }
  
          # Identify contexts...
          my $wantarray = wantarray;
          use Want ();
          $attrs->{want_pure_bool} ||= Want::want('BOOL');
  
          # Prepare for exception handling...
          my $recover = $attrs->{RECOVER};
          local $Contextual::Return::uplevel = 2;
          no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
  
          # Handle list context directly, if possible...
          if ($wantarray) {
              local $Contextual::Return::__RESULT__
                  = $context_name eq 'RECOVER' ? $Contextual::Return::__RESULT__
                  :                              undef
                  ;
  
              # List or ancestral handlers...
              handler:
              for my $context (qw(LIST VALUE NONVOID DEFAULT)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  my @rv = eval { $handler->(@{$attrs->{args}}) };
                  if ($recover) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [@rv];
                      }
                      () = $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  return @rv if !$Contextual::Return::__RESULT__;
                  return @{$Contextual::Return::__RESULT__};
              }
              # Convert to list from arrayref handler...
              if (!$attrs->{STRICT} and my $handler = $attrs->{ARRAYREF}) {
                  local $Contextual::Return::uplevel = 2;
  
                  # Array ref may be returned directly, or via RESULT{}...
                  my $array_ref = eval { $handler->(@{$attrs->{args}}) };
                  if ($recover) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$array_ref];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  $array_ref = $Contextual::Return::__RESULT__->[0]
                      if $Contextual::Return::__RESULT__;
  
                  return @{$array_ref} if (ref $array_ref||q{}) eq 'ARRAY';
              }
              # Return scalar object as one-elem list, if possible...
              handler:
              for my $context (qw(BOOL STR NUM VALUE SCALAR LAZY)) {
                  last if $attrs->{STRICT};
                  return $crv if exists $attrs->{$context};
              }
              $@ = _in_context "Can't call $attrs->{sub} in a list context";
              if ($recover) {
                  () = $recover->(@{$attrs->{args}});
              }
              else {
                  die $@;
              }
          }
  
          # Handle void context directly...
          if (!defined $wantarray) {
              handler:
              for my $context (qw(VOID DEFAULT)) {
                  if (!$attrs->{$context}) {
                      last handler if $attrs->{STRICT};
                      next handler;
                  }
  
                  eval { $attrs->{$context}->(@{$attrs->{args}}) };
  
                  if ($recover) {
                      $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  last handler;
              }
              if ($attrs->{STRICT}) {
                  $@ = _in_context "Can't call $attrs->{sub} in a void context";
                  if ($recover) {
                      () = $recover->(@{$attrs->{args}});
                  }
                  else {
                      die $@;
                  }
              }
              return;
          }
  
          # Otherwise, defer evaluation by returning an object...
          return $crv;
      }
  }
  
  # Alias LAZY to SCALAR...
  *LAZY = *SCALAR;
  
  
  # Set $Data::Dumper::Freezer to 'Contextual::Return::FREEZE' to be able to
  # dump contextual return values...
  
  my %operator_impl;
  
  my $no_handler_message = qr{
      ^ Can't [ ] call [ ] .*? [ ] in [ ] [\w]+ [ ] context
    | ^ [\w:]+ [ ] can't [ ] return [ ] a [ ] \w+ [ ] reference
  }xms;
  
  sub _flag_self_ref_in {
      my ($data_ref, $obj_ref) = @_;
      my $type = ref $data_ref;
      return if !$type;
      for my $ref ( $type eq 'SCALAR' ? ${$data_ref} : $type eq 'ARRAY' ? @{$data_ref} : ()) {
          no warnings 'numeric', 'uninitialized';
          if (refaddr($ref) == refaddr($obj_ref)) {
              $ref = '<<<self-reference>>>';
          }
      }
  }
  
  sub FREEZE {
      my ($self) = @_;
      my $attrs_ref = $attrs_of{refaddr $self};
      my $args_ref  = $attrs_ref->{args};
  
      my @no_handler;
  
      # Call appropriate operator handler, defusing and recording exceptions...
      my $overloaded = sub {
          my ($context, $op) = @_;
  
          # Try the operator...
          my $retval = eval { $operator_impl{$op}->($self,@{$args_ref}) };
  
          # Detect and report internal exceptions...
          if (my $exception = $@) {
              if ($exception =~ $no_handler_message) {
                  push @no_handler, $context;
                  return ();
              }
              chomp $exception;
              return { $context => "<<<Throws exception: $exception>>>" };
          }
  
          # Detect self-referential overloadings (to avoid infinite recursion)...
          {
              no warnings 'numeric', 'uninitialized';
              if (ref $retval eq 'REF' && eval{ ${$retval} == ${$self} }) {
                  return { $context => "<<<self-reference>>>" };
              }
          }
  
          # Normal return of contextual value labelled by context...
          return { $context => $retval };
      };
  
      my @values;
  
      # Where did this value originate?
      push @values, { ISA  => 'Contextual::Return::Value' };
      push @values, { FROM => $attrs_ref->{sub} };
  
      # Does it return a value in void context?
      if (exists $attrs_ref->{VOID} || exists $attrs_ref->{DEFAULT}) {
          push @values, { VOID => undef };
      }
      else {
          push @no_handler, 'VOID';
      }
  
      # Generate list context value by "pretend" LIST handler...
      push @values, { LIST => eval{ [ _internal_LIST(sub{}, $self) ] } // do{ chomp $@; "<<<Throws exception: $@>>>"} };
          _flag_self_ref_in($values[-1]{LIST}, $self);
  
      # Generate scalar context values by calling appropriate handler...
      push @values, $overloaded->( STR       => q{""}  );
      push @values, $overloaded->( NUM       => '0+'   );
      push @values, $overloaded->( BOOL      => 'bool' );
      push @values, $overloaded->( SCALARREF => '${}'  );
          _flag_self_ref_in($values[-1]{SCALARREF}, $self);
      push @values, $overloaded->( ARRAYREF  => '@{}'  );
          _flag_self_ref_in($values[-1]{ARRAYREF}, $self);
      push @values, $overloaded->( CODEREF   => '&{}'  );
      push @values, $overloaded->( HASHREF   => '%{}'  );
      push @values, $overloaded->( GLOBREF   => '*{}'  );
  
      # Are there handlers for various "generic" super-contexts...
      my @fallbacks = grep { $attrs_ref->{$_} }
                         qw< DEFAULT NONVOID SCALAR VALUE REF RECOVER >;
  
      push @values, { NO_HANDLER => \@no_handler };
      push @values, { FALLBACKS  => \@fallbacks  };
  
      # Temporarily replace object being dumped, by values found...
      $_[0] = \@values;
  }
  
  # Call this method on a contextual return value object to debug it...
  
  sub DUMP {
      if (eval{ require Data::Dumper; 1; }) {
          my ($crv) = @_;
          if (eval{ ref($crv)->isa('Contextual::Return::Value')}) {
              Contextual::Return::FREEZE($crv);
          }
          local $Data::Dumper::Terse = 1;
          local $Data::Dumper::Indent = 1;
          my $dump = Data::Dumper::Dumper($crv);
          $dump =~ s<,\n  \{><,ZZZZ{>msg;
          $dump =~ s<\n\s+>< >msg;
          $dump =~ s<,ZZZZ\{><\n  {>msg;
          return $dump;
      }
      else {
          Carp::carp("Can't DUMP contextual return value (no Data::Dumper!)");
          return;
      }
  }
  
  
  package Contextual::Return::Value;
  BEGIN { *_in_context = *Contextual::Return::_in_context; }
  use Scalar::Util qw( refaddr );
  
  BEGIN {
      %operator_impl = (
          q{""} => sub {
              my ($self) = @_;
              local $Contextual::Return::__RETOBJ__ = $self;
              no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
  
              my $attrs = $attrs_of{refaddr $self};
              handler:
              for my $context (qw(STR SCALAR LAZY VALUE NONVOID DEFAULT NUM)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  local $Contextual::Return::__RESULT__;
                  local $Contextual::Return::uplevel = 2;
                  my $rv = eval { $handler->(@{$attrs->{args}}) };
  
                  if (my $recover = $attrs->{RECOVER}) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$rv];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  if ($Contextual::Return::__RESULT__) {
                      $rv = $Contextual::Return::__RESULT__->[0];
                  }
  
                  if ( $attrs->{FIXED} ) {
                      $_[0] = $rv;
                  }
                  elsif ( !$attrs->{ACTIVE} ) {
                      $attrs->{$context} = sub { $rv };
                  }
                  return $rv;
              }
              $@ = _in_context "Can't use return value of $attrs->{sub} as a string";
              if (my $recover = $attrs->{RECOVER}) {
                  scalar $recover->(@{$attrs->{args}});
              }
              else {
                  die $@;
              }
          },
  
          q{0+} => sub {
              my ($self) = @_;
              local $Contextual::Return::__RETOBJ__ = $self;
              no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
              my $attrs = $attrs_of{refaddr $self};
              handler:
              for my $context (qw(NUM SCALAR LAZY VALUE NONVOID DEFAULT STR)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  local $Contextual::Return::__RESULT__;
                  local $Contextual::Return::uplevel = 2;
                  my $rv = eval { $handler->(@{$attrs->{args}}) };
  
                  if (my $recover = $attrs->{RECOVER}) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$rv];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  if ($Contextual::Return::__RESULT__) {
                      $rv = $Contextual::Return::__RESULT__->[0];
                  }
  
                  if ( $attrs->{FIXED} ) {
                      $_[0] = $rv;
                  }
                  elsif ( !$attrs->{ACTIVE} ) {
                      $attrs->{$context} = sub { $rv };
                  }
                  return $rv;
              }
              $@ = _in_context "Can't use return value of $attrs->{sub} as a number";
              if (my $recover = $attrs->{RECOVER}) {
                  scalar $recover->(@{$attrs->{args}});
              }
              else {
                  die $@;
              }
          },
  
          q{bool} => sub {
              my ($self) = @_;
              local $Contextual::Return::__RETOBJ__ = $self;
              no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
              my $attrs = $attrs_of{refaddr $self};
  
              # Handle Calls in Pure Boolean context...
              my @PUREBOOL = $attrs->{want_pure_bool} ? ('PUREBOOL') : ();
              $attrs->{want_pure_bool} = 0;
  
              handler:
              for my $context (@PUREBOOL, qw(BOOL STR NUM SCALAR LAZY VALUE NONVOID DEFAULT)) {
                  my $handler = $attrs->{$context}
                      or $context eq 'BOOL' and $attrs->{STRICT} and last handler
                      or next handler;
  
                  local $Contextual::Return::__RESULT__;
                  local $Contextual::Return::uplevel = 2;
                  my $outer_sig_warn = $SIG{__WARN__};
                  local $SIG{__WARN__}
                      = sub{ return if $_[0] =~ /^Exiting \S+ via next/;
                             goto &{$outer_sig_warn} if $outer_sig_warn;
                             warn @_;
                        };
                  my $rv = eval { $handler->(@{$attrs->{args}}) };
  
                  if (my $recover = $attrs->{RECOVER}) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$rv];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  if ($Contextual::Return::__RESULT__) {
                      $rv = $Contextual::Return::__RESULT__->[0];
                  }
  
                  if ( $attrs->{FIXED} ) {
                      $_[0] = $rv;
                  }
                  elsif ( !$attrs->{ACTIVE} ) {
                      $attrs->{$context} = sub { $rv };
                  }
                  return $rv;
              }
              $@ = _in_context "Can't use return value of $attrs->{sub} as a boolean";
              if (my $recover = $attrs->{RECOVER}) {
                  scalar $recover->(@{$attrs->{args}});
              }
              else {
                  die $@;
              }
          },
          '${}' => sub {
              my ($self) = @_;
              local $Contextual::Return::__RETOBJ__ = $self;
              no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
              my $attrs = $attrs_of{refaddr $self};
              handler:
              for my $context (qw(SCALARREF REF NONVOID DEFAULT)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  local $Contextual::Return::__RESULT__;
                  local $Contextual::Return::uplevel = 2;
                  my $rv = eval { $handler->(@{$attrs->{args}}) };
  
                  if (my $recover = $attrs->{RECOVER}) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$rv];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  if ($Contextual::Return::__RESULT__) {
                      $rv = $Contextual::Return::__RESULT__->[0];
                  }
  
                  # Catch bad behaviour...
                  die _in_context "$context block did not return ",
                                  "a suitable reference to the scalar dereference"
                          if ref($rv) ne 'SCALAR' && ref($rv) ne 'OBJ';
  
                  if ( $attrs->{FIXED} ) {
                      $_[0] = $rv;
                  }
                  elsif ( !$attrs->{ACTIVE} ) {
                      $attrs->{$context} = sub { $rv };
                  }
                  return $rv;
              }
  
              if ($attrs->{STRICT}) {
                  $@ = _in_context "Call to $attrs->{sub} didn't return a scalar reference, as required <LOC>";
                  if (my $recover = $attrs->{RECOVER}) {
                      scalar $recover->(@{$attrs->{args}});
                  }
                  else {
                      die $@;
                  }
              }
  
              if ( $attrs->{FIXED} ) {
                  $_[0] = \$self;
              }
              return \$self;
          },
          '@{}' => sub {
              my ($self) = @_;
              local $Contextual::Return::__RETOBJ__ = $self;
              no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
              my $attrs = $attrs_of{refaddr $self};
              local $Contextual::Return::__RESULT__;
              handler:
              for my $context (qw(ARRAYREF REF)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  local $Contextual::Return::uplevel = 2;
                  my $rv = eval { $handler->(@{$attrs->{args}}) };
  
                  if (my $recover = $attrs->{RECOVER}) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$rv];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  if ($Contextual::Return::__RESULT__) {
                      $rv = $Contextual::Return::__RESULT__->[0];
                  }
  
                  # Catch bad behaviour...
                  die _in_context "$context block did not return ",
                                  "a suitable reference to the array dereference"
                          if ref($rv) ne 'ARRAY' && ref($rv) ne 'OBJ';
  
                  if ( $attrs->{FIXED} ) {
                      $_[0] = $rv;
                  }
                  elsif ( !$attrs->{ACTIVE} ) {
                      $attrs->{$context} = sub { $rv };
                  }
                  return $rv;
              }
              handler:
              for my $context (qw(LIST VALUE NONVOID DEFAULT)) {
                  last handler if $attrs->{STRICT};
                  my $handler = $attrs->{$context}
                      or next handler;
  
                  local $Contextual::Return::uplevel = 2;
                  my @rv = eval { $handler->(@{$attrs->{args}}) };
  
                  if (my $recover = $attrs->{RECOVER}) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [@rv];
                      }
                      () = $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  if ($Contextual::Return::__RESULT__) {
                      @rv = @{$Contextual::Return::__RESULT__->[0]};
                  }
  
                  if ( $attrs->{FIXED} ) {
                      $_[0] = \@rv;
                  }
                  elsif ( !$attrs->{ACTIVE} ) {
                      $attrs->{$context} = sub { @rv };
                  }
                  return \@rv;
              }
  
              if ($attrs->{STRICT}) {
                  $@ = _in_context "Call to $attrs->{sub} didn't return an array reference, as required <LOC>";
                  if (my $recover = $attrs->{RECOVER}) {
                      scalar $recover->(@{$attrs->{args}});
                  }
                  else {
                      die $@;
                  }
              }
  
              return [ $self ];
          },
          '%{}' => sub {
              my ($self) = @_;
              local $Contextual::Return::__RETOBJ__ = $self;
              no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
              my $attrs = $attrs_of{refaddr $self};
              handler:
              for my $context (qw(HASHREF REF NONVOID DEFAULT)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  local $Contextual::Return::__RESULT__;
                  local $Contextual::Return::uplevel = 2;
                  my $rv = eval { $handler->(@{$attrs->{args}}) };
  
                  if (my $recover = $attrs->{RECOVER}) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$rv];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  if ($Contextual::Return::__RESULT__) {
                      $rv = $Contextual::Return::__RESULT__->[0];
                  }
  
                  # Catch bad behaviour...
                  die _in_context "$context block did not return ",
                                  "a suitable reference to the hash dereference"
                          if ref($rv) ne 'HASH' && ref($rv) ne 'OBJ';
  
                  if ( $attrs->{FIXED} ) {
                      $_[0] = $rv;
                  }
                  elsif ( !$attrs->{ACTIVE} ) {
                      $attrs->{$context} = sub { $rv };
                  }
                  return $rv;
              }
              $@ = _in_context "Call to $attrs->{sub} didn't return a hash reference, as required <LOC>";
              if (my $recover = $attrs->{RECOVER}) {
                  scalar $recover->(@{$attrs->{args}});
              }
              else {
                  die $@;
              }
          },
          '&{}' => sub {
              my ($self) = @_;
              local $Contextual::Return::__RETOBJ__ = $self;
              no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
              my $attrs = $attrs_of{refaddr $self};
              handler:
              for my $context (qw(CODEREF REF NONVOID DEFAULT)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  local $Contextual::Return::__RESULT__;
                  local $Contextual::Return::uplevel = 2;
                  my $rv = eval { $handler->(@{$attrs->{args}}) };
  
                  if (my $recover = $attrs->{RECOVER}) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$rv];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  if ($Contextual::Return::__RESULT__) {
                      $rv = $Contextual::Return::__RESULT__->[0];
                  }
  
                  # Catch bad behaviour...
                  die _in_context "$context block did not return ",
                                  "a suitable reference to the subroutine dereference"
                          if ref($rv) ne 'CODE' && ref($rv) ne 'OBJ';
  
                  if ( $attrs->{FIXED} ) {
                      $_[0] = $rv;
                  }
                  elsif ( !$attrs->{ACTIVE} ) {
                      $attrs->{$context} = sub { $rv };
                  }
                  return $rv;
              }
              $@ = _in_context "Call to $attrs->{sub} didn't return a subroutine reference, as required <LOC>";
              if (my $recover = $attrs->{RECOVER}) {
                  scalar $recover->(@{$attrs->{args}});
              }
              else {
                  die $@;
              }
          },
          '*{}' => sub {
              my ($self) = @_;
              local $Contextual::Return::__RETOBJ__ = $self;
              no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
              my $attrs = $attrs_of{refaddr $self};
              handler:
              for my $context (qw(GLOBREF REF NONVOID DEFAULT)) {
                  my $handler = $attrs->{$context}
                      or $attrs->{STRICT} and last handler
                      or next handler;
  
                  local $Contextual::Return::__RESULT__;
                  local $Contextual::Return::uplevel = 2;
                  my $rv = eval { $handler->(@{$attrs->{args}}) };
  
                  if (my $recover = $attrs->{RECOVER}) {
                      if (!$Contextual::Return::__RESULT__) {
                          $Contextual::Return::__RESULT__ = [$rv];
                      }
                      scalar $recover->(@{$attrs->{args}});
                  }
                  elsif ($@) {
                      die $@;
                  }
  
                  if ($Contextual::Return::__RESULT__) {
                      $rv = $Contextual::Return::__RESULT__->[0];
                  }
  
                  # Catch bad behaviour...
                  die _in_context "$context block did not return ",
                                  "a suitable reference to the typeglob dereference"
                          if ref($rv) ne 'GLOB' && ref($rv) ne 'OBJ';
  
                  if ( $attrs->{FIXED} ) {
                      $_[0] = $rv;
                  }
                  elsif ( !$attrs->{ACTIVE} ) {
                      $attrs->{$context} = sub { $rv };
                  }
                  return $rv;
              }
              $@ = _in_context "Call to $attrs->{sub} didn't return a typeglob reference, as required <LOC>";
              if (my $recover = $attrs->{RECOVER}) {
                  scalar $recover->(@{$attrs->{args}});
              }
              else {
                  die $@;
              }
          },
      );
  }
  
  use overload %operator_impl, fallback => 1;
  
  sub DESTROY {
      my ($id) = refaddr shift;
      my $attrs = $attrs_of{$id};
      no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
      if (my $handler = $attrs->{CLEANUP}) {
          $handler->(@{ $attrs->{args} });
      }
      delete $attrs_of{$id};
      return;
  }
  
  my $NO_SUCH_METHOD = qr/\ACan't (?:locate|call)(?: class| object)? method/ms;
  
  # Forward metainformation requests to actual class...
  sub can {
      my ($invocant) = @_;
      # Only forward requests on actual C::R::V objects...
      if (ref $invocant) {
          our $AUTOLOAD = 'can';
          goto &AUTOLOAD;
      }
  
      # Refer requests on classes to actual class hierarchy...
      return $invocant->SUPER::can(@_[1..$#_]);
  }
  
  sub isa {
      # Only forward requests on actual C::R::V objects...
      my ($invocant) = @_;
      if (ref $invocant) {
          our $AUTOLOAD = 'isa';
          goto &AUTOLOAD;
      }
  
      # Refer requests on classes to actual class hierarchy...
      return $invocant->SUPER::isa(@_[1..$#_]);
  }
  
  
  sub AUTOLOAD {
      my ($self) = @_;
      our $AUTOLOAD;
  
      my ($requested_method) = $AUTOLOAD =~ m{ .* :: (.*) }xms ? $1 : $AUTOLOAD;
  
      my $attrs = $attrs_of{refaddr $self} || {};
      local $Contextual::Return::__RETOBJ__ = $self;
      no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
  
      # First, see if there is a method call handler...
      if (my $context_handler = $attrs->{METHOD}) {
          local $Contextual::Return::__RESULT__;
          local $Contextual::Return::uplevel = 2;
          my @method_handlers = eval { $context_handler->(@{$attrs->{args}}) };
  
          if (my $recover = $attrs->{RECOVER}) {
              if (!$Contextual::Return::__RESULT__) {
                  $Contextual::Return::__RESULT__ = [\@method_handlers];
              }
              scalar $recover->(@{$attrs->{args}});
          }
          elsif ($@) {
              die $@;
          }
  
          if ($Contextual::Return::__RESULT__) {
              @method_handlers = @{$Contextual::Return::__RESULT__};
          }
  
          # Locate the correct method handler (if any)...
          MATCHER:
          while (my ($matcher, $method_handler) = splice @method_handlers, 0, 2) {
  
              if (ref($matcher) eq 'ARRAY') {
                  next MATCHER
                      if !grep { $requested_method =~ $_ } @{$matcher};
              }
              elsif ($requested_method !~ $matcher) {
                  next MATCHER;
              }
  
              shift;
              if (wantarray) {
                  my @result = eval {
                      local $_ = $requested_method;
                      $method_handler->($self,@_);
                  };
                  die _in_context $@ if $@;
                  return @result;
              }
              else {
                  my $result = eval {
                      local $_ = $requested_method;
                      $method_handler->($self,@_);
                  };
                  die _in_context $@ if $@;
                  return $result;
              }
          }
      }
  
      # Next, try to create an object on which to call the method...
      handler:
      for my $context (qw(OBJREF STR SCALAR LAZY VALUE NONVOID DEFAULT)) {
          my $handler = $attrs->{$context}
              or $attrs->{STRICT} and last handler
              or next handler;
  
          local $Contextual::Return::__RESULT__;
          local $Contextual::Return::uplevel = 2;
          my $object = eval { $handler->(@{$attrs->{args}}) };
  
          if (my $recover = $attrs->{RECOVER}) {
              if (!$Contextual::Return::__RESULT__) {
                  $Contextual::Return::__RESULT__ = [$object];
              }
              scalar $recover->(@{$attrs->{args}});
          }
          elsif ($@) {
              die $@;
          }
  
          if ($Contextual::Return::__RESULT__) {
              $object = $Contextual::Return::__RESULT__->[0];
          }
  
          if ( $attrs->{FIXED} ) {
              $_[0] = $object;
          }
          elsif ( !$attrs->{ACTIVE} ) {
              $attrs->{$context} = sub { $object };
          }
          shift;
  
          if (wantarray) {
              my @result = eval { $object->$requested_method(@_) };
              my $exception = $@;
              return @result if !$exception;
              die _in_context $exception if $exception !~ $NO_SUCH_METHOD;
          }
          else {
              my $result = eval { $object->$requested_method(@_) };
              my $exception = $@;
              return $result if !$exception;
              die _in_context $exception if $exception !~ $NO_SUCH_METHOD;
          }
          $@ = _in_context "Can't call method '$requested_method' on $context value returned by $attrs->{sub}";
          if (my $recover = $attrs->{RECOVER}) {
              scalar $recover->(@{$attrs->{args}});
          }
          else {
              die $@;
          }
      }
  
      # Otherwise, the method cannot be called, so react accordingly...
      $@ = _in_context "Can't call method '$requested_method' on value returned by $attrs->{sub}";
      if (my $recover = $attrs->{RECOVER}) {
          return scalar $recover->(@{$attrs->{args}});
      }
      else {
          die $@;
      }
  }
  
  package Contextual::Return::Lvalue;
  
  sub TIESCALAR {
      my ($package, @handler) = @_;
      return bless {@handler}, $package;
  }
  
  # Handle calls that are lvalues...
  sub STORE {
      local *CALLER::_ = \$_;
      local *_         = \$_[1];
      local $Contextual::Return::uplevel = 1;
      no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
      local $Contextual::Return::__RESULT__;
  
      my $rv = $_[0]{LVALUE}( @{$_[0]{args}} );
  
      return $rv if !$Contextual::Return::__RESULT__;
      return $Contextual::Return::__RESULT__->[0];
  }
  
  # Handle calls that are rvalues...
  sub FETCH {
      local $Contextual::Return::uplevel = 1;
      no warnings 'redefine'; local *CORE::GLOBAL::caller = $smart_caller;
      local $Contextual::Return::__RESULT__;
  
      my $rv = $_[0]{RVALUE} ? $_[0]{RVALUE}( @{$_[0]{args}} ) : undef;
  
      return $rv if !$Contextual::Return::__RESULT__;
      return $Contextual::Return::__RESULT__->[0];
  }
  
  sub DESTROY {};
  
  1; # Magic true value required at end of module
  
  __END__
  
  =head1 NAME
  
  Contextual::Return - Create context-sensitive return values
  
  
  =head1 VERSION
  
  This document describes Contextual::Return version 0.004014
  
  
  =head1 SYNOPSIS
  
      use Contextual::Return;
      use Carp;
  
      sub foo {
          return
              SCALAR { 'thirty-twelve' }
              LIST   { 1,2,3 }
  
              BOOL { 1 }
              NUM  { 7*6 }
              STR  { 'forty-two' }
  
              HASHREF  { {name => 'foo', value => 99} }
              ARRAYREF { [3,2,1] }
  
              GLOBREF  { \*STDOUT }
              CODEREF  { croak "Don't use this result as code!"; }
          ;
      }
  
      # and later...
  
      if (my $foo = foo()) {
          for my $count (1..$foo) {
              print "$count: $foo is:\n"
                  . "  array: @{$foo}\n"
                  . "  hash:  $foo->{name} => $foo->{value}\n"
                  ;
          }
          print {$foo} $foo->();
      }
  
  =head1 DESCRIPTION
  
  Usually, when you need to create a subroutine that returns different values in
  different contexts (list, scalar, or void), you write something like:
  
      sub get_server_status {
          my ($server_ID) = @_;
  
          # Acquire server data somehow...
          my %server_data = _ascertain_server_status($server_ID);
  
          # Return different components of that data,
          # depending on call context...
          if (wantarray()) {
              return @server_data{ qw(name uptime load users) };
          }
          if (defined wantarray()) {
              return $server_data{load};
          }
          if (!defined wantarray()) {
              carp 'Useless use of get_server_status() in void context';
              return;
          }
          else {
              croak q{Bad context! No biscuit!};
          }
      }
  
  That works okay, but the code could certainly be more readable. In
  its simplest usage, this module makes that code more readable by
  providing three subroutines--C<LIST()>, C<SCALAR()>, C<VOID()>--that
  are true only when the current subroutine is called in the
  corresponding context:
  
      use Contextual::Return;
  
      sub get_server_status {
          my ($server_ID) = @_;
  
          # Acquire server data somehow...
          my %server_data = _ascertain_server_status($server_ID);
  
          # Return different components of that data
          # depending on call context...
          if (LIST)   { return @server_data{ qw(name uptime load users) } }
          if (SCALAR) { return $server_data{load}                         }
          if (VOID)   { print "$server_data{load}\n"                      }
          else        { croak q{Bad context! No biscuit!}                 }
      }
  
  =head2 Contextual returns
  
  Those three subroutines can also be used in another way: as labels on a
  series of I<contextual return blocks> (collectively known as a I<contextual
  return sequence>). When a context sequence is returned, it automatically
  selects the appropriate contextual return block for the calling context.
  So the previous example could be written even more cleanly as:
  
      use Contextual::Return;
  
      sub get_server_status {
          my ($server_ID) = @_;
  
          # Acquire server data somehow...
          my %server_data = _ascertain_server_status($server_ID);
  
          # Return different components of that data
          # depending on call context...
          return (
              LIST    { return @server_data{ qw(name uptime load users) } }
              SCALAR  { return $server_data{load}                         }
              VOID    { print "$server_data{load}\n"                      }
              DEFAULT { croak q{Bad context! No biscuit!}                 }
          );
      }
  
  The context sequence automatically selects the appropriate block for each call
  context.
  
  
  =head2 Lazy contextual return values
  
  C<LIST> and C<VOID> blocks are always executed during the C<return>
  statement. However, scalar return blocks (C<SCALAR>, C<STR>, C<NUM>,
  C<BOOL>, etc.) blocks are not. Instead, returning any of scalar block
  types causes the subroutine to return an object that lazily
  evaluates that block only when the return value is used.
  
  This means that returning a C<SCALAR> block is a convenient way to
  implement a subroutine with a lazy return value. For example:
  
      sub digest {
          return SCALAR {
              my ($text) = @_;
              md5($text);
          }
      }
  
      my $digest = digest($text);
  
      print $digest;   # md5() called only when $digest used as string
  
  To better document this usage, the C<SCALAR> block has a synonym: C<LAZY>.
  
      sub digest {
          return LAZY {
              my ($text) = @_;
              md5($text);
          }
      }
  
  
  =head2 Active contextual return values
  
  Once a return value has been lazily evaluated in a given context,
  the resulting value is cached, and thereafter reused in that same context.
  
  However, you can specify that, rather than being cached, the value
  should be re-evaluated I<every> time the value is used:
  
       sub make_counter {
          my $counter = 0;
          return ACTIVE
              SCALAR   { ++$counter }
              ARRAYREF { [1..$counter] }
      }
  
      my $idx = make_counter();
  
      print "$idx\n";      # 1
      print "$idx\n";      # 2
      print "[@$idx]\n";   # [1 2]
      print "$idx\n";      # 3
      print "[@$idx]\n";   # [1 2 3]
  
  
  =head2 Semi-lazy contextual return values
  
  Sometimes, single or repeated lazy evaluation of a scalar return value
  in different contexts isn't what you really want. Sometimes what you
  really want is for the return value to be lazily evaluated once only (the
  first time it's used in any context), and then for that first value to
  be reused whenever the return value is subsequently reevaluated in any
  other context.
  
  To get that behaviour, you can use the C<FIXED> modifier, which causes
  the return value to morph itself into the actual value the first time it
  is used. For example:
  
      sub lazy {
          return
              SCALAR { 42 }
              ARRAYREF { [ 1, 2, 3 ] }
          ;
      }
  
      my $lazy = lazy();
      print $lazy + 1;            # 43
      print "@{$lazy}";           # 1 2 3
  
  
      sub semilazy {
          return FIXED
              SCALAR { 42 }
              ARRAYREF { [ 1, 2, 3 ] }
          ;
      }
  
      my $semi = semilazy();
      print $semi + 1;            # 43
      print "@{$semi}";           # die q{Can't use string ("42") as an ARRAY ref}
  
  
  
  =head2 Finer distinctions of scalar context
  
  Because the scalar values returned from a context sequence are lazily
  evaluated, it becomes possible to be more specific about I<what kind> of
  scalar value should be returned: a boolean, a number, or a string. To support
  those distinctions, Contextual::Return provides four extra context blocks:
  C<NUM>, C<STR>, C<BOOL>, and C<PUREBOOL>:
  
      sub get_server_status {
          my ($server_ID) = @_;
  
          # Acquire server data somehow...
          my %server_data = _ascertain_server_status($server_ID);
  
          # Return different components of that data
          # depending on call context...
          return (
                 LIST { @server_data{ qw(name uptime load users) }          }
             PUREBOOL { $_ = $server_data{uptime}; $server_data{uptime} > 0 }
                 BOOL { $server_data{uptime} > 0                            }
                 NUM  { $server_data{load}                                  }
                 STR  { "$server_data{name}: $server_data{uptime}"          }
                 VOID { print "$server_data{load}\n"                        }
              DEFAULT { croak q{Bad context! No biscuit!}                   }
          );
      }
  
  With these in place, the object returned from a scalar-context call to
  C<get_server_status()> now behaves differently, depending on how
  it's used. For example:
  
      if ( my $status = get_server_status() ) {  # BOOL: True if uptime > 0
          $load_distribution[$status]++;         # INT:  Evaluates to load value
          print "$status\n";                     # STR:  Prints "name: uptime"
      }
  
      if (get_server_status()) {                 # PUREBOOL: also sets $_;
          print;                                 # ...which is then used here
      }
  
  =head3 Boolean vs Pure Boolean contexts
  
  There is a special subset of boolean contexts where the return value is being
  used and immediately thrown away. For example, in the loop:
  
      while (get_data()) {
          ...
      }
  
  the value returned by C<get_data()> is tested for truth and then discarded.
  This is known as "pure boolean context". In contrast, in the loop:
  
      while (my $data = get_data()) {
          ...
      }
  
  the value returned by C<get_data()> is first assigned to C<$data>, then
  tested for truth. Because of the assignment, the return value is I<not>
  discarded after the boolean test. This is ordinary "boolean context".
  
  In Perl, pure boolean context is often associated with a special side-effect,
  that does not occur in regular boolean contexts. For example:
  
      while (<>) {...}         # $_ set as side-effect of pure boolean context
  
      while ($v = <>) {...}    # $_ NOT set in ordinary boolean context
  
  Contextual::Return supports this with a special subcase of C<BOOL> named
  <PUREBOOL>. In pure boolean contexts, Contextual::Return will call a
  C<PUREBOOL> handler if one has been defined, or fall back to a C<BOOL>
  or C<SCALAR> handler if no C<PUREBOOL> handler exists. In ordinary
  boolean contexts only the C<BOOL> or C<SCALAR> handlers are tried, even
  if a C<PUREBOOL> handler is also defined.
  
  Typically C<PUREBOOL> handlers are set up to have some side-effect (most
  commonly: setting C<$_> or <$@>), like so:
  
      sub get_data {
          my ($succeeded, @data) = _go_and_get_data();
  
          return
              PUREBOOL { $_ = $data[0]; $succeeded; }
                  BOOL {                $succeeded; }
                SCALAR {                $data[0];   }
                  LIST {                @data;      }
      }
  
  However, there is no requirement that they have side-effects. For example,
  they can also be used to implement "look-but-don't-retrieve-yet" checking:
  
      sub get_data {
          my $data;
          return
              PUREBOOL {        _check_for_but_dont_get_data();   }
                  BOOL { defined( $data ||= _go_and_get_data() ); }
                   REF {          $data ||= _go_and_get_data();   }
      }
  
  
  =head2 Self-reference within handlers
  
  Any handler can refer to the contextual return object it is part of, by
  calling the C<RETOBJ()> function. This is particularly useful for C<PUREBOOL>
  and C<LIST> handlers. For example:
  
      return
          PUREBOOL { $_ = RETOBJ; next handler; }
              BOOL { !$failed;                  }
           DEFAULT { $data;                     };
  
  
  =head2 Referential contexts
  
  The other major kind of scalar return value is a reference.
  Contextual::Return provides contextual return blocks that allow you to
  specify what to (lazily) return when the return value of a subroutine is
  used as a reference to a scalar (C<SCALARREF {...}>), to an array
  (C<ARRAYREF {...}>), to a hash (C<HASHREF {...}>), to a subroutine
  (C<CODEREF {...}>), or to a typeglob (C<GLOBREF {...}>).
  
  For example, the server status subroutine shown earlier could be extended to
  allow it to return a hash reference, thereby supporting "named return values":
  
      sub get_server_status {
          my ($server_ID) = @_;
  
          # Acquire server data somehow...
          my %server_data = _ascertain_server_status($server_ID);
  
          # Return different components of that data
          # depending on call context...
          return (
                 LIST { @server_data{ qw(name uptime load users) }  }
                 BOOL { $server_data{uptime} > 0                    }
                  NUM { $server_data{load}                          }
                  STR { "$server_data{name}: $server_data{uptime}"  }
                 VOID { print "$server_data{load}\n"                }
              HASHREF { return \%server_data                        }
              DEFAULT { croak q{Bad context! No biscuit!}           }
          );
      }
  
      # and later...
  
      my $users = get_server_status->{users};
  
  
      # or, lazily...
  
      my $server = get_server_status();
  
      print "$server->{name} load = $server->{load}\n";
  
  
  =head2 Interpolative referential contexts
  
  The C<SCALARREF {...}> and C<ARRAYREF {...}> context blocks are
  especially useful when you need to interpolate a subroutine into
  strings. For example, if you have a subroutine like:
  
      sub get_todo_tasks {
          return (
              SCALAR { scalar @todo_list }      # How many?
              LIST   { @todo_list        }      # What are they?
          );
      }
  
      # and later...
  
      print "There are ", scalar(get_todo_tasks()), " tasks:\n",
              get_todo_tasks();
  
  then you could make it much easier to interpolate calls to that
  subroutine by adding:
  
      sub get_todo_tasks {
          return (
              SCALAR { scalar @todo_list }      # How many?
              LIST   { @todo_list        }      # What are they?
  
              SCALARREF { \scalar @todo_list }  # Ref to how many
              ARRAYREF  { \@todo_list        }  # Ref to them
          );
      }
  
      # and then...
  
      print "There are ${get_todo_tasks()} tasks:\n@{get_todo_tasks()}";
  
  In fact, this behaviour is so useful that it's the default. If you
  don't provide an explicit C<SCALARREF {...}> block,
  Contextual::Return automatically provides an implicit one that simply
  returns a reference to whatever would have been returned in scalar context.
  Likewise, if no C<ARRAYREF {...}> block is specified, the module supplies one
  that returns the list-context return value wrapped up in an array reference.
  
  So you could just write:
  
      sub get_todo_tasks {
          return (
              SCALAR { scalar @todo_list }      # How many?
              LIST   { @todo_list        }      # What are they?
          );
      }
  
      # and still do this...
  
      print "There are ${get_todo_tasks()} tasks:\n@{get_todo_tasks()}";
  
  
  =head2 Fallback contexts
  
  As the previous sections imply, the C<BOOL {...}>, C<NUM {...}>, C<STR
  {...}>, and various C<*REF {...}> blocks, are special cases of the
  general C<SCALAR {...}> context block. If a subroutine is called in one
  of these specialized contexts but does not use the corresponding context
  block, then the more general C<SCALAR {...}> block is used instead (if
  it has been specified).
  
  So, for example:
  
      sub read_value_from {
          my ($fh) = @_;
  
          my $value = <$fh>;
          chomp $value;
  
          return (
              BOOL   { defined $value }
              SCALAR { $value         }
          );
      }
  
  ensures that the C<read_value_from()> subroutine returns true in boolean
  contexts if the read was successful. But, because no specific C<NUM {...}>
  or C<STR {...}> return behaviours were specified, the subroutine falls back on
  using its generic C<SCALAR {...}> block in all other scalar contexts.
  
  Another way to think about this behaviour is that the various kinds of
  scalar context blocks form a hierarchy:
  
      SCALAR
           ^
           |
           |--< BOOL
           |
           |--< NUM
           |
           `--< STR
  
  Contextual::Return uses this hierarchical relationship to choose the most
  specific context block available to handle any particular return context,
  working its way up the tree from the specific type it needs, to the more
  general type, if that's all that is available.
  
  There are two slight complications to this picture. The first is that Perl
  treats strings and numbers as interconvertable so the diagram (and the
  Contextual::Return module) also has to allow these interconversions as a
  fallback strategy:
  
      SCALAR
           ^
           |
           |--< BOOL
           |
           |--< NUM
           |    : ^
           |    v :
           `--< STR
  
  The dotted lines are meant to indicate that this intraconversion is secondary
  to the main hierarchical fallback. That is, in a numeric context, a C<STR
  {...}> block will only be used if there is no C<NUM {...}> block I<and> no
  C<SCALAR {...}> block. In other words, the generic context type is always
  used in preference to string<->number conversion.
  
  The second slight complication is that the above diagram only shows a
  small part of the complete hierarchy of contexts supported by
  Contextual::Return. The full fallback hierarchy (including dotted
  interconversions) is:
  
        DEFAULT
           ^
           |
           |--< VOID
           |
           `--< NONVOID
                   ^
                   |
                   |--< VALUE <...............
                   |      ^                   :
                   |      |                   :
                   |      |--< SCALAR <.......:...
                   |      |           ^           :
                   |      |           |           :
                   |      |           |--< BOOL   :
                   |      |           |     ^     :
                   |      |           |     |     :
                   |      |           |  PUREBOOL :
                   |      |           |           :
                   |      |           |--< NUM <..:.
                   |      |           |    : ^      :
                   |      |           |    v :      :
                   |      |           `--< STR <....:..
                   |      |                           :
                   |      |                          ::
                   |      `--< LIST ................: :
                   |            : ^                   :
                   |            : :                   :
                   `--- REF     : :                   :
                         ^      : :                   :
                         |      v :                   :
                         |--< ARRAYREF                :
                         |                            :
                         |--< SCALARREF .............:
                         |
                         |--< HASHREF
                         |
                         |--< CODEREF
                         |
                         |--< GLOBREF
                         |
                         `--< OBJREF <....... METHOD
                                 ^
                                 :........... BLESSED
  
  As before, each dashed arrow represents a fallback relationship. That
  is, if the required context specifier isn't available, the arrows are
  followed until a more generic one is found. The dotted arrows again
  represent the interconversion of return values, which is
  attempted only after the normal hierarchical fallback fails.
  
  For example, if a subroutine is called in a context that expects a
  scalar reference, but no C<SCALARREF {...}> block is provided, then
  Contextual::Return tries the following blocks in order:
  
          REF {...}
      NONVOID {...}
      DEFAULT {...}
          STR {...} (automatically taking a reference to the result)
          NUM {...} (automatically taking a reference to the result)
       SCALAR {...} (automatically taking a reference to the result)
        VALUE {...} (automatically taking a reference to the result)
  
  Likewise, in a list context, if there is no C<LIST {...}> context block, the
  module tries:
  
         VALUE {...}
       NONVOID {...}
       DEFAULT {...}
      ARRAYREF {...} (automatically dereferencing the result)
           STR {...} (treating it as a list of one element)
           NUM {...} (treating it as a list of one element)
        SCALAR {...} (treating it as a list of one element)
  
  The more generic context blocks are especially useful for intercepting
  unexpected and undesirable call contexts. For example, to turn I<off>
  the automatic scalar-ref and array-ref interpolative behaviour described
  in L<Interpolative referential contexts>, you could intercept I<all>
  referential contexts using a generic C<REF {...}> context block:
  
      sub get_todo_tasks {
          return (
              SCALAR { scalar @todo_list }      # How many?
              LIST   { @todo_list        }      # What are they?
  
              REF { croak q{get_todo_task() can't be used as a reference} }
          );
      }
  
      print 'There are ', get_todo_tasks(), '...';    # Still okay
      print "There are ${get_todo_tasks()}...";       # Throws an exception
  
  
  =head2 Treating return values as objects
  
  Normally, when a return value is treated as an object (i.e. has a method
  called on it), Contextual::Return invokes any C<OBJREF> handler that was
  specified in the contextual return list, and delegates the method call to
  the object returned by that handler.
  
  However, you can also be more specific, by specifying a C<METHOD> context
  handler in the contextual return list. The block of this handler is expected
  to return one or more method-name/method-handler pairs, like so:
  
      return
          METHOD {
              get_count => sub { my $n = shift; $data[$n]{count} },
              get_items => sub { my $n = shift; $data[$n]{items} },
              clear     => sub { @data = (); },
              reset     => sub { @data = (); },
          }
  
  Then, whenever one of the specified methods is called on the return value,
  the corresponding subroutine will be called to implement it.
  
  The method handlers must always be subroutine references, but the method-name
  specifiers may be strings (as in the previous example) or they may be
  specified generically, as either regexes or array references. Generic method
  names are used to call the same handler for two or more distinct method names.
  For example, the previous example could be simplified to:
  
      return
          METHOD {
              qr/get_(\w+)/     => sub { my $n = shift; $data[$n]{$1} },
              ['clear','reset'] => sub { @data = (); },
          }
  
  A method name specified by regex will invoke the corresponding handler for any
  method call request that the regex matches. A method name specified by array
  ref will invoke the corresponding handler if the method requested matches any
  of the elements of the array (which may themselves be strings or regexes).
  
  When the method handler is invoked, the name of the method requested is
  passed to the handler in C<$_>, and the method's argument list is passed
  (as usual) via C<@_>.
  
  Note that any methods not explicitly handled by the C<METHOD> handlers
  will still be delegated to the object returned by the C<OBJREF> handler
  (if it is also specified).
  
  
  =head2 Not treating return values as objects
  
  The use of C<OBJREF> and C<METHOD> are slightly complicated by the fact
  that contextual return values are themselves objects.
  
  For example, prior to version 0.4.4 of the module, if you passed a
  contextual return value to C<Scalar::Util::blessed()>, it always
  returned a true value (namely, the string: 'Contextual::Return::Value'),
  even if the return value had not specified handlers for C<OBJREF> or
  C<METHOD>.
  
  In other words, the I<implementation> of contextual return values (as
  objects) was getting in the way of the I<use> of contextual return
  values (as non-objects).
  
  So the module now also provides a C<BLESSED> handler, which allows you
  to explicitly control how contextual return values interact with
  C<Scalar::Util::blessed()>.
  
  If C<$crv> is a contextual return value, by default
  C<Scalar::Util::blessed($crv)> will now only return true if that return
  value has a C<OBJREF>, C<LAZY>, C<REF>, C<SCALAR>, C<VALUE>, C<NONVOID>,
  or C<DEFAULT> handler that in turn returns a blessed object.
  
  However if C<$crv> also provides a C<BLESSED> handler, C<blessed()>
  will return whatever that handler returns.
  
  This means:
  
      sub simulate_non_object {
          return BOOL { 1 }
                  NUM { 42 }
      }
  
      sub simulate_real_object {
          return OBJREF { bless {}, 'My::Class' }
                   BOOL { 1 }
                    NUM { 42 }
      }
  
      sub simulate_faked_object {
          return BLESSED { 'Foo' }
                    BOOL { 1 }
                     NUM { 42 }
      }
  
      sub simulate_previous_behaviour {
          return BLESSED { 'Contextual::Return::Value' }
                    BOOL { 1 }
                     NUM { 42 }
      }
  
  
      say blessed( simulate_non_object()         );   # undef
      say blessed( simulate_real_object()        );   # My::Class
      say blessed( simulate_faked_object()       );   # Foo
      say blessed( simulate_previous_behaviour() );   # Contextual::Return::Value
  
  Typically, you either want no C<BLESSED> handler (in which case
  contextual return values pretend not to be blessed objects), or you want
  C<BLESSED { 'Contextual::Return::Value' }> for backwards compatibility
  with pre-v0.4.7 behaviour.
  
  
  =head3 Preventing fallbacks
  
  Sometimes fallbacks can be too helpful. Or sometimes you want to impose
  strict type checking on a return value.
  
  Contextual::Returns allows that via the C<STRICT> specifier. If you include
  C<STRICT> anywhere in your return statement, the module disables all
  fallbacks and will therefore through an exception if the return value is
  used in any way not explicitly specified in the contextual return sequence.
  
  For example, to create a subroutine that returns only a string:
  
      sub get_name {
          return STRICT STR { 'Bruce' }
      }
  
  If the return value of the subroutine is used in any other way than as
  a string, an exception will be thrown.
  
  You can still specify handlers for more than a single kind of context
  when using C<STRICT>:
  
      sub get_name {
          return STRICT
              STR  { 'Bruce' }
              BOOL { 0 }
      }
  
  ...but these will still be the only contexts in which the return value
  can be used:
  
      my $n = get_name() ? 1 : 2;  # Okay because BOOL handler specified
  
      my $n = 'Dr' . get_name();   # Okay because STR handler specified
  
      my $n = 1 + get_name();      # Exception thrown because no NUM handler
  
  In other words, C<STRICT> allows you to impose strict type checking on
  your contextual return value.
  
  
  =head2 Deferring handlers
  
  Because the various handlers form a hierarchy, it's possible to
  implement more specific handlers by falling back on ("deferring to")
  more general ones. For example, L<a C<PUREBOOL> handler|"Boolean vs Pure
  Boolean contexts"> is almost always identical in its basic behaviour to
  the corresponding C<BOOL> handler, except that it adds some side-effect.
  For example:
  
      return
          PUREBOOL { $_ = $return_val; defined $return_val && $return_val > 0 }
              BOOL {                   defined $return_val && $return_val > 0 }
            SCALAR {                   $return_val;                           }
  
  So Contextual::Return allows you to have a handler perform some action
  and then defer to a more general handler to supply the actual return
  value. To fall back to a more general case in this way, you simply write:
  
      next handler;
  
  at the end of the handler in question, after which Contextual::Return
  will find the next-most-specific handler and execute it as well. So the
  previous example, could be re-written:
  
      return
          PUREBOOL { $_ = $return_val; next handler;        }
              BOOL { defined $return_val && $return_val > 0 }
            SCALAR { $return_val;                           }
  
  Note that I<any> specific handler can defer to a more general one in
  this same way. For example, you could provide consistent and
  maintainable type-checking for a subroutine that returns references by
  providing C<ARRAYREF>, C<HASHREF>, and C<SCALARREF> handlers that all
  defer to a generic C<REF> handler, like so:
  
      my $retval = _get_ref();
  
      return
         SCALARREF { croak 'Type mismatch' if ref($retval) ne 'SCALAR';
                     next handler;
                   }
          ARRAYREF { croak 'Type mismatch' if ref($retval) ne 'ARRAY';
                     next handler;
                   }
           HASHREF { croak 'Type mismatch' if ref($retval) ne 'HASH';
                     next handler;
                   }
               REF { $retval }
  
  If, at a later time, the process of returning a reference became more complex,
  only the C<REF> handler would have to be updated.
  
  
  =head2 Nested handlers
  
  Another way of factoring out return behaviour is to nest more specific
  handlers inside more general ones. For instance, in the final example given in
  L<"Boolean vs Pure Boolean contexts">:
  
      sub get_data {
          my $data;
          return
              PUREBOOL {        _check_for_but_dont_get_data();   }
                  BOOL { defined( $data ||= _go_and_get_data() ); }
                   REF {          $data ||= _go_and_get_data();   }
      }
  
  you could factor out the repeated calls to C<_go_and_get_data()> like so:
  
      sub get_data {
          return
              PUREBOOL { _check_for_but_dont_get_data(); }
               DEFAULT {
                  my $data = _go_and_get_data();
  
                  BOOL { defined $data; }
                   REF {         $data; }
               }
      }
  
  Here, the C<DEFAULT> handler deals with every return context except pure
  boolean. Within that C<DEFAULT> handler, the data is first retrieved,
  and then two "sub-handlers" deal with the ordinary boolean and
  referential contexts.
  
  Typically nested handlers are used in precisely this way: to optimize
  for inexpensive special cases (such as pure boolean or integer or void
  return contexts) and only do extra work for those other cases that
  require it.
  
  
  =head2 Failure contexts
  
  Two of the most common ways to specify that a subroutine has failed
  are to return a false value, or to throw an exception. The
  Contextual::Return module provides a mechanism that allows the
  subroutine writer to support I<both> of these mechanisms at the
  same time, by using the C<FAIL> specifier.
  
  A return statement of the form:
  
      return FAIL;
  
  causes the surrounding subroutine to return C<undef> (i.e. false) in
  boolean contexts, and to throw an exception in any other context. For example:
  
      use Contextual::Return;
  
      sub get_next_val {
          my $next_val = <>;
          return FAIL if !defined $next_val;
          chomp $next_val;
          return $next_val;
      }
  
  If the C<return FAIL> statement is executed, it will either return false in a
  boolean context:
  
      if (my $val = get_next_val()) {      # returns undef if no next val
          print "[$val]\n";
      }
  
  or else throw an exception if the return value is used in any
  other context:
  
      print get_next_val();       # throws exception if no next val
  
      my $next_val = get_next_val();
      print "[$next_val]\n";      # throws exception if no next val
  
  
  The exception that is thrown is of the form:
  
      Call to main::get_next_val() failed at demo.pl line 42
  
  but you can change that message by providing a block to the C<FAIL>, like so:
  
      return FAIL { "No more data" } if !defined $next_val;
  
  in which case, the final value of the block becomes the exception message:
  
      No more data at demo.pl line 42
  
  A failure value can be interrogated for its error message, by calling its
  C<error()> method, like so:
  
      my $val = get_next_val();
      if ($val) {
          print "[$val]\n";
      }
      else {
          print $val->error, "\n";
      }
  
  
  =head2 Configurable failure contexts
  
  The default C<FAIL> behaviour--false in boolean context, fatal in all
  others--works well in most situations, but violates the Platinum Rule ("Do
  unto others as I<they> would have done unto them").
  
  So it may be user-friendlier if the user of a module is allowed decide how
  the module's subroutines should behave on failure. For example, one user
  might prefer that failing subs always return undef; another might prefer
  that they always throw an exception; a third might prefer that they
  always log the problem and return a special Failure object; whilst a
  fourth user might want to get back C<0> in scalar contexts, an empty list
  in list contexts, and an exception everywhere else.
  
  You could create a module that allows the user to specify all these
  alternatives, like so:
  
      package MyModule;
      use Contextual::Return;
      use Log::StdLog;
  
      sub import {
          my ($package, @args) = @_;
  
          Contextual::Return::FAIL_WITH {
              ':false' => sub { return undef },
              ':fatal' => sub { croak @_       },
              ':filed' => sub {
                              print STDLOG 'Sub ', (caller 1)[3], ' failed';
                              return Failure->new();
                          },
              ':fussy' => sub {
                              SCALAR  { undef      }
                              LIST    { ()         }
                              DEFAULT { croak @_ }
                          },
          }, @args;
      }
  
  This configures Contextual::Return so that, instead of the usual
  false-or-fatal semantics, every C<return FAIL> within MyModule's namespace is
  implemented by one of the four subroutines specified in the hash that was
  passed to C<FAIL_WITH>.
  
  Which of those four subs implements the C<FAIL> is determined by the
  arguments passed after the hash (i.e. by the contents of C<@args>).
  C<FAIL_WITH> walks through that list of arguments and compares
  them against the keys of the hash. If a key matches an argument, the
  corresponding value is used as the implementation of C<FAIL>. Note that,
  if subsequent arguments also match a key, their subroutine overrides the
  previously installed implementation, so only the final override has any
  effect. Contextual::Return generates warnings when multiple overrides are
  specified.
  
  All of which mean that, if a user loaded the MyModule module like this:
  
      use MyModule qw( :fatal other args here );
  
  then every C<FAIL> within MyModule would be reconfigured to throw an exception
  in all circumstances, since the presence of the C<':fatal'> in the argument
  list will cause C<FAIL_WITH> to select the hash entry whose key is C<':fatal'>.
  
  On the other hand, if they loaded the module:
  
      use MyModule qw( :fussy other args here );
  
  then each C<FAIL> within MyModule would return undef or empty list or throw an
  exception, depending on context, since that's what the subroutine whose key is
  C<':fussy'> does.
  
  Many people prefer module interfaces with a C<< I<flag> => I<value> >>
  format, and C<FAIL_WITH> supports this too. For example, if you
  wanted your module to take a C<-fail> flag, whose associated value could
  be any of C<"undefined">, C<"exception">, C<"logged">, or C<"context">,
  then you could implement that simply by specifying the flag as the first
  argument (i.e. I<before> the hash) like so:
  
      sub import {
          my $package = shift;
  
          Contextual::Return::FAIL_WITH -fail => {
              'undefined' => sub { return undef },
              'exception' => sub { croak @_ },
              'logged'    => sub {
                              print STDLOG 'Sub ', (caller 1)[3], ' failed';
                              return Failure->new();
                          },
              'context' => sub {
                              SCALAR  { undef      }
                              LIST    { ()         }
                              DEFAULT { croak @_ }
                          },
          }, @_;
  
  and then load the module:
  
      use MyModule qw( other args here ), -fail=>'undefined';
  
  or:
  
      use MyModule qw( other args here ), -fail=>'exception';
  
  In this case, C<FAIL_WITH> scans the argument list for a pair of values: its
  flag string, followed by some other selector value. Then it looks up the
  selector value in the hash, and installs the corresponding subroutine as its
  local C<FAIL> handler.
  
  If this "flagged" interface is used, the user of the module can also
  specify their own handler directly, by passing a subroutine reference as
  the selector value instead of a string:
  
      use MyModule qw( other args here ), -fail=>sub{ die 'horribly'};
  
  If this last example were used, any call to C<FAIL> within MyModule
  would invoke the specified anonymous subroutine (and hence throw a
  'horribly' exception).
  
  Note that, any overriding of a C<FAIL> handler is specific to the
  namespace and file from which the subroutine that calls C<FAIL_WITH> is
  itself called. Since C<FAIL_WITH> is designed to be called from within a
  module's C<import()> subroutine, that generally means that the C<FAIL>s
  within a given module X are only overridden for the current namespace
  within the particular file from module X is loaded. This means that two
  separate pieces of code (in separate files or separate namespaces) can
  each independently override a module's C<FAIL> behaviour, without
  interfering with each other.
  
  =head2 Lvalue contexts
  
  Recent versions of Perl offer (limited) support for lvalue subroutines:
  subroutines that return a modifiable variable, rather than a simple constant
  value.
  
  Contextual::Return can make it easier to create such subroutines, within the
  limitations imposed by Perl itself. The limitations that Perl places on lvalue
  subs are:
  
  =over
  
  =item 1.
  
  The subroutine must be declared with an C<:lvalue> attribute:
  
      sub foo :lvalue {...}
  
  =item 2.
  
  The subroutine must not return via an explicit C<return>. Instead, the
  last statement must evaluate to a variable, or must be a call to another
  lvalue subroutine call.
  
      my ($foo, $baz);
  
      sub foo :lvalue {
          $foo;               # last statement evals to a var
      }
  
      sub bar :lvalue {
          foo();              # last statement is lvalue sub call
      }
  
      sub baz :lvalue {
          my ($arg) = @_;
  
          $arg > 0            # last statement evals...
              ? $baz          # ...to a var
              : bar();        # ...or to an lvalue sub call
      }
  
  =back
  
  Thereafter, any call to the lvalue subroutine produces a result that can be
  assigned to:
  
      baz(0) = 42;            # same as: $baz = 42
  
      baz(1) = 84;            # same as:                  bar() = 84
                              #  which is the same as:    foo() = 84
                              #   which is the same as:   $foo  = 84
  
  Ultimately, every lvalue subroutine must return a scalar variable, which
  is then used as the lvalue of the assignment (or whatever other lvalue
  operation is applied to the subroutine call). Unfortunately, because the
  subroutine has to return this variable I<before> the assignment
  can take place, there is no way that a normal lvalue subroutine can
  get access to the value that will eventually be assigned to its
  return value.
  
  This is occasionally annoying, so the Contextual::Return module offers
  a solution: in addition to all the context blocks described above, it
  provides three special contextual return blocks specifically for use in
  lvalue subroutines: C<LVALUE>, C<RVALUE>, and C<NVALUE>.
  
  Using these blocks you can specify what happens when an lvalue
  subroutine is used in lvalue and non-lvalue (rvalue) context. For
  example:
  
      my $verbosity_level = 1;
  
      # Verbosity values must be between 0 and 5...
      sub verbosity :lvalue {
          LVALUE { $verbosity_level = max(0, min($_, 5)) }
          RVALUE { $verbosity_level                      }
      }
  
  The C<LVALUE> block is executed whenever C<verbosity> is called as an lvalue:
  
      verbosity() = 7;
  
  The block has access to the value being assigned, which is passed to it
  as C<$_>. So, in the above example, the assigned value of 7 would be
  aliased to C<$_> within the C<LVALUE> block, would be reduced to 5 by the
  "min-of-max" expression, and then assigned to C<$verbosity_level>.
  
  (If you need to access the caller's C<$_>, it's also still available:
  as C<$CALLER::_>.)
  
  When the subroutine isn't used as an lvalue:
  
      print verbosity();
  
  the C<RVALUE> block is executed instead and its final value returned.
  Within an C<RVALUE> block you can use any of the other features of
  Contextual::Return. For example:
  
      sub verbosity :lvalue {
          LVALUE { $verbosity_level = int max(0, min($_, 5)) }
          RVALUE {
              NUM  { $verbosity_level               }
              STR  { $description[$verbosity_level] }
              BOOL { $verbosity_level > 2           }
          }
      }
  
  but the context sequence must be nested inside an C<RVALUE> block.
  
  You can also specify what an lvalue subroutine should do when it is used
  neither as an lvalue nor as an rvalue (i.e. in void context), by using an
  C<NVALUE> block:
  
      sub verbosity :lvalue {
          my ($level) = @_;
  
          NVALUE { $verbosity_level = int max(0, min($level, 5)) }
          LVALUE { $verbosity_level = int max(0, min($_,     5)) }
          RVALUE {
              NUM  { $verbosity_level               }
              STR  { $description[$verbosity_level] }
              BOOL { $verbosity_level > 2           }
          }
      }
  
  In this example, a call to C<verbosity()> in void context sets the verbosity
  level to whatever argument is passed to the subroutine:
  
      verbosity(1);
  
  Note that you I<cannot> get the same effect by nesting a C<VOID> block
  within an C<RVALUE> block:
  
          LVALUE { $verbosity_level = int max(0, min($_, 5)) }
          RVALUE {
              NUM  { $verbosity_level               }
              STR  { $description[$verbosity_level] }
              BOOL { $verbosity_level > 2           }
              VOID { $verbosity_level = $level      }  # Wrong!
          }
  
  That's because, in a void context the return value is never evaluated,
  so it is never treated as an rvalue, which means the C<RVALUE> block
  never executes.
  
  
  =head2 Result blocks
  
  Occasionally, it's convenient to calculate a return value I<before> the
  end of a contextual return block. For example, you may need to clean up
  external resources involved in the calculation after it's complete.
  Typically, this requirement produces a slightly awkward code sequence
  like this:
  
      return
          VALUE {
              $db->start_work();
              my $result = $db->retrieve_query($query);
              $db->commit();
              $result;
          }
  
  Such code sequences become considerably more awkward when you want
  the return value to be context sensitive, in which case you have to
  write either:
  
      return
          LIST {
              $db->start_work();
              my @result = $db->retrieve_query($query);
              $db->commit();
              @result;
          }
          SCALAR {
              $db->start_work();
              my $result = $db->retrieve_query($query);
              $db->commit();
              $result;
          }
  
  or, worse:
  
      return
          VALUE {
              $db->start_work();
              my $result = LIST ? [$db->retrieve_query($query)]
                                :  $db->retrieve_query($query);
              $db->commit();
              LIST ? @{$result} : $result;
          }
  
  To avoid these infelicities, Contextual::Return provides a second way of
  setting the result of a context block; a way that doesn't require that the
  result be the last statement in the block:
  
      return
          LIST {
              $db->start_work();
              RESULT { $db->retrieve_query($query) };
              $db->commit();
          }
          SCALAR {
              $db->start_work();
              RESULT { $db->retrieve_query($query) };
              $db->commit();
          }
  
  The presence of a C<RESULT> block inside a contextual return block causes
  that block to return the value of the final statement of the C<RESULT>
  block as the handler's return value, rather than returning the value of
  the handler's own final statement. In other words, the presence of a C<RESULT>
  block overrides the normal return value of a context handler.
  
  Better still, the C<RESULT> block always evaluates its final statement
  in the same context as the surrounding C<return>, so you can just write:
  
      return
          VALUE {
              $db->start_work();
              RESULT { $db->retrieve_query($query) };
              $db->commit();
          }
  
  and the C<retrieve_query()> method will be called in the appropriate context
  in all cases.
  
  A C<RESULT> block can appear anywhere inside any contextual return
  block, but may not be used outside a context block. That is, this
  is an error:
  
      if ($db->closed) {
          RESULT { undef }; # Error: not in a context block
      }
      return
          VALUE {
              $db->start_work();
              RESULT { $db->retrieve_query($query) };
              $db->commit();
          }
  
  
  =head2 Post-handler clean-up
  
  If a subroutine uses an external resource, it's often necessary to close
  or clean-up that resource after the subroutine ends...regardless of
  whether the subroutine exits normally or via an exception.
  
  Typically, this is done by encapsulating the resource in a lexically
  scoped object whose destructor does the clean-up. However, if the clean-up
  doesn't involve deallocation of an object (as in the C<< $db->commit() >>
  example in the previous section), it can be annoying to have to create a
  class and allocate a container object, merely to mediate the clean-up.
  
  To make it easier to manage such resources, Contextual::Return supplies
  a special labelled block: the C<RECOVER> block. If a C<RECOVER> block is
  specified as part of a contextual return sequence, that block is
  executed after any context handler, even if the context handler exits
  via an exception.
  
  So, for example, you could implement a simple commit-or-revert
  policy like so:
  
      return
          LIST    { $db->retrieve_all($query)  }
          SCALAR  { $db->retrieve_next($query) }
          RECOVER {
              if ($@) {
                  $db->revert();
              }
              else {
                  $db->commit();
              }
          }
  
  The presence of a C<RECOVER> block also intercepts all exceptions thrown
  in any other context block in the same contextual return sequence. Any
  such exception is passed into the C<RECOVER> block in the usual manner:
  via the C<$@> variable. The exception may be rethrown out of the
  C<RECOVER> block by calling C<die>:
  
      return
          LIST    { $db->retrieve_all($query) }
          DEFAULT { croak "Invalid call (not in list context)" }
          RECOVER {
              die $@ if $@;    # Propagate any exception
              $db->commit();   # Otherwise commit the changes
          }
  
  A C<RECOVER> block can also access or replace the returned value, by
  invoking a C<RESULT> block. For example:
  
      return
          LIST    { attempt_to_generate_list_for(@_)  }
          SCALAR  { attempt_to_generate_count_for(@_) }
          RECOVER {
              if ($@) {                # On any exception...
                  warn "Replacing return value. Previously: ", RESULT;
                  RESULT { undef }     # ...return undef
              }
          }
  
  
  =head2 Post-return clean-up
  
  Occasionally it's necessary to defer the clean-up of resources until
  after the return value has been used. Once again, this is usually
  done by returning an object with a suitable destructor.
  
  Using Contextual::Return you can get the same effect, by providing a
  C<CLEANUP> block in the contextual return sequence:
  
      return
          LIST    { $db->retrieve_all($query)  }
          SCALAR  { $db->retrieve_next($query) }
          CLEANUP { $db->commit()              }
  
  In this example, the C<commit> method call is only performed after the
  return value has been used by the caller. Note that this is quite
  different from using a C<RECOVER> block, which is called as the
  subroutine returns its value; a C<CLEANUP> is called when the returned
  value is garbage collected.
  
  A C<CLEANUP> block is useful for controlling resources allocated to support an
  C<ACTIVE> return value. For example:
  
      my %file;
  
      # Return an active value that is always the next line from a file...
      sub readline_from {
          my ($file_name) = @_;
  
          # Open the file, if not already open...
          if (!$file{$file_name}) {
              open $file{$file_name}{handle}, '<', $file_name;
          }
  
          # Track how many active return values are using this file...
          $file{$file_name}{count}++;
  
          return ACTIVE
              # Evaluating the return value returns the next line...
              VALUE   { readline $file{$file_name}{handle} }
  
              # Once the active value is finished with, clean up the filehandle...
              CLEANUP {
                  delete $file{$file_name}
                      if --$file{$file_name}{count} == 0;
              }
      }
  
  
  =head2 Debugging contextual return values
  
  Contextual return values are implemented as opaque objects (using the
  "inside-out" technique). This means that passing such values to
  Data::Dumper produces an uninformative output like:
  
      $VAR1 = bless( do{\(my $o = undef)}, 'Contextual::Return::Value' );
  
  So the module provides two methods that allow contextual return values
  to be correctly reported: either directly, or when dumped by
  Data::Dumper.
  
  To dump a contextual return value directly, call the module's C<DUMP()>
  method explicitly and print the result:
  
      print $crv->Contextual::Return::DUMP();
  
  This produces an output something like:
  
      [
       { FROM       => 'main::foo'                                       },
       { NO_HANDLER => [ 'VOID', 'CODEREF', 'HASHREF', 'GLOBREF' ]       },
       { FALLBACKS  => [ 'VALUE' ]                                       },
       { LIST       => [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]                 },
       { STR        => '<<<Throws exception: Died at demo.pl line 7.>>>' },
       { NUM        => 42                                                },
       { BOOL       => -1                                                },
       { SCALARREF  => '<<<self-reference>>>'                            },
       { ARRAYREF   => [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]                 },
      ];
  
  The C<FROM> hash entry names the subroutine that produced the return
  value. The C<NO_HANDLER> hash entry lists those contexts for which no
  handler was defined (and which would therefore normally produce "can't
  call" exceptions such as: C<"Can't call main::foo in VOID context">).
  The C<FALLBACKS> hash entry lists any "generic" contexts such as
  C<VALUE>, C<NONVOID>, C<REF>, C<DEFAULT>, etc. that the contextual
  return value can also handle. After these, all the remaining hash
  entries are actual contexts in which the return value could successfully
  be evaluated, and the value it would produce in each of those contexts.
  
  The Data::Dumper module also has a mechanism by which you can tell it
  how to produce a similar listing automatically whenever a contextual
  return value is passed to its C<Dumper> method. Data::Dumper allows you
  to register a "freezer" method, that is called prior to dumping, and
  which can be used to adapt an opaque object to make it dumpable.
  Contextual::Return provides just such a method
  (C<Contextual::Return::FREEZE()>) for you to register, like so:
  
      use Data::Dumper 'Dumper';
  
      local $Data::Dumper::Freezer = 'Contextual::Return::FREEZE';
  
      print Dumper $foo;
  
  The output is then precisely the same as C<Contextual::Return::DUMP()>
  would produce.
  
  Note that, with both of the above dumping mechanisms, it is essential to use
  the full name of the method. That is:
  
      print $crv->Contextual::Return::DUMP();
  
  rather than:
  
      print $crv->DUMP();
  
  This is because the shorter version is interpreted as calling the
  C<DUMP()> method on the object returned by the return value's C<OBJREF>
  context block (see L<"Scalar reference contexts">)
  
  For the same reason, you must write:
  
      local $Data::Dumper::Freezer = 'Contextual::Return::FREEZE';
  
  not:
  
      local $Data::Dumper::Freezer = 'FREEZE';
  
  
  =head2 Namespace controls
  
  By default the module exports a large number of return context markers:
  
      DEFAULT    REF          LAZY
      VOID       SCALARREF    FIXED
      NONVOID    ARRAYREF     ACTIVE
      LIST       CODEREF      RESULT
      SCALAR     HASHREF      RECOVER
      VALUE      GLOBREF      CLEANUP
      STR        OBJREF       RVALUE
      NUM        METHOD       LVALUE
      BOOL                    NVALUE
      PUREBOOL
  
  These are exported as subroutines, and so can conflict with existing
  subroutines in your namespace, or with subroutines imported from other
  modules.
  
  Contextual::Return allows you to control which contextual return blocks are
  exported into any namespace that uses the module. It also allows you to rename
  blocks to avoid namespace conflicts with existing subroutines.
  
  Both these features are controlled by passing arguments to the C<use>
  statement that loads the module as follows:
  
  =over
  
  =item *
  
  Any string passed as an argument to C<use Contextual::Return>,
  exports only the block name it specifies;
  
  =item *
  
  Any regex passed as an argument to C<use Contextual::Return>
  exports every block name it matches;
  
  =item *
  
  Any array ref (recursively) exports each of its elements
  
  =item *
  
  Any string that appears immediately after one of the above three specifiers,
  and which is not itself a block name, renames the handlers exported by that
  preceding specifier by filtering each handler name through C<sprintf()>
  
  =back
  
  That is, you can specify handlers to be exported by exact name (as a string),
  by general pattern (as a regex), or collectively (in an array). And after any
  of these export specifications, you can append a template in which any C<'%s'>
  will be replaced by the original name of the handler. For example:
  
      # Selectively export specific sets of handlers...
      use Contextual::Return  qr/[NLR]VALUE/;
      use Contextual::Return  qr/.*REF/;
  
      # Selective export specific sets and add a suffix to each...
      use Contextual::Return  qr/[NLR]VALUE/ => '%s_CONTEXT';
  
      # Selective export specific sets and add a prefix to each...
      use Contextual::Return  qr/.*REF/ => 'CR_%s';
  
      # Export a list of handlers...
      use Contextual::Return    'NUM', 'STR', 'BOOL' ;
      use Contextual::Return qw< NUM    STR    BOOL >;
      use Contextual::Return   ['NUM', 'STR', 'BOOL'];
  
      # Export a list of handlers, renaming them individually...
      use Contextual::Return  NUM => 'NUMERIC', STR => 'TEXT', BOOL => 'CR_%s';
  
      # Export a list of handlers, renaming them collectively...
      use Contextual::Return  ['NUM', 'STR', 'BOOL'] => '%s_CONTEXT';
  
      # Mixed exports and renames...
      use Contextual::Return (
          STR => 'TEXT',
          ['NUM', 'BOOL'] => 'CR_%s',
          ['LIST', 'SCALAR', 'VOID', qr/^[NLR]VALUE/] => '%s_CONTEXT',
      );
  
  
  
  =head1 INTERFACE
  
  =head2 Context tests
  
  =over
  
  =item C<< LIST() >>
  
  Returns true if the current subroutine was called in list context.
  A cleaner way of writing: C<< wantarray() >>
  
  =item C<< SCALAR() >>
  
  Returns true if the current subroutine was called in scalar context.
  A cleaner way of writing: C<< defined wantarray() && ! wantarray() >>
  
  
  =item C<< VOID() >>
  
  Returns true if the current subroutine was called in void context.
  A cleaner way of writing: C<< !defined wantarray() >>
  
  =item C<< NONVOID() >>
  
  Returns true if the current subroutine was called in list or scalar context.
  A cleaner way of writing: C<< defined wantarray() >>
  
  =back
  
  =head2 Standard contexts
  
  =over
  
  =item C<< LIST {...} >>
  
  The block specifies what the context sequence should evaluate to when
  called in list context.
  
  =item C<< SCALAR {...} >>
  
  The block specifies what the context sequence should evaluate to in
  scalar contexts, unless some more-specific specifier scalar context specifier
  (see below) also occurs in the same context sequence.
  
  =item C<< VOID {...} >>
  
  The block specifies what the context sequence should do when
  called in void context.
  
  =back
  
  =head2 Scalar value contexts
  
  =over
  
  =item C<< BOOL {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a boolean value.
  
  =item C<< NUM {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a numeric value.
  
  =item C<< STR {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a string value.
  
  =item C<< LAZY {...} >>
  
  Another name for C<SCALAR {...}>. Usefully self-documenting when the primary
  purpose of the contextual return is to defer evaluation of the return value
  until it's actually required.
  
  =back
  
  =head2 Scalar reference contexts
  
  =over
  
  =item C<< SCALARREF {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a reference to a scalar.
  
  =item C<< ARRAYREF {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a reference to an array.
  
  =item C<< HASHREF {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a reference to a hash.
  
  Note that a common error here is to write:
  
  HASHREF { a=>1, b=>2, c=>3 }
  
  The curly braces there are a block, not a hash constructor, so the block
  doesn't return a hash reference and the interpreter throws an exception.
  What's needed is:
  
  HASHREF { {a=>1, b=>2, c=>3} }
  
  in which the inner braces I<are> a hash constructor.
  
  =item C<< CODEREF {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a reference to a subroutine.
  
  =item C<< GLOBREF {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a reference to a typeglob.
  
  =item C<< OBJREF {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a reference to an object.
  
  =item C<< METHOD {...} >>
  
  The block can be used to specify particular handlers for specific method calls
  when the return value is treated as an object reference.
  It should return a list of methodname/methodbody pairs. Each method name can
  be specified as a string, a regex, or an array of strings or regexes. The
  method bodies must be specified as subroutine references (usually anonymous
  subs). The first method name that matches the actual method call selects the
  corresponding handler, which is then called.
  
  =back
  
  =head2 Generic contexts
  
  =over
  
  =item C<< VALUE {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a non-referential value (as a boolean, numeric, string,
  scalar, or list). Only used if there is no more-specific value context
  specifier in the context sequence.
  
  =item C<< REF {...} >>
  
  The block specifies what the context sequence should evaluate to when
  treated as a reference of any kind. Only used if there is no
  more-specific referential context specifier in the context sequence.
  
  =item C<< NONVOID {...} >>
  
  The block specifies what the context sequence should evaluate to when
  used in a non-void context of any kind. Only used if there is no
  more-specific context specifier in the context sequence.
  
  =item C<< DEFAULT {...} >>
  
  The block specifies what the context sequence should evaluate to when
  used in a void or non-void context of any kind. Only used if there is no
  more-specific context specifier in the context sequence.
  
  =back
  
  =head2 Failure context
  
  =over
  
  =item C<< FAIL >>
  
  This block is executed unconditionally and is used to indicate failure. In a
  Boolean context it return false. In all other contexts it throws an exception
  consisting of the final evaluated value of the block.
  
  That is, using C<FAIL>:
  
  return
  FAIL { "Could not defenestrate the widget" }
  
  is exactly equivalent to writing:
  
  return
  BOOL { 0 }
  DEFAULT { croak "Could not defenestrate the widget" }
  
  except that the reporting of errors is a little smarter under C<FAIL>.
  
  If C<FAIL> is called without specifying a block:
  
  return FAIL;
  
  it is equivalent to:
  
  return FAIL { croak "Call to <subname> failed" }
  
  (where C<< <subname> >> is replaced with the name of the surrounding
  subroutine).
  
  Note that, because C<FAIL> implicitly covers every possible return
  context, it cannot be chained with other context specifiers.
  
  =item C<< Contextual::Return::FAIL_WITH >>
  
  This subroutine is not exported, but may be called directly to reconfigure
  C<FAIL> behaviour in the caller's namespace.
  
  The subroutine is called with an optional string (the I<flag>), followed
  by a mandatory hash reference (the I<configurations hash>), followed by a
  list of zero-or-more strings (the I<selector list>). The values of the
  configurations hash must all be subroutine references.
  
  If the optional flag is specified, C<FAIL_WITH> searches the selector
  list looking for that string, then uses the I<following> item in the
  selector list as its I<selector value>. If that selector value is a
  string, C<FAIL_WITH> looks up that key in the hash, and installs the
  corresponding subroutine as the namespace's C<FAIL> handler (an
  exception is thrown if the selector string is not a valid key of the
  configurations hash). If the selector value is a subroutine reference,
  C<FAIL_WITH> installs that subroutine as the C<FAIL> handler.
  
  If the optional flag is I<not> specified, C<FAIL_WITH> searches the
  entire selector list looking for the last element that matches any
  key in the configurations hash. It then looks up that key in the
  hash, and installs the corresponding subroutine as the namespace's
  C<FAIL> handler.
  
  See L<Configurable failure contexts> for examples of using this feature.
  
  =back
  
  =head2 Lvalue contexts
  
  =over
  
  =item C<< LVALUE >>
  
  This block is executed when the result of an C<:lvalue> subroutine is assigned
  to. The assigned value is passed to the block as C<$_>. To access the caller's
  C<$_> value, use C<$CALLER::_>.
  
  =item C<< RVALUE >>
  
  This block is executed when the result of an C<:lvalue> subroutine is used
  as an rvalue. The final value that is evaluated in the block becomes the
  rvalue.
  
  =item C<< NVALUE >>
  
  This block is executed when an C<:lvalue> subroutine is evaluated in void
  context.
  
  =back
  
  =head2 Explicit result blocks
  
  =over
  
  =item C<< RESULT >>
  
  This block may only appear inside a context handler block. It causes the
  surrounding handler to return the final value of the C<RESULT>'s block,
  rather than the final value of the handler's own block. This override occurs
  regardless of the location to the C<RESULT> block within the handler.
  
  If called without a trailing C<{...}>, it simply returns the current result
  value in scalar contexts, or the list of result values in list context.
  
  =back
  
  =head2 Recovery blocks
  
  =over
  
  =item C<< RECOVER >>
  
  If present in a context return sequence, this block grabs control after
  any context handler returns or exits via an exception. If an exception
  was thrown it is passed to the C<RECOVER> block via the C<$@> variable.
  
  =back
  
  =head2 Clean-up blocks
  
  =over
  
  =item C<< CLEANUP >>
  
  If present in a context return sequence, this block grabs control when
  a return value is garbage collected.
  
  =back
  
  
  =head2 Modifiers
  
  =over
  
  =item C<< FIXED >>
  
  This specifies that the scalar value will only be evaluated once, the
  first time it is used, and that the value will then morph into that
  evaluated value.
  
  =item C<< ACTIVE >>
  
  This specifies that the scalar value's originating block will be re-
  evaluated every time the return value is used.
  
  =back
  
  =head2 Debugging support
  
  =over
  
  =item C<< $crv->Contextual::Return::DUMP() >>
  
  Return a dumpable representation of the return value in all viable contexts.
  
  =item C<< local $Data::Dumper::Freezer = 'Contextual::Return::FREEZE'; >>
  
  =item C<< local $Data::Dumper::Freezer = \&Contextual::Return::FREEZE; >>
  
  Configure Data::Dumper to correctly dump a representation of the
  contextual return value.
  
  =back
  
  
  =head1 DIAGNOSTICS
  
  =over
  
  =item C<Can't use %s as export specifier>
  
  In your C<use Contextual::Return> statement you specified something (such as a
  hash or coderef) that can't be used to select what the module exports. Make
  sure the list of selectors includes only strings, regexes, or references to
  arrays of strings or regexes.
  
  
  =item C<use Contextual::Return qr{%s} didn't export anything>
  
  In your C<use Contextual::Return> statement you specified a regex to select
  which handlers to support, but the regex didn't select any handlers. Check
  that the regex you're using actually does match at least one of the names of
  the modules many handlers.
  
  
  =item C<Can't export %s: no such handler>
  
  In your C<use Contextual::Return> statement you specified a string as the
  name of a context handler to be exported, but the module doesn't export a
  handler of that name. Check the spelling for the requested export.
  
  
  =item C<Can't call %s in a %s context>
  
  =item C<Can't use return value of %s in a %s context>
  
  The subroutine you called uses a contextual return, but doesn't specify what
  to return in the particular context in which you called it. You either need to
  change the context in which you're calling the subroutine, or else add a
  context block corresponding to the offending context (or perhaps a
  C<DEFAULT {...}> block).
  
  
  =item C<Can't call bare %s {...} in %s context>
  
  You specified a handler (such as C<VOID {...}> or C<LIST {...}>)
  outside any subroutine, and in a context that it
  can't handle. Did you mean to place the handler outside of a subroutine?
  If so, then you need to put it in a context it can actually handle.
  Otherwise, perhaps you need to replace the trailing block with parens
  (that is: C<VOID()> or C<LIST()>).
  
  
  =item C<Call to %s at %s didn't return a %s reference">
  
  You called the subroutine in a context that expected to get back a
  reference of some kind but the subroutine didn't specify the
  corresponding C<SCALARREF>, C<ARRAYREF>, C<HASHREF>, C<CODEREF>,
  C<GLOBREF>, or generic C<REF>, C<NONVOID>, or C<DEFAULT> handlers.
  You need to specify the appropriate one of these handlers in the subroutine.
  
  
  =item C<Can't call method '%s' on %s value returned by %s">
  
  You called the subroutine and then tried to call a method on the return
  value, but the subroutine returned a classname or object that doesn't
  have that method. This probably means that the subroutine didn't return
  the classname or object you expected. Or perhaps you need to specify
  an C<OBJREF {...}> context block.
  
  
  =item C<Can't install two %s handlers>
  
  You attempted to specify two context blocks of the same name in the same
  return context, which is ambiguous. For example:
  
      sub foo: lvalue {
          LVALUE { $foo = $_ }
          RVALUE { $foo }
          LVALUE { $foo = substr($_,1,10) }
      }
  
  or:
  
      sub bar {
          return
              BOOL { 0 }
              NUM  { 1 }
              STR  { "two" }
              BOOL { 1 };
      }
  
  Did you cut-and-paste wrongly, or mislabel one of the blocks?
  
  
  =item C<Expected a %s block after the %s block but found instead: %s>
  
  If you specify any of C<LVALUE>, C<RVALUE>, or C<NVALUE>, then you can only
  specify C<LVALUE>, C<RVALUE>, or C<NVALUE> blocks in the same return context.
  If you need to specify other contexts (like C<BOOL>, or C<STR>, or C<REF>,
  etc.), put them inside an C<RVALUE> block. See L<Lvalue contexts> for an
  example.
  
  
  =item C<Call to %s failed at %s>
  
  This is the default exception that a C<FAIL> throws in a non-scalar
  context. Which means that the subroutine you called has signalled
  failure by throwing an exception, and you didn't catch that exception.
  You should either put the call in an C<eval {...}> block or else call the
  subroutine in boolean context instead.
  
  
  =item C<Call to %s failed at %s. Attempted to use failure value at %s>
  
  This is the default exception that a C<FAIL> throws when a failure value
  is captured in a scalar variable and later used in a non-boolean
  context. That means that the subroutine you called must have failed, and
  you didn't check the return value for that failure, so when you tried to
  use that invalid value it killed your program. You should either put the
  original call in an C<eval {...}> or else test the return value in a
  boolean context and avoid using it if it's false.
  
  
  =item C<Usage: FAIL_WITH $flag_opt, \%selector, @args>
  
  The C<FAIL_WITH> subroutine expects an optional flag, followed by a reference
  to a configuration hash, followed by a list or selector arguments. You gave it
  something else. See L<Configurable Failure Contexts>.
  
  
  =item C<Selector values must be sub refs>
  
  You passed a configuration hash to C<FAIL_WITH> that specified non-
  subroutines as possible C<FAIL> handlers. Since non-subroutines can't
  possibly be handlers, maybe you forgot the C<sub> keyword somewhere?
  
  
  =item C<Invalid option: %s => %s>
  
  The C<FAIL_WITH> subroutine was passed a flag/selector pair, but the selector
  was not one of those allowed by the configuration hash.
  
  
  =item C<FAIL handler for package %s redefined>
  
  A warning that the C<FAIL> handler for a particular package was
  reconfigured more than once. Typically that's because the module was
  loaded in two places with difference configurations specified. You can't
  reasonably expect two different sets of behaviours from the one module within
  the one namespace.
  
  =back
  
  
  =head1 CONFIGURATION AND ENVIRONMENT
  
  Contextual::Return requires no configuration files or environment variables.
  
  
  =head1 DEPENDENCIES
  
  Requires version.pm and Want.pm.
  
  
  =head1 INCOMPATIBILITIES
  
  C<LVALUE>, C<RVALUE>, and C<NVALUE> do not work correctly under the Perl
  debugger. This seems to be because the debugger injects code to capture
  the return values from subroutines, which interferes destructively with
  the optional final arguments that allow C<LVALUE>, C<RVALUE>, and C<NVALUE>
  to cascade within a single return.
  
  
  =head1 BUGS AND LIMITATIONS
  
  No bugs have been reported.
  
  
  =head1 AUTHOR
  
  Damian Conway  C<< <DCONWAY@cpan.org> >>
  
  
  =head1 LICENCE AND COPYRIGHT
  
  Copyright (c) 2005-2011, Damian Conway C<< <DCONWAY@cpan.org> >>. All rights reserved.
  
  This module is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  
  =head1 DISCLAIMER OF WARRANTY
  
  BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
  PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
  EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
  ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
  YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
  NECESSARY SERVICING, REPAIR, OR CORRECTION.
  
  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
  LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
  OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
  THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
  FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
  SUCH DAMAGES.
CONTEXTUAL_RETURN

$fatpacked{"Contextual/Return/Failure.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CONTEXTUAL_RETURN_FAILURE';
  package Contextual::Return::Failure;
  our $VERSION = 0.000_003;
  
  use Contextual::Return;
  BEGIN { *_in_context = *Contextual::Return::_in_context }
  
  use warnings;
  use strict;
  
  my %handler_for;
  
  sub _FAIL_WITH {
      # Unpack and vet args...
      my $flag = shift;
      my $selector_ref;
      if (ref $flag eq 'HASH') {
          $selector_ref = $flag;
          $flag = undef;
      }
      else {
          $selector_ref = shift;
          die _in_context 'Usage: FAIL_WITH $flag_opt, \%selector, @args'
              if ref $selector_ref ne 'HASH';
      }
      die _in_context "Selector values must be sub refs"
          if grep {ref ne 'CODE'} values %{$selector_ref};
  
      # Search for handler sub;
      my $handler;
      if (defined $flag) {
          ARG:
          while (@_) {
              last ARG if shift(@_) eq $flag;
          }
          my $selector = shift @_;
          if (ref $selector eq 'CODE') {
              $handler = $selector;
              @_ = ();
          }
          else {
              @_ = $selector;
          }
      }
  
      SELECTION:
      for my $selection (reverse @_) {
          if (exists $selector_ref->{$selection}) {
              $handler = $selector_ref->{$selection};
              last SELECTION;
          }
          elsif ($flag) {
              die _in_context "Invalid option: $flag => $selection";
          }
      }
  
      # (Re)set handler...
      if ($handler) {
          my $caller_loc = join '|', (CORE::caller 1)[0,1];
          if (exists $handler_for{$caller_loc}) {
              warn _in_context "FAIL handler for package ", scalar CORE::caller, " redefined";
          }
          $handler_for{$caller_loc} = $handler;
      }
  };
  
  sub _FAIL (;&) {
      # Generate args...
      my $arg_generator_ref = shift;
      my @args;
      if ($arg_generator_ref) {
          package DB;
          ()=CORE::caller(1);
          @args = $arg_generator_ref->(@DB::args);
      }
  
      # Handle user-defined failure semantics...
      my $caller_loc = join '|', (CORE::caller 1)[0,1];
      if (exists $handler_for{$caller_loc} ) {
          # Fake out caller() and Carp...
          local $Contextual::Return::uplevel = 1;
  
          return $handler_for{$caller_loc}->(@args);
      }
  
      my $exception = @args == 1 ? $args[0]
                    : @args > 0  ? join(q{}, @args)
                    :              "Call to " . (CORE::caller 1)[3] . "() failed"
                    ;
  
      # Join message with croak() semantics, if string...
      if (!ref $exception) {
          $exception .= _in_context @_;
      }
  
  #    # Check for immediate failure...
  #    use Want qw( want );
  #    return 0 if want 'BOOL';
  #    die $exception if !want 'SCALAR';
  
      # Return a delayed failure object...
      return
          BOOL    { 0 }
          DEFAULT {
              if (ref $exception) {
                  my $message = "$exception";
                  $message =~ s/$/\n/;
                  die _in_context $message, "Attempted to use failure value";
              }
              else {
                  die _in_context $exception, "Attempted to use failure value";
              }
          }
          METHOD {
              error => sub { _in_context $exception }
          }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Contextual::Return::Failure - Utility module for Contextual::Return
  
  =head1 NOTE
  
  Contains no user serviceable parts. See L<Contextual::Return> instead.
  
  =head1 AUTHOR
  
  Damian Conway  C<< <DCONWAY@cpan.org> >>
  
  
  =head1 LICENCE AND COPYRIGHT
  
  Copyright (c) 2006, Damian Conway C<< <DCONWAY@cpan.org> >>. All rights reserved.
  
  This module is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  
  =head1 DISCLAIMER OF WARRANTY
  
  BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
  PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
  EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
  ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
  YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
  NECESSARY SERVICING, REPAIR, OR CORRECTION.
  
  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
  LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
  OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
  THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
  FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
  SUCH DAMAGES.
  
CONTEXTUAL_RETURN_FAILURE

$fatpacked{"File/Slurp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_SLURP';
  package File::Slurp;
  
  use strict;
  use warnings ;
  
  our $VERSION = '9999.32';
  $VERSION = eval $VERSION;
  
  use Carp ;
  use Exporter qw(import);
  use Fcntl qw( :DEFAULT ) ;
  use File::Basename ();
  use File::Spec;
  use File::Temp qw(tempfile);
  use IO::Handle ();
  use POSIX qw( :fcntl_h ) ;
  use Errno ;
  
  my @std_export = qw(
  	read_file
  	write_file
  	overwrite_file
  	append_file
  	read_dir
  ) ;
  
  my @edit_export = qw(
  	edit_file
  	edit_file_lines
  ) ;
  
  my @abbrev_export = qw(
  	rf
  	wf
  	ef
  	efl
  ) ;
  
  our @EXPORT_OK = (
  	@edit_export,
  	@abbrev_export,
  	qw(
  		slurp
  		prepend_file
  	),
  ) ;
  
  our %EXPORT_TAGS = (
  	'all'	=> [ @std_export, @edit_export, @abbrev_export, @EXPORT_OK ],
  	'edit'	=> [ @edit_export ],
  	'std'	=> [ @std_export ],
  	'abr'	=> [ @abbrev_export ],
  ) ;
  
  our @EXPORT = @std_export ;
  
  my $max_fast_slurp_size = 1024 * 100 ;
  
  my $is_win32 = $^O =~ /win32/i ;
  
  *slurp = \&read_file ;
  *rf = \&read_file ;
  
  sub read_file {
  	my $file_name = shift;
  	my $opts = (ref $_[0] eq 'HASH') ? shift : {@_};
  	# options we care about:
  	# array_ref binmode blk_size buf_ref chomp err_mode scalar_ref
  
  	# let's see if we have a stringified object before doing anything else
  	# We then only have to deal with when we are given a file handle/globref
  	if (ref($file_name)) {
  		my $ref_result = _check_ref($file_name, $opts);
  		if (ref($ref_result)) {
  			@_ = ($opts, $ref_result);
  			goto &_error;
  		}
  		$file_name = $ref_result if $ref_result;
  		# we have now stringified $file_name if possible. if it's still a ref
  		# then we probably have a file handle
  	}
  
  	my $fh;
  	if (ref($file_name)) {
  		$fh = $file_name;
  	}
  	else {
  		# to keep with the old ways, read in :raw by default
  		unless (open $fh, "<:raw", $file_name) {
  			@_ = ($opts, "read_file '$file_name' - open: $!");
  			goto &_error;
  		}
  		# even though we set raw, let binmode take place here (busted)
  		if (my $bm = $opts->{binmode}) {
  			binmode $fh, $bm;
  		}
  	}
  
  	# we are now sure to have an open file handle. Let's slurp it in the same
  	# way that File::Slurper does.
  	my $buf;
  	my $buf_ref = $opts->{buf_ref} || \$buf;
  	${$buf_ref} = '';
  	my $blk_size = $opts->{blk_size} || 1024 * 1024;
  	if (my $size = -f $fh && -s _) {
  		$blk_size = $size if $size < $blk_size;
  		my ($pos, $read) = 0;
  		do {
  			unless(defined($read = read $fh, ${$buf_ref}, $blk_size, $pos)) {
  				@_ = ($opts, "read_file '$file_name' - read: $!");
  				goto &_error;
  			}
  			$pos += $read;
  		} while ($read && $pos < $size);
  	}
  	else {
  		${$buf_ref} = do { local $/; <$fh> };
  	}
  	seek($fh, $opts->{_data_tell}, SEEK_SET) if $opts->{_is_data} && $opts->{_data_tell};
  
  	# line endings if we're on Windows
  	${$buf_ref} =~ s/\015\012/\012/g if ${$buf_ref} && $is_win32 && !$opts->{binmode};
  
  	# we now have a buffer filled with the file content. Figure out how to
  	# return it to the user
  	my $want_array = wantarray; # let's only ask for this once
  	if ($want_array || $opts->{array_ref}) {
  		use re 'taint';
  		my $sep = $/;
  		$sep = '\n\n+' if defined $sep && $sep eq '';
  		# split the buffered content into lines
  		my @lines = length(${$buf_ref}) ?
  			${$buf_ref} =~ /(.*?$sep|.+)/sg : ();
  		chomp @lines if $opts->{chomp};
  		return \@lines if $opts->{array_ref};
  		return @lines;
  	}
  	return $buf_ref if $opts->{scalar_ref};
  	# if the function was called in scalar context, return the contents
  	return ${$buf_ref} if defined $want_array;
  	# if we were called in void context, return nothing
  	return;
  }
  
  # errors in this sub are returned as scalar refs
  # a normal IO/GLOB handle is an empty return
  # an overloaded object returns its stringified as a scalarfilename
  
  sub _check_ref {
  
  	my( $handle, $opts ) = @_ ;
  
  # check if we are reading from a handle (GLOB or IO object)
  
  	if ( eval { $handle->isa( 'GLOB' ) || $handle->isa( 'IO' ) } ) {
  
  # we have a handle. deal with seeking to it if it is DATA
  
  		my $err = _seek_data_handle( $handle, $opts ) ;
  
  # return the error string if any
  
  		return \$err if $err ;
  
  # we have good handle
  		return ;
  	}
  
  	eval { require overload } ;
  
  # return an error if we can't load the overload pragma
  # or if the object isn't overloaded
  
  	return \"Bad handle '$handle' is not a GLOB or IO object or overloaded"
  		 if $@ || !overload::Overloaded( $handle ) ;
  
  # must be overloaded so return its stringified value
  
  	return "$handle" ;
  }
  
  sub _seek_data_handle {
  
  	my( $handle, $opts ) = @_ ;
  	# store some meta-data about the __DATA__ file handle
  	$opts->{_is_data} = 0;
  	$opts->{_data_tell} = 0;
  
  # DEEP DARK MAGIC. this checks the UNTAINT IO flag of a
  # glob/handle. only the DATA handle is untainted (since it is from
  # trusted data in the source file). this allows us to test if this is
  # the DATA handle and then to do a sysseek to make sure it gets
  # slurped correctly. on some systems, the buffered i/o pointer is not
  # left at the same place as the fd pointer. this sysseek makes them
  # the same so slurping with sysread will work.
  
  	eval{ require B } ;
  
  	if ( $@ ) {
  
  		return <<ERR ;
  Can't find B.pm with this Perl: $!.
  That module is needed to properly slurp the DATA handle.
  ERR
  	}
  
  	if ( B::svref_2object( $handle )->IO->IoFLAGS & 16 ) {
  
  		# we now know we have the data handle. Let's store its original
  		# location in the file so that we can put it back after the read.
  		# this is only done for Bugwards-compatibility in some dists such as
  		# CPAN::Index::API that made use of the oddity where sysread was in use
  		# before
  		$opts->{_is_data} = 1;
  		$opts->{_data_tell} = tell($handle);
  # set the seek position to the current tell.
  
  		# unless( sysseek( $handle, tell( $handle ), SEEK_SET ) ) {
  		# 	return "read_file '$handle' - sysseek: $!" ;
  		# }
  	}
  
  # seek was successful, return no error string
  
  	return ;
  }
  
  *wf = \&write_file ;
  
  sub write_file {
  	my $file_name = shift;
  	my $opts = (ref $_[0] eq 'HASH') ? shift : {};
  	# options we care about:
  	# append atomic binmode buf_ref err_mode no_clobber perms
  
  	my $fh;
  	my $no_truncate = 0;
  	my $orig_filename;
  	# let's see if we have a stringified object or some sort of handle
  	# or globref before doing anything else
  	if (ref($file_name)) {
  		my $ref_result = _check_ref($file_name, $opts);
  		if (ref($ref_result)) {
  			# some error happened while checking for a ref
  			@_ = ($opts, $ref_result);
  			goto &_error;
  		}
  		if ($ref_result) {
  			# we have now stringified $file_name from the overloaded obj
  			$file_name = $ref_result;
  		}
  		else {
  			# we now have a proper handle ref
  			# make sure we don't call truncate on it
  			$fh = $file_name;
  			$no_truncate = 1;
  			# can't do atomic or permissions on a file handle
  			delete $opts->{atomic};
  			delete $opts->{perms};
  		}
  	}
  
  	# open the file for writing if we were given a filename
  	unless ($fh) {
  		$orig_filename = $file_name;
  		my $perms = defined($opts->{perms}) ? $opts->{perms} : 0666;
  		# set the mode for the sysopen
  		my $mode = O_WRONLY | O_CREAT;
  		$mode |= O_APPEND if $opts->{append};
  		$mode |= O_EXCL if $opts->{no_clobber};
  		if ($opts->{atomic}) {
  			# in an atomic write, we must open a new file in the same directory
  			# as the original to account for ACLs. We must also set the new file
  			# to the same permissions as the original unless overridden by the
  			# caller's request to set a specified permission set.
  			my $dir = File::Spec->rel2abs(File::Basename::dirname($file_name));
  			if (!defined($opts->{perms}) && -e $file_name && -f _) {
  				$perms = 07777 & (stat $file_name)[2];
  			}
  			# we must ensure we're using a good temporary filename (doesn't already
  			# exist). This is slower, but safer.
  			{
  				local $^W = 0; # AYFKM
  				(undef, $file_name) = tempfile('.tempXXXXX', DIR => $dir, OPEN => 0);
  			}
  		}
  		$fh = local *FH;
  		unless (sysopen($fh, $file_name, $mode, $perms)) {
  			@_ = ($opts, "write_file '$file_name' - sysopen: $!");
  			goto &_error;
  		}
  	}
  	# we now have an open file handle as well as data to write to that handle
  	if (my $binmode = $opts->{binmode}) {
  		binmode($fh, $binmode);
  	}
  
  	# get the data to print to the file
  	# get the buffer ref - it depends on how the data is passed in
  	# after this if/else $buf_ref will have a scalar ref to the data
  	my $buf_ref;
  	my $data_is_ref = 0;
  	if (ref($opts->{buf_ref}) eq 'SCALAR') {
  		# a scalar ref passed in %opts has the data
  		# note that the data was passed by ref
  		$buf_ref = $opts->{buf_ref};
  		$data_is_ref = 1;
  	}
  	elsif (ref($_[0]) eq 'SCALAR') {
  		# the first value in @_ is the scalar ref to the data
  		# note that the data was passed by ref
  		$buf_ref = shift;
  		$data_is_ref = 1;
  	}
  	elsif (ref($_[0]) eq 'ARRAY') {
  		# the first value in @_ is the array ref to the data so join it.
  		${$buf_ref} = join '', @{$_[0]};
  	}
  	else {
  		# good old @_ has all the data so join it.
  		${$buf_ref} = join '', @_;
  	}
  
  	# seek and print
  	seek($fh, 0, SEEK_END) if $opts->{append};
  	print {$fh} ${$buf_ref};
  	truncate($fh, tell($fh)) unless $no_truncate;
  	close($fh);
  
  	if ($opts->{atomic} && !rename($file_name, $orig_filename)) {
  		@_ = ($opts, "write_file '$file_name' - rename: $!");
  		goto &_error;
  	}
  
  	return 1;
  }
  
  # this is for backwards compatibility with the previous File::Slurp module.
  # write_file always overwrites an existing file
  *overwrite_file = \&write_file ;
  
  # the current write_file has an append mode so we use that. this
  # supports the same API with an optional second argument which is a
  # hash ref of options.
  
  sub append_file {
  
  # get the optional opts hash ref
  	my $opts = $_[1] ;
  	if ( ref $opts eq 'HASH' ) {
  
  # we were passed an opts ref so just mark the append mode
  
  		$opts->{append} = 1 ;
  	}
  	else {
  
  # no opts hash so insert one with the append mode
  
  		splice( @_, 1, 0, { append => 1 } ) ;
  	}
  
  # magic goto the main write_file sub. this overlays the sub without touching
  # the stack or @_
  
  	goto &write_file
  }
  
  # prepend data to the beginning of a file
  
  sub prepend_file {
  
  	my $file_name = shift ;
  
  #print "FILE $file_name\n" ;
  
  	my $opts = ( ref $_[0] eq 'HASH' ) ? shift : {} ;
  
  # delete unsupported options
  
  	my @bad_opts =
  		grep $_ ne 'err_mode' && $_ ne 'binmode', keys %{$opts} ;
  
  	delete @{$opts}{@bad_opts} ;
  
  	my $prepend_data = shift ;
  	$prepend_data = '' unless defined $prepend_data ;
  	$prepend_data = ${$prepend_data} if ref $prepend_data eq 'SCALAR' ;
  
  #print "PRE [$prepend_data]\n" ;
  
  	my $err_mode = delete $opts->{err_mode} ;
  	$opts->{ err_mode } = 'croak' ;
  	$opts->{ scalar_ref } = 1 ;
  
  	my $existing_data = eval { read_file( $file_name, $opts ) } ;
  
  	if ( $@ ) {
  
  		@_ = ( { err_mode => $err_mode },
  			"prepend_file '$file_name' - read_file: $!" ) ;
  		goto &_error ;
  	}
  
  #print "EXIST [$$existing_data]\n" ;
  
  	$opts->{atomic} = 1 ;
  	my $write_result =
  		eval { write_file( $file_name, $opts,
  		       $prepend_data, $$existing_data ) ;
  	} ;
  
  	if ( $@ ) {
  
  		@_ = ( { err_mode => $err_mode },
  			"prepend_file '$file_name' - write_file: $!" ) ;
  		goto &_error ;
  	}
  
  	return $write_result ;
  }
  
  # edit a file as a scalar in $_
  
  *ef = \&edit_file ;
  
  sub edit_file(&$;$) {
  
  	my( $edit_code, $file_name, $opts ) = @_ ;
  	$opts = {} unless ref $opts eq 'HASH' ;
  
  # 	my $edit_code = shift ;
  # 	my $file_name = shift ;
  # 	my $opts = ( ref $_[0] eq 'HASH' ) ? shift : {} ;
  
  #print "FILE $file_name\n" ;
  
  # delete unsupported options
  
  	my @bad_opts =
  		grep $_ ne 'err_mode' && $_ ne 'binmode', keys %{$opts} ;
  
  	delete @{$opts}{@bad_opts} ;
  
  # keep the user err_mode and force croaking on internal errors
  
  	my $err_mode = delete $opts->{err_mode} ;
  	$opts->{ err_mode } = 'croak' ;
  
  # get a scalar ref for speed and slurp the file into a scalar
  
  	$opts->{ scalar_ref } = 1 ;
  	my $existing_data = eval { read_file( $file_name, $opts ) } ;
  
  	if ( $@ ) {
  
  		@_ = ( { err_mode => $err_mode },
  			"edit_file '$file_name' - read_file: $!" ) ;
  		goto &_error ;
  	}
  
  #print "EXIST [$$existing_data]\n" ;
  
  	my( $edited_data ) = map { $edit_code->(); $_ } $$existing_data ;
  
  	$opts->{atomic} = 1 ;
  	my $write_result =
  		eval { write_file( $file_name, $opts, $edited_data ) } ;
  
  	if ( $@ ) {
  
  		@_ = ( { err_mode => $err_mode },
  			"edit_file '$file_name' - write_file: $!" ) ;
  		goto &_error ;
  	}
  
  	return $write_result ;
  }
  
  *efl = \&edit_file_lines ;
  
  sub edit_file_lines(&$;$) {
  
  	my( $edit_code, $file_name, $opts ) = @_ ;
  	$opts = {} unless ref $opts eq 'HASH' ;
  
  # 	my $edit_code = shift ;
  # 	my $file_name = shift ;
  # 	my $opts = ( ref $_[0] eq 'HASH' ) ? shift : {} ;
  
  #print "FILE $file_name\n" ;
  
  # delete unsupported options
  
  	my @bad_opts =
  		grep $_ ne 'err_mode' && $_ ne 'binmode', keys %{$opts} ;
  
  	delete @{$opts}{@bad_opts} ;
  
  # keep the user err_mode and force croaking on internal errors
  
  	my $err_mode = delete $opts->{err_mode} ;
  	$opts->{ err_mode } = 'croak' ;
  
  # get an array ref for speed and slurp the file into lines
  
  	$opts->{ array_ref } = 1 ;
  	my $existing_data = eval { read_file( $file_name, $opts ) } ;
  
  	if ( $@ ) {
  
  		@_ = ( { err_mode => $err_mode },
  			"edit_file_lines '$file_name' - read_file: $!" ) ;
  		goto &_error ;
  	}
  
  #print "EXIST [$$existing_data]\n" ;
  
  	my @edited_data = map { $edit_code->(); $_ } @$existing_data ;
  
  	$opts->{atomic} = 1 ;
  	my $write_result =
  		eval { write_file( $file_name, $opts, @edited_data ) } ;
  
  	if ( $@ ) {
  
  		@_ = ( { err_mode => $err_mode },
  			"edit_file_lines '$file_name' - write_file: $!" ) ;
  		goto &_error ;
  	}
  
  	return $write_result ;
  }
  
  # basic wrapper around opendir/readdir
  
  sub read_dir {
  
  	my $dir = shift ;
  	my $opts = ( ref $_[0] eq 'HASH' ) ? shift : { @_ } ;
  
  # this handle will be destroyed upon return
  
  	local(*DIRH);
  
  # open the dir and handle any errors
  
  	unless ( opendir( DIRH, $dir ) ) {
  
  		@_ = ( $opts, "read_dir '$dir' - opendir: $!" ) ;
  		goto &_error ;
  	}
  
  	my @dir_entries = readdir(DIRH) ;
  
  	@dir_entries = grep( $_ ne "." && $_ ne "..", @dir_entries )
  		unless $opts->{'keep_dot_dot'} ;
  
  	if ( $opts->{'prefix'} ) {
  
  		$_ = File::Spec->catfile($dir, $_) for @dir_entries;
  	}
  
  	return @dir_entries if wantarray ;
  	return \@dir_entries ;
  }
  
  # error handling section
  #
  # all the error handling uses magic goto so the caller will get the
  # error message as if from their code and not this module. if we just
  # did a call on the error code, the carp/croak would report it from
  # this module since the error sub is one level down on the call stack
  # from read_file/write_file/read_dir.
  
  
  my %err_func = (
  	'carp'	=> \&carp,
  	'croak'	=> \&croak,
  ) ;
  
  sub _error {
  
  	my( $opts, $err_msg ) = @_ ;
  
  # get the error function to use
  
   	my $func = $err_func{ $opts->{'err_mode'} || 'croak' } ;
  
  # if we didn't find it in our error function hash, they must have set
  # it to quiet and we don't do anything.
  
  	return unless $func ;
  
  # call the carp/croak function
  
  	$func->($err_msg) if $func ;
  
  # return a hard undef (in list context this will be a single value of
  # undef which is not a legal in-band value)
  
  	return undef ;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  File::Slurp - Simple and Efficient Reading/Writing/Modifying of Complete Files
  
  =head1 SYNOPSIS
  
    use File::Slurp;
  
    # read in a whole file into a scalar
    my $text = read_file('/path/file');
  
    # read in a whole file into an array of lines
    my @lines = read_file('/path/file');
  
    # write out a whole file from a scalar
    write_file('/path/file', $text);
  
    # write out a whole file from an array of lines
    write_file('/path/file', @lines);
  
    # Here is a simple and fast way to load and save a simple config file
    # made of key=value lines.
    my %conf = read_file('/path/file') =~ /^(\w+)=(.*)$/mg;
    write_file('/path/file', {atomic => 1}, map "$_=$conf{$_}\n", keys %conf);
  
    # insert text at the beginning of a file
    prepend_file('/path/file', $text);
  
    # in-place edit to replace all 'foo' with 'bar' in file
    edit_file { s/foo/bar/g } '/path/file';
  
    # in-place edit to delete all lines with 'foo' from file
    edit_file_lines sub { $_ = '' if /foo/ }, '/path/file';
  
    # read in a whole directory of file names (skipping . and ..)
    my @files = read_dir('/path/to/dir');
  
  =head1 DESCRIPTION
  
  This module provides subs that allow you to read or write entire files
  with one simple call. They are designed to be simple to use, have
  flexible ways to pass in or get the file contents and to be very
  efficient. There is also a sub to read in all the files in a
  directory.
  
  =head2 WARNING - PENDING DOOM
  
  Although you technically I<can>, do NOT use this module to work on file handles,
  pipes, sockets, standard IO, or the C<DATA> handle. These are
  features implemented long ago that just really shouldn't be abused here.
  
  Be warned: this activity will lead to inaccurate encoding/decoding of data.
  
  All further mentions of actions on the above have been removed from this
  documentation and that feature set will likely be deprecated in the future.
  
  In other words, if you don't have a filename to pass, consider using the
  standard C<< do { local $/; <$fh> } >>, or
  L<Data::Section>/L<Data::Section::Simple> for working with C<__DATA__>.
  
  =head1 FUNCTIONS
  
  L<File::Slurp> implements the following functions.
  
  =head2 append_file
  
  	use File::Slurp qw(append_file write_file);
  	my $res = append_file('/path/file', "Some text");
  	# same as
  	my $res = write_file('/path/file', {append => 1}, "Some text");
  
  The C<append_file> function is simply a synonym for the
  L<File::Slurp/"write_file"> function, but ensures that the C<append> option is
  set.
  
  =head2 edit_file
  
  	use File::Slurp qw(edit_file);
  	# perl -0777 -pi -e 's/foo/bar/g' /path/file
  	edit_file { s/foo/bar/g } '/path/file';
  	edit_file sub { s/foo/bar/g }, '/path/file';
  	sub replace_foo { s/foo/bar/g }
  	edit_file \&replace_foo, '/path/file';
  
  The C<edit_file> function reads in a file into C<$_>, executes a code block that
  should modify C<$_>, and then writes C<$_> back to the file. The C<edit_file>
  function reads in the entire file and calls the code block one time. It is
  equivalent to the C<-pi> command line options of Perl but you can call it from
  inside your program and not have to fork out a process.
  
  The first argument to C<edit_file> is a code block or a code reference. The
  code block is not followed by a comma (as with C<grep> and C<map>) but a code
  reference is followed by a comma.
  
  The next argument is the filename.
  
  The next argument(s) is either a hash reference or a flattened hash,
  C<< key => value >> pairs. The options are passed through to the
  L<File::Slurp/"write_file"> function. All options are described there.
  Only the C<binmode> and C<err_mode> options are supported. The call to
  L<File::Slurp/"write_file"> has the C<atomic> option set so you will always
  have a consistent file.
  
  =head2 edit_file_lines
  
  	use File::Slurp qw(edit_file_lines);
  	# perl -pi -e '$_ = "" if /foo/' /path/file
  	edit_file_lines { $_ = '' if /foo/ } '/path/file';
  	edit_file_lines sub { $_ = '' if /foo/ }, '/path/file';
  	sub delete_foo { $_ = '' if /foo/ }
  	edit_file \&delete_foo, '/path/file';
  
  The C<edit_file_lines> function reads each line of a file into C<$_>, and
  executes a code block that should modify C<$_>. It will then write C<$_> back
  to the file. It is equivalent to the C<-pi> command line options of Perl but
  you can call it from inside your program and not have to fork out a process.
  
  The first argument to C<edit_file_lines> is a code block or a code reference.
  The code block is not followed by a comma (as with C<grep> and C<map>) but a
  code reference is followed by a comma.
  
  The next argument is the filename.
  
  The next argument(s) is either a hash reference or a flattened hash,
  C<< key => value >> pairs. The options are passed through to the
  L<File::Slurp/"write_file"> function. All options are described there.
  Only the C<binmode> and C<err_mode> options are supported. The call to
  L<File::Slurp/"write_file"> has the C<atomic> option set so you will always
  have a consistent file.
  
  =head2 ef
  
  	use File::Slurp qw(ef);
  	# perl -0777 -pi -e 's/foo/bar/g' /path/file
  	ef { s/foo/bar/g } '/path/file';
  	ef sub { s/foo/bar/g }, '/path/file';
  	sub replace_foo { s/foo/bar/g }
  	ef \&replace_foo, '/path/file';
  
  The C<ef> function is simply a synonym for the L<File::Slurp/"edit_file">
  function.
  
  =head2 efl
  
  	use File::Slurp qw(efl);
  	# perl -pi -e '$_ = "" if /foo/' /path/file
  	efl { $_ = '' if /foo/ } '/path/file';
  	efl sub { $_ = '' if /foo/ }, '/path/file';
  	sub delete_foo { $_ = '' if /foo/ }
  	efl \&delete_foo, '/path/file';
  
  The C<efl> function is simply a synonym for the L<File::Slurp/"edit_file_lines">
  function.
  
  =head2 overwrite_file
  
  	use File::Slurp qw(overwrite_file);
  	my $res = overwrite_file('/path/file', "Some text");
  
  The C<overwrite_file> function is simply a synonym for the
  L<File::Slurp/"write_file"> function.
  
  =head2 prepend_file
  
  	use File::Slurp qw(prepend_file);
  	prepend_file('/path/file', $header);
  	prepend_file('/path/file', \@lines);
  	prepend_file('/path/file', { binmode => ':raw'}, $bin_data);
  
  	# equivalent to:
  	use File::Slurp qw(read_file write_file);
  	my $content = read_file('/path/file');
  	my $new_content = "hahahaha";
  	write_file('/path/file', $new_content . $content);
  
  The C<prepend_file> function is the opposite of L<File::Slurp/"append_file"> as
  it writes new contents to the beginning of the file instead of the end. It is a
  combination of L<File::Slurp/"read_file"> and L<File::Slurp/"write_file">. It
  works by first using C<read_file> to slurp in the file and then calling
  C<write_file> with the new data and the existing file data.
  
  The first argument to C<prepend_file> is the filename.
  
  The next argument(s) is either a hash reference or a flattened hash,
  C<< key => value >> pairs. The options are passed through to the
  L<File::Slurp/"write_file"> function. All options are described there.
  
  Only the C<binmode> and C<err_mode> options are supported. The
  C<write_file> call has the C<atomic> option set so you will always have
  a consistent file.
  
  =head2 read_dir
  
  	use File::Slurp qw(read_dir);
  	my @files = read_dir('/path/to/dir');
  	# all files, even the dots
  	my @files = read_dir('/path/to/dir', keep_dot_dot => 1);
  	# keep the full file path
  	my @paths = read_dir('/path/to/dir', prefix => 1);
  	# scalar context
  	my $files_ref = read_dir('/path/to/dir');
  
  This function returns a list of the filenames in the supplied directory. In
  list context, an array is returned, in scalar context, an array reference is
  returned.
  
  The first argument is the path to the directory to read.
  
  The next argument(s) is either a hash reference or a flattened hash,
  C<< key => value >> pairs. The following options are available:
  
  =over
  
  =item
  
  err_mode
  
  The C<err_mode> option has three possible values: C<quiet>, C<carp>, or the
  default, C<croak>. In C<quiet> mode, all errors will be silent. In C<carp> mode,
  all errors will be emitted as warnings. And, in C<croak> mode, all errors will
  be emitted as exceptions. Take a look at L<Try::Tiny> or
  L<Syntax::Keyword::Try> to see how to catch exceptions.
  
  =item
  
  keep_dot_dot
  
  The C<keep_dot_dot> option is a boolean option, defaulted to false (C<0>).
  Setting this option to true (C<1>) will also return the C<.> and C<..> files
  that are removed from the file list by default.
  
  =item
  
  prefix
  
  The C<prefix> option is a boolean option, defaulted to false (C<0>).
  Setting this option to true (C<1>) add the directory as a prefix to the file.
  The directory and the filename are joined using C<< File::Spec->catfile() >> to
  ensure the proper directory separator is used for your OS. See L<File::Spec>.
  
  =back
  
  =head2 read_file
  
  	use File::Slurp qw(read_file);
  	my $text = read_file('/path/file');
  	my $bin = read_file('/path/file', { binmode => ':raw' });
  	my @lines = read_file('/path/file');
  	my $lines_ref = read_file('/path/file', array_ref => 1);
  	my $lines_ref = [ read_file('/path/file') ];
  
  	# or we can read into a buffer:
  	my $buffer;
  	read_file('/path/file', buf_ref => \$buffer);
  
  	# or we can set the block size for the read
  	my $text_ref = read_file('/path/file', blk_size => 10_000_000, array_ref => 1);
  
  	# or we can get a scalar reference
  	my $text_ref = read_file('/path/file', scalar_ref => 1);
  
  This function reads in an entire file and returns its contents to the
  caller. In scalar context it returns the entire file as a single
  scalar. In list context it will return a list of lines (using the
  current value of C<$/> as the separator, including support for paragraph
  mode when it is set to C<''>).
  
  The first argument is the path to the file to be slurped in.
  
  The next argument(s) is either a hash reference or a flattened hash,
  C<< key => value >> pairs. The following options are available:
  
  =over
  
  =item
  
  array_ref
  
  The C<array_ref> option is a boolean option, defaulted to false (C<0>). Setting
  this option to true (C<1>) will only have relevance if the C<read_file> function
  is called in scalar context. When true, the C<read_file> function will return
  a reference to an array of the lines in the file.
  
  =item
  
  binmode
  
  The C<binmode> option is a string option, defaulted to empty (C<''>). If you
  set the C<binmode> option, then its value is passed to a call to C<binmode> on
  the opened handle. You can use this to set the file to be read in binary mode,
  utf8, etc. See C<perldoc -f binmode> for more.
  
  =item
  
  blk_size
  
  You can use this option to set the block size used when slurping from
  an already open handle (like C<\*STDIN>). It defaults to 1MB.
  
  =item
  
  buf_ref
  
  The C<buf_ref> option can be used in conjunction with any of the other options.
  You can use this option to pass in a scalar reference and the slurped
  file contents will be stored in the scalar. This saves an extra copy of
  the slurped file and can lower RAM usage vs returning the file. It is
  usually the fastest way to read a file into a scalar.
  
  =item
  
  chomp
  
  The C<chomp> option is a boolean option, defaulted to false (C<0>). Setting
  this option to true (C<1>) will cause each line to have its contents C<chomp>ed.
  This option works in list context or in scalar context with the C<array_ref>
  option.
  
  =item
  
  err_mode
  
  The C<err_mode> option has three possible values: C<quiet>, C<carp>, or the
  default, C<croak>. In C<quiet> mode, all errors will be silent. In C<carp> mode,
  all errors will be emitted as warnings. And, in C<croak> mode, all errors will
  be emitted as exceptions. Take a look at L<Try::Tiny> or
  L<Syntax::Keyword::Try> to see how to catch exceptions.
  
  =item
  
  scalar_ref
  
  The C<scalar_ref> option is a boolean option, defaulted to false (C<0>). It only
  has meaning in scalar context. The return value will be a scalar reference to a
  string which is the contents of the slurped file. This will usually be faster
  than returning the plain scalar. It will also save memory as it will not make a
  copy of the file to return.
  
  =back
  
  =head2 rf
  
  	use File::Slurp qw(rf);
  	my $text = rf('/path/file');
  
  The C<rf> function is simply a synonym for the L<File::Slurp/"read_file">
  function.
  
  =head2 slurp
  
  	use File::Slurp qw(slurp);
  	my $text = slurp('/path/file');
  
  The C<slurp> function is simply a synonym for the L<File::Slurp/"read_file">
  function.
  
  =head2 wf
  
  	use File::Slurp qw(wf);
  	my $res = wf('/path/file', "Some text");
  
  
  The C<wf> function is simply a synonym for the
  L<File::Slurp/"write_file"> function.
  
  =head2 write_file
  
  	use File::Slurp qw(write_file);
  	write_file('/path/file', @data);
  	write_file('/path/file', {append => 1}, @data);
  	write_file('/path/file', {binmode => ':raw'}, $buffer);
  	write_file('/path/file', \$buffer);
  	write_file('/path/file', $buffer);
  	write_file('/path/file', \@lines);
  	write_file('/path/file', @lines);
  
  	# binmode
  	write_file('/path/file', {binmode => ':raw'}, @data);
  	write_file('/path/file', {binmode => ':utf8'}, $utf_text);
  
  	# buffered
  	write_file('/path/file', {buf_ref => \$buffer});
  	write_file('/path/file', \$buffer);
  	write_file('/path/file', $buffer);
  
  	# append
  	write_file('/path/file', {append => 1}, @data);
  
  	# no clobbering
  	write_file('/path/file', {no_clobber => 1}, @data);
  
  This function writes out an entire file in one call. By default C<write_file>
  returns C<1> upon successfully writing the file or C<undef> if it encountered
  an error. You can change how errors are handled with the C<err_mode> option.
  
  The first argument to C<write_file> is the filename.
  
  The next argument(s) is either a hash reference or a flattened hash,
  C<< key => value >> pairs. The following options are available:
  
  =over
  
  =item
  
  append
  
  The C<append> option is a boolean option, defaulted to false (C<0>). Setting
  this option to true (C<1>) will cause the data to be be written at the end of
  the current file. Internally this sets the C<sysopen> mode flag C<O_APPEND>.
  
  The L<File::Slurp/"append_file"> function sets this option by default.
  
  =item
  
  atomic
  
  The C<atomic> option is a boolean option, defaulted to false (C<0>). Setting
  this option to true (C<1>) will cause the file to be be written to in an
  atomic fashion. A temporary file name is created using L<File::Temp/"tempfile">.
  After the file is closed it is renamed to the original file name
  (and C<rename> is an atomic operation on most OSes). If the program using
  this were to crash in the middle of this, then the temporary file could
  be left behind.
  
  =item
  
  binmode
  
  The C<binmode> option is a string option, defaulted to empty (C<''>). If you
  set the C<binmode> option, then its value is passed to a call to C<binmode> on
  the opened handle. You can use this to set the file to be read in binary mode,
  utf8, etc. See C<perldoc -f binmode> for more.
  
  =item
  
  buf_ref
  
  The C<buf_ref> option is used to pass in a scalar reference which has the
  data to be written. If this is set then any data arguments (including
  the scalar reference shortcut) in C<@_> will be ignored.
  
  =item
  
  err_mode
  
  The C<err_mode> option has three possible values: C<quiet>, C<carp>, or the
  default, C<croak>. In C<quiet> mode, all errors will be silent. In C<carp> mode,
  all errors will be emitted as warnings. And, in C<croak> mode, all errors will
  be emitted as exceptions. Take a look at L<Try::Tiny> or
  L<Syntax::Keyword::Try> to see how to catch exceptions.
  
  
  =item
  
  no_clobber
  
  The C<no_clobber> option is a boolean option, defaulted to false (C<0>). Setting
  this option to true (C<1>) will ensure an that existing file will not be
  overwritten.
  
  =item
  
  perms
  
  The C<perms> option sets the permissions of newly-created files. This value
  is modified by your process's C<umask> and defaults to C<0666> (same as
  C<sysopen>).
  
  NOTE: this option is new as of File::Slurp version 9999.14.
  
  =back
  
  =head1 EXPORT
  
  These are exported by default or with
  
  	use File::Slurp qw(:std);
  	# read_file write_file overwrite_file append_file read_dir
  
  These are exported with
  
  	use File::Slurp qw(:edit);
  	# edit_file edit_file_lines
  
  You can get all subs in the module exported with
  
  	use File::Slurp qw(:all);
  
  =head1 SEE ALSO
  
  =over
  
  =item *
  
  L<File::Slurper> - Provides a straightforward set of functions for the most
  common tasks of reading/writing text and binary files.
  
  =item *
  
  L<Path::Tiny> - Lightweight and comprehensive file handling, including simple
  methods for reading, writing, and editing text and binary files.
  
  =item *
  
  L<Mojo::File> - Similar to Path::Tiny for the L<Mojo> toolkit, always works in
  bytes.
  
  =back
  
  =head1 AUTHOR
  
  Uri Guttman, <F<uri@stemsystems.com>>
  
  =head1 COPYRIGHT & LICENSE
  
  Copyright (c) 2003 Uri Guttman. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =cut
FILE_SLURP

$fatpacked{"Gradescope/Color.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRADESCOPE_COLOR';
  package Gradescope::Color v2023.02.14 {
      use v5.36;
      use utf8;
      use strictures 2; # nice `use strict`, `use warnings` defaults
      use open qw(:utf8); # try to use Perl's internal Unicode encoding for everything
      BEGIN{$diagnostics::PRETTY = 1} # a bit noisy, but somewhat informative
      use diagnostics -verbose;
  
      # turn on features
          use builtin qw(true false is_bool reftype);
          no warnings 'experimental::builtin';
          use feature 'try';
          no warnings 'experimental::try';
      # end prelude
      use Carp;
      use Carp::Assert;
      use IPC::Cmd qw(can_run);
      use IPC::Run qw(run);
  
      use parent qw(Exporter);
  
      # default exports
      our @EXPORT = qw();
      # optional exports
      our @EXPORT_OK = qw(
          color_print
      );
  
      our $has_colorizer = defined(can_run('bat'));
      carp '[suggestion] get `bat` for colorized output' if !$has_colorizer;
  
      sub color_print {
          my ($str, $language) = @_;
          if($has_colorizer && !defined($ENV{GU_NO_PAGER})){
              run ['bat', '-l', $language], '<', \$str;
          }
          else{
              print $str;
          }
      }
  
      true;
  }
  
  # ABSTRACT: Gradescope submission script component
  =pod
  
  =encoding utf8
  
  =head1 DESCRIPTION
  
  =cut
GRADESCOPE_COLOR

$fatpacked{"Gradescope/Curl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRADESCOPE_CURL';
  package Gradescope::Curl v2022.11.13 {
      use v5.36;
      use utf8;
      use strictures 2; # nice `use strict`, `use warnings` defaults
      use open qw(:utf8); # try to use Perl's internal Unicode encoding for everything
      BEGIN{$diagnostics::PRETTY = 1} # a bit noisy, but somewhat informative
      use diagnostics -verbose;
  
      # turn on features
          use builtin qw(true false is_bool reftype);
          no warnings 'experimental::builtin';
          use feature 'try';
          no warnings 'experimental::try';
      # end prelude
      use Carp;
      use Carp::Assert;
      use IO::Prompter;
      use JSON;
  
      use parent qw(Exporter);
  
      # default exports
      our @EXPORT = qw();
      # optional exports
      our @EXPORT_OK = qw(
          login
      );
  
      our $baseurl;
  
      sub import {
          # in the style of Getopt::Long
          # (I figured people would be familiar w/ this import style since
          # Getopt::Long well known)
          shift; # package
          my @syms;
          my @config;
          my $dest = \@syms;
          for (@_){
              if($_ eq ':config'){
                  $dest = \@config;
              } else{
                  @$dest = (@$dest, $_);
              }
          }
          Gradescope::Curl->export_to_level(1, @syms);
          my %config = @config;
          assert(!defined($baseurl));
          $baseurl = $config{baseurl};
          assert(defined($baseurl));
      }
  
      sub login {
          # hacked together from the python script and a lot of netcat (thanks 489)
          # aka the curl snippets took a lot of trial and error
          open my $tty, '<', '/dev/tty' or confess 'This needs to be run in an interactive shell!';
          my $email = IO::Prompter::prompt('Enter your email: ', -in => $tty);
          my $password = IO::Prompter::prompt('Enter your password: ', -in => $tty, -echo => '');
          my %response = %{JSON::from_json(`curl -s --data 'email=$email&password=$password' $baseurl/api/v1/user_session`)};
          carp '[warning] curl returned error code on gradescope auth' if $? >> 8;
          $response{token} // confess "[error] Your gradescope login credentials are probably wrong";
          carp "[debug] token_expiration_time: $response{token_expiration_time}";
          return $response{token};
      }
  
      true;
  }
  
  # ABSTRACT: Gradescope submission script component
  =pod
  
  =encoding utf8
  
  =head1 DESCRIPTION
  
  =cut
GRADESCOPE_CURL

$fatpacked{"Gradescope/Translate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GRADESCOPE_TRANSLATE';
  package Gradescope::Translate v2022.12.30 {
      use v5.36;
      use utf8;
      use strictures 2; # nice `use strict`, `use warnings` defaults
      use open qw(:utf8); # try to use Perl's internal Unicode encoding for everything
      BEGIN{$diagnostics::PRETTY = 1} # a bit noisy, but somewhat informative
      use diagnostics -verbose;
  
      # turn on features
          use builtin qw(true false is_bool reftype);
          no warnings 'experimental::builtin';
          use feature 'try';
          no warnings 'experimental::try';
      # end prelude
      use Carp;
      use Carp::Assert;
      use Text::CSV;
      use JSON;
      use File::Slurp;
  
      use parent qw(Exporter);
  
      # default exports
      our @EXPORT = qw();
      # optional exports
      our @EXPORT_OK = qw(
          print_csv
          read_csv
      );
  
      sub print_csv {
          my ($in, $out) = @_;
          Text::CSV::csv({
              # attributes (OO interface)
              binary => 0,
              decode_utf8 => 0,
              strict => 1,
              # `csv` arguments
              in => $in,
              out => $out,
              encoding => ':utf8',
          }) or confess Text::CSV->error_diag;
      }
  
      sub read_csv {
          my ($csv_path, $key_header, $value_header, $filter) = @_;
          $filter //= sub {true};
          my %kv = %{Text::CSV::csv ({
              # attributes (OO interface)
              binary => 0,
              decode_utf8 => 0,
              strict => 1,
              # `csv` arguments
              in => $csv_path,
              filter => $filter,
              encoding => 'UTF-8',
              key => $key_header,
              value => $value_header,
          }) or confess Text::CSV->error_diag};
          return %kv;
      }
  
  }
  
  # ABSTRACT: Gradescope submission script component
  =pod
  
  =encoding utf8
  
  =head1 DESCRIPTION
  
  C<Text::CSV> wrappers
  
  =cut
GRADESCOPE_TRANSLATE

$fatpacked{"IO/Prompter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_PROMPTER';
  use 5.010;
  package IO::Prompter;
  use utf8;
  
  use warnings;
  no if $] >= 5.018000, warnings => 'experimental';
  use strict;
  use Carp;
  use Contextual::Return qw< PUREBOOL BOOL SCALAR METHOD VOID LIST RETOBJ >;
  use Scalar::Util qw< openhandle looks_like_number >;
  use Symbol       qw< qualify_to_ref >;
  
  our $VERSION = '0.004015';
  
  my $fake_input;     # Flag that we're faking input from the source
  
  my $DEFAULT_TERM_WIDTH   = 80;
  my $DEFAULT_VERBATIM_KEY = "\cV";
  
  # Completion control...
  my $COMPLETE_DISPLAY_FIELDS = 4;  #...per line
  my $COMPLETE_DISPLAY_GAP    = 3;  #...spaces
  
  my $COMPLETE_KEY  = $ENV{IO_PROMPTER_COMPLETE_KEY} // qq{\t};
  my $COMPLETE_HIST = $ENV{IO_PROMPTER_HISTORY_KEY}  // qq{\cR};
  my $COMPLETE_NEXT = qq{\cN};
  my $COMPLETE_PREV = qq{\cP};
  
  my $COMPLETE_INIT  = qr{ [\Q$COMPLETE_KEY$COMPLETE_HIST\E] }xms;
  my $COMPLETE_CYCLE = qr{ [$COMPLETE_NEXT$COMPLETE_PREV] }xms;
  
  my %COMPLETE_MODE = (
      $COMPLETE_KEY
          => [split /\s+/, $ENV{IO_PROMPTER_COMPLETE_MODES}//q{list+longest  full}],
      $COMPLETE_HIST
          => [split /\s+/, $ENV{IO_PROMPTER_HISTORY_MODES} // q{full}],
  );
  
  my $FAKE_ESC    = "\e";
  my $FAKE_INSERT = "\cF";
  my $MENU_ESC    = "\e";
  my $MENU_MK     = '__M_E_N_U__';
  
  my %EDIT = (
      BACK    => qq{\cB},
      FORWARD => qq{\cF},
      START   => qq{\cA},
      END     => qq{\cE},
  );
  my $EDIT_KEY = '['.join(q{},values %EDIT).']';
  
  # Extracting key letters...
  my $KL_EXTRACT = qr{ (?| \[  ( [[:alnum:]]++ )  \]
                         | \(  ( [[:alnum:]]++ )  \)
                         | \<  ( [[:alnum:]]++ )  \>
                         | \{  ( [[:alnum:]]++ )  \}
                       )
                     }xms;
  my $KL_DEF_EXTRACT = qr{ \[  ( [[:alnum:]]++ )  \] }xms;
  
  
  # Auxiliary prompts for -Yes => N construct...
  my @YESNO_PROMPTS = (
      q{Really?},
      q{You're quite certain?},
      q{Definitely?},
      q{You mean it?},
      q{You truly mean it?},
      q{You're sure?},
      q{Have you thought this through?},
      q{You understand the consequences?},
  );
  
  
  # Remember returned values for history completion...
  my %history_cache;
  
  # Track lexically-scoped default options and wrapper subs...
  my @lexical_options  = [];
  my @lexical_wrappers = [];
  
  # Export the prompt() sub...
  sub import {
      my (undef, $config_data, @other_args) = @_;
  
      # Handle -argv requests...
      if (defined $config_data && $config_data eq '-argv') {
          scalar prompt(-argv, @other_args);
      }
  
      # Handle lexical options...
      elsif (ref $config_data eq 'ARRAY') {
          push @lexical_options, $config_data;
          $^H{'IO::Prompter::scope_number'} = $#lexical_options;
      }
  
      # Handle lexical wrappers...
      elsif (ref $config_data eq 'HASH') {
          push @lexical_options, [];
          $lexical_wrappers[ $#lexical_options ] = $config_data;
          $^H{'IO::Prompter::scope_number'} = $#lexical_options;
          for my $subname (keys %{$config_data}) {
              my @args = @{$config_data->{$subname}};
              no strict 'refs';
              no warnings 'redefine';
              *{caller().'::'.$subname} = sub {
                  my $scope_number = (caller 0)[10]{'IO::Prompter::scope_number'};
                  return prompt(@{$lexical_wrappers[$scope_number]{$subname}//[]}, @_);
              };
          }
      }
  
      # Handler faked input specifications...
      elsif (defined $config_data) {
          $fake_input = $config_data;
      }
  
      no strict 'refs';
      *{caller().'::prompt'} = \&prompt;
  }
  
  # Prompt for, read, vet, and return input...
  sub prompt {
      # Reclaim full control of print statements while prompting...
      local $\ = '';
  
      # Locate any lexical default options...
      my $hints_hash = (caller 0)[10] // {};
      my $scope_num = $hints_hash->{'IO::Prompter::scope_number'} // 0;
  
      # Extract and sanitize configuration arguments...
      my $opt_ref = _decode_args(@{$lexical_options[$scope_num]}, @_);
  
      _warn( void => 'Useless use of prompt() in void context' )
          if VOID && !$opt_ref->{-void};
  
      # Set up yesno prompts if required...
      my @yesno_prompts
          = ($opt_ref->{-yesno}{count}//0) > 1 ? @YESNO_PROMPTS : ();
  
      # Work out where the prompts go, and where the input comes from...
      my $in_filehandle  = $opt_ref->{-in}  // _open_ARGV();
      my $out_filehandle = $opt_ref->{-out} // qualify_to_ref(select);
      if (!openhandle $in_filehandle) {
          open my $fh, '<', $in_filehandle
              or _opt_err('Unacceptable', '-in', 'valid filehandle or filename');
          $in_filehandle = $fh;
      }
      if (!openhandle $out_filehandle) {
          open my $fh, '>', $out_filehandle
              or _opt_err('Unacceptable', '-out', 'valid filehandle or filename');
          $out_filehandle = $fh;
      }
  
      # Track timeouts...
      my $in_pos = do { no warnings;  tell $in_filehandle } // 0;
  
      # Short-circuit if not valid handles...
      return if !openhandle($in_filehandle) || !openhandle($out_filehandle);
  
      # Work out how they're arriving and departing...
      my $outputter_ref = -t $in_filehandle && -t $out_filehandle
                              ? _std_printer_to($out_filehandle, $opt_ref)
                              : _null_printer()
                              ;
      my $inputter_ref = _generate_unbuffered_reader_from(
                              $in_filehandle, $outputter_ref, $opt_ref
                         );
  
      # Clear the screen if requested to...
      if ($opt_ref->{-wipe}) {
          $outputter_ref->(-nostyle => "\n" x 1000);
      }
  
      # Handle menu structures...
      my $input;
      REPROMPT_YESNO:
      if ($opt_ref->{-menu}) {
          # Remember top of (possibly nested) menu...
          my @menu = ( $opt_ref->{-menu} );
          my $top_prompt = $opt_ref->{-prompt};
          $top_prompt =~ s{$MENU_MK}{$opt_ref->{-menu}{prompt}}xms;
          $menu[-1]{prompt} = $top_prompt;
  
          MENU:
          while (1) {
              # Track the current level...
              $opt_ref->{-menu_curr_level} = $menu[-1]{value_for};
  
              # Show menu and retreive choice...
              $outputter_ref->(-style => $menu[-1]{prompt});
              my $tag = $inputter_ref->($menu[-1]{constraint});
  
              # Handle a failure by exiting the loop...
              last MENU if !defined $tag;
              $tag =~ s{\A\s*(\S*).*}{$1}xms;
  
              # Handle <ESC> by moving up menu stack...
              if ($tag eq $MENU_ESC) {
                  $input = undef;
                  last MENU if @menu <= 1;
                  pop @menu;
                  next MENU;
              }
  
              # Handle defaults by selecting and ejecting...
              if ($tag =~ /\A\R?\Z/ && exists $opt_ref->{-def}) {
                  $input = $tag;
                  last MENU;
              }
  
              # Otherwise, retrieve value for selected tag and exit if not a nested menu...
              $input = $menu[-1]{value_for}{$tag};
              last MENU if !ref $input;
  
              # Otherwise, go down the menu one level...
              push @menu,
                  _build_menu($input,
                               "Select from $menu[-1]{key_for}{$tag}: ",
                               $opt_ref->{-number} || $opt_ref->{-integer}
                  );
              $menu[-1]{prompt} .= '> ';
          }
      }
  
      # Otherwise, simply ask and ye shall receive...
      else {
          $outputter_ref->(-style => $opt_ref->{-prompt});
          $input = $inputter_ref->();
      }
  
      # Provide default value if available and necessary...
      my $defaulted = 0;
      if (defined $input && $input =~ /\A\R?\Z/ && exists $opt_ref->{-def}) {
          $input = $opt_ref->{-def};
          $defaulted = 1;
      }
  
      # The input line is usually chomped before being returned...
      if (defined $input && !$opt_ref->{-line}) {
          chomp $input;
      }
  
      # Check for a value indicating failure...
      if (exists $opt_ref->{-fail} && $input ~~ $opt_ref->{-fail}) {
          $input = undef;
      }
  
      # Setting @ARGV is a special case; process it like a command-line...
      if ($opt_ref->{-argv}) {
          @ARGV = map { _shell_expand($_) }
                      grep {defined}
                              $input =~ m{
                                      ( '  [^'\\]* (?: \\. [^'\\]* )* ' )
                                  |   ( "  [^"\\]* (?: \\. [^"\\]* )* " )
                                  |   (?: ^ | \s)  ( [^\s"'] \S*        )
                              }gxms;
          return 1;
      }
  
      # "Those who remember history are enabled to repeat it"...
      if (defined $input and $opt_ref->{-history} ne 'NONE') {
          my $history_set = $history_cache{ $opt_ref->{-history} } //= [] ;
          @{ $history_set } = ($input, grep { $_ ne $input } @{ $history_set });
      }
  
      # If input timed out insert the default, if any...
      my $timedout = $in_pos == do{ no warnings; tell $in_filehandle } // 0;
      if ($timedout && exists $opt_ref->{-def}) {
          $input = $opt_ref->{-def};
          $defaulted = 1;
      }
  
      # A defined input is a successful input...
      my $succeeded = defined $input;
  
      # The -yesno variants also need a 'y' to be successful...
      if ($opt_ref->{-yesno}{count}) {
          $succeeded &&= $input =~ m{\A \s* y}ixms;
          if ($succeeded && $opt_ref->{-yesno}{count} > 1) {
              my $count = --$opt_ref->{-yesno}{count};
              $opt_ref->{-prompt}
                  = @yesno_prompts ? shift(@yesno_prompts) . q{ }
                  : $count > 1     ? qq{Please confirm $count more times }
                  :                   q{Please confirm one last time }
                  ;
              goto REPROMPT_YESNO;    # Gasp, yes goto is the cleanest way!
          }
      }
  
      # Verbatim return doesn't do fancy tricks...
      if ($opt_ref->{-verbatim}) {
          return $input // ();
      }
  
      # Failure in a list context returns nothing...
      return if LIST && !$succeeded;
  
      # Otherwise, be context sensitive...
      return
          PUREBOOL { $_ = RETOBJ; next handler;      }
              BOOL { $succeeded;                     }
            SCALAR { $input;                         }
            METHOD {
                      defaulted => sub { $defaulted  },
                      timedout  => sub {
                          return q{} if !$timedout;
                          return "timed out after $opt_ref->{-timeout} second"
                               . ($opt_ref->{-timeout} == 1 ? q{} : q{s});
                      },
                   };
  }
  
  
  # Simulate a command line expansion for the -argv option...
  sub _shell_expand {
      my ($text) = @_;
  
      # Single-quoted text is literal...
      if ($text =~ m{\A ' (.*) ' \z}xms) {
          return $1;
      }
  
      # Everything else has shell variables expanded...
      my $ENV_PAT = join '|', reverse sort keys %ENV;
      $text =~ s{\$ ($ENV_PAT)}{$ENV{$1}}gxms;
  
      # Double-quoted text isn't globbed...
      if ($text =~ m{\A " (.*) " \z}xms) {
          return $1;
      }
  
      # Everything else is...
      return glob($text);
  }
  
  # No completion is the default...
  my $DEFAULT_COMPLETER = sub { q{} };
  
  # Translate std constraints...
  my %STD_CONSTRAINT = (
      positive  => sub { $_ > 0      },
      negative  => sub { $_ < 0      },
      zero      => sub { $_ == 0     },
      even      => sub { $_ % 2 == 0 },
      odd       => sub { $_ % 2 != 0 },
  );
  
  # Create abbreviations...
  $STD_CONSTRAINT{pos} = $STD_CONSTRAINT{positive};
  $STD_CONSTRAINT{neg} = $STD_CONSTRAINT{negative};
  
  # Create antitheses...
  for my $constraint (keys %STD_CONSTRAINT) {
      my $implementation = $STD_CONSTRAINT{$constraint};
      $STD_CONSTRAINT{"non$constraint"}
          = sub { ! $implementation->(@_) };
  }
  
  # Special style specifications require decoding...
  
  sub _decode_echo {
      my $style = shift;
  
      # Not a special style...
      return $style if ref $style || $style !~ m{/};
  
      # A slash means yes/no echoes...
      my ($yes, $no) = split m{/}, $style;
      return sub{ /y/i ? $yes : $no };
  }
  
  sub _decode_echostyle {
      my $style = shift;
  
      # Not a special style...
      return $style if ref $style || $style !~ m{/};
  
      # A slash means yes/no styles...
      my ($yes, $no) = split m{/}, $style;
      return sub{ /y/i ? $yes : $no };
  }
  
  sub _decode_style {
      # No special prompt styles (yet)...
      return shift;
  }
  
  # Generate safe closure around active sub...
  sub _gen_wrapper_for {
      my ($arg) = @_;
      return ref $arg ne 'CODE'
             ? sub { $arg }
             : sub { eval { for (shift) { no warnings; return $arg->($_) // $_ } } };
  }
  
  # Create recognizer...
  my $STD_CONSTRAINT
      = '^(?:' . join('|', reverse sort keys %STD_CONSTRAINT) . ')';
  
  # Translate name constraints to implementations...
  sub _standardize_constraint {
      my ($option_type, $constraint_spec) = @_;
  
      return ("be an acceptable $option_type", $constraint_spec)
          if ref $constraint_spec;
  
      my @constraint_names = split /\s+/, $constraint_spec;
      my @constraints =
          map { $STD_CONSTRAINT{$_}
                // _opt_err('invalid',-$option_type,'"pos", "neg", "even", etc.')
              } @constraint_names;
  
      return (
          'be ' . join(' and ', @constraint_names),
          sub {
              my ($compare_val) = @_;
              for my $constraint (@constraints) {
                  return 0 if !$constraint->($compare_val);
              }
              return 1;
          }
      );
  }
  
  
  # Convert args to prompt + options hash...
  sub _decode_args {
      my %option = (
          -prompt    => undef,
          -complete  => $DEFAULT_COMPLETER,
          -must      => {},
          -history   => 'DEFAULT',
          -style     => sub{ q{} },
          -nostyle   => sub{ q{} },
          -echostyle => sub{ q{} },
          -echo      => sub { my $char = shift; $char eq "\t" ? q{ } : $char },
          -return    => sub { "\n" },
      );
  
      DECODING:
      while (defined(my $arg = shift @_)) {
          if (my $type = ref $arg) {
              _warn( reserved =>
                  'prompt(): Unexpected argument (' . lc($type) . ' ref) ignored'
              );
          }
          else {
              my $redo;
              given ($arg) {
                  # The sound of one hand clapping...
                  when (/^-_/) {
                      $redo = 1;
                  }
  
                  # Non-chomping option...
                  when (/^-line$/) {
                      $option{-line}++;
                  }
                  when (/^-l/) {
                      $option{-line}++;
                      $redo = 1;
                  }
  
                  # The -yesno variants...
                  when (/^-YesNo$/) {
                      my $count = @_ && looks_like_number($_[0]) ? shift @_ : 1;
                      $option{-yesno} = {
                          must => { '[YN]' => qr{\A \s* [YN] }xms },
                          count  => $count,
                      };
                  }
                  when (/^-YN/) {
                      $option{-yesno} = {
                          must => { '[YN]' => qr{\A \s* [YN] }xms },
                          count  => 1,
                      };
                      $redo = 2;
                  }
                  when (/^-yesno$/) {
                      my $count = @_ && looks_like_number($_[0]) ? shift @_ : 1;
                      $option{-yesno} = {
                          must => { '[yn]' => qr{\A \s* [YN] }ixms },
                          count  => $count,
                      };
                  }
                  when (/^-yn/) {
                      $option{-yesno} = {
                          must => { '[yn]' => qr{\A \s* [YN] }ixms },
                          count  => 1,
                      };
                      $redo = 2;
                  }
                  when (/^-Yes$/) {
                      my $count = @_ && looks_like_number($_[0]) ? shift @_ : 1;
                      $option{-yesno} = {
                          must => { '[Y for yes]' => qr{\A \s* (?: [^y] | \Z) }xms },
                          count  => $count,
                      };
                  }
                  when (/^-Y/) {
                      $option{-yesno} = {
                          must => { '[Y for yes]' => qr{\A \s* (?: [^y] | \Z) }xms },
                          count  => 1,
                      };
                      $redo = 1;
                  }
                  when (/^-yes$/) {
                      my $count = @_ && looks_like_number($_[0]) ? shift @_ : 1;
                      $option{-yesno} = { count  => $count };
                  }
                  when (/^-y/) {
                      $option{-yesno} = { count  => 1 };
                      $redo = 1;
                  }
  
                  # Load @ARGV...
                  when (/^-argv$/) {
                      $option{-argv} = 1;
                  }
  
                  when (/^-a/) {
                      $option{-argv} = 1;
                      $redo = 1;
                  }
  
                  # Clear screen before prompt...
                  state $already_wiped;
                  when (/^-wipe(first)?$/) {
                      $option{-wipe} = $1 ? !$already_wiped : 1;
                      $already_wiped = 1;
                  }
                  when (/^-w/) {
                      $option{-wipe} = 1;
                      $already_wiped = 1;
                      $redo = 1;
                  }
  
                  # Specify a failure condition...
                  when (/^-fail$/) {
                      _opt_err('Missing', -fail, 'failure condition') if !@_;
                      $option{-fail} = shift @_;
                  }
  
                  # Specify a file request...
                  when (/^-f(?:ilenames?)?$/) {
                      $option{-must}{'0: be an existing file'} = sub { -e $_[0] };
                      $option{-must}{'1: be readable'}         = sub { -r $_[0] };
                      $option{-complete}                       = 'filenames';
                  }
  
                  # Specify prompt echoing colour/style...
                  when (/^-style/) {
                      _opt_err('Missing -style specification') if !@_;
                      my $style = _decode_style(shift @_);
                      $option{-style} = _gen_wrapper_for($style);
                  }
  
                  # Specify input colour/style...
                  when (/^-echostyle/) {
                      _opt_err('Missing -echostyle specification') if !@_;
                      my $style = _decode_echostyle(shift @_);
                      $option{-echostyle} = _gen_wrapper_for($style);
                  }
  
  
                  # Specify input and output filehandles...
                  when (/^-stdio$/) { $option{-in}  = *STDIN;
                                     $option{-out} = *STDOUT;
                                    }
                  when (/^-in$/)    { $option{-in}  = shift @_; }
                  when (/^-out$/)   { $option{-out} = shift @_; }
  
                  # Specify integer and number return value...
                  when (/^-integer$/)       {
                      $option{-integer} = 1;
                      if (@_ && (ref $_[0] || $_[0] =~ $STD_CONSTRAINT)) {
                          my ($errmsg, $constraint)
                              = _standardize_constraint('integer',shift);
                          $option{-must}{$errmsg} = $constraint;
                      }
                  }
                  when (/^-num(?:ber)?$/)   {
                      $option{-number}  = 1;
                      if (@_ && (ref $_[0] || $_[0] =~ $STD_CONSTRAINT)) {
                          my ($errmsg, $constraint)
                              = _standardize_constraint('number',shift);
                          $option{-must}{$errmsg} = $constraint;
                      }
                  }
                  when (/^-i/)              { $option{-integer} = 1; $redo = 1; }
                  when (/^-n/)              { $option{-number}  = 1; $redo = 1; }
  
                  # Specify void context is okay...
                  when (/^-void$/)          { $option{-void} = 1;               }
  
                  # Specify verbatim return value...
                  when (/^-verb(?:atim)?$/) { $option{-verbatim} = 1;           }
                  when (/^-v/)              { $option{-verbatim} = 1; $redo = 1;}
  
                  # Specify single character return...
                  when (/^-sing(?:le)?$/)   { $option{-single} = 1;             }
                  when (/^-[s1]/)           { $option{-single} = 1; $redo = 1;  }
  
                  # Specify a default...
                  when (/^-DEF(?:AULT)?/) {
                      _opt_err('Missing', '-DEFAULT', 'string') if !@_;
                      $option{-def} = shift @_;
                      $option{-def_nocheck} = 1;
                      _opt_err('Invalid', '-DEFAULT', 'string')
                          if ref($option{-def});
                  }
                  when (/^-def(?:ault)?/) {
                      _opt_err('Missing', '-default', 'string') if !@_;
                      $option{-def} = shift @_;
                      _opt_err('Invalid', '-default', 'string')
                          if ref($option{-def});
                  }
                  when (/^-d(.+)$/)   { $option{-def} = $1; }
  
                  # Specify a timeout...
                  when (/^-t(\d+)/)   {
                      $option{-timeout} = $1;
                      $arg =~ s{\d+}{}xms;
                      $redo = 1;
                  }
                  when (/^-timeout$/) {
                      _opt_err('Missing', -timeout, 'number of seconds') if !@_;
                      $option{-timeout} = shift @_;
                      _opt_err('Invalid', -timeout,'number of seconds')
                          if !looks_like_number($option{-timeout});
                  }
  
                  # Specify a set of input constraints...
                  when (/^-g.*/) {
                      _opt_err('Missing', -guarantee, 'input restriction') if !@_;
                      my $restriction = shift @_;
                      my $restriction_type = ref $restriction;
  
                      $option{-must}{'be a valid input'} = $restriction;
  
                      # Hashes restrict input to their keys...
                      if ($restriction_type eq 'HASH') {
                          $restriction_type = 'ARRAY';
                          $restriction = [ keys %{$restriction} ];
                      }
                      # Arrays of strings matched (and completed) char-by-char...
                      if ($restriction_type eq 'ARRAY') {
                          my @restrictions = @{$restriction};
                          $option{-guarantee}
                              = '\A(?:'
                              . join('|', map {
                                    join(q{}, map { "(?:\Q$_\E" } split(q{}, $_))
                                  . ')?' x length($_)
                                } @restrictions)
                              . ')\z'
                              ;
                          if ($option{-complete} == $DEFAULT_COMPLETER) {
                              $option{-complete} = \@restrictions;
                          }
                      }
                      # Regexes matched as-is...
                      elsif ($restriction_type eq 'Regexp') {
                          $option{-guarantee} = $restriction;
                      }
                      else {
                          _opt_err( 'Invalid', -guarantee,
                                    'array or hash reference, or regex'
                          );
                      }
                  }
  
                  # Specify a set of key letters...
                  when ('-keyletters_implement') {
                      # Extract all keys and default keys...
                      my @keys  = ($option{-prompt} =~ m{$KL_EXTRACT}gxms);
  
                      # Convert default to a -default...
                      my @defaults = ($option{-prompt} =~ m{$KL_DEF_EXTRACT}gxms);
                      if (@defaults > 1) {
                          _warn( ambiguous =>
                              "prompt(): -keyletters found too many defaults"
                          )
                      }
                      elsif (@defaults) {
                          push @_, -default => $defaults[0];
                      }
  
                      # Convert key letters to a -guarantee...
                      @keys = ( map({uc} @keys), map({lc} @keys) );
                      if (@defaults == 1) {
                          push @keys, q{};
                      }
                      push @_, -guarantee => \@keys;
  
                  }
                  when (/^-key(?:let(?:ter)?)(?:s)?/) {
                      push @_, '-keyletters_implement';
                  }
                  when (/^-k/) {
                      push @_, '-keyletters_implement';
                      $redo = 1;
                  }
  
                  # Specify a set of return constraints...
                  when (/^-must$/) {
                      _opt_err('Missing', -must, 'constraint hash') if !@_;
                      my $must = shift @_;
                      _opt_err('Invalid', -must, 'hash reference')
                          if ref($must) ne 'HASH';
                      for my $errmsg (keys %{$must}) {
                          $option{-must}{$errmsg} = $must->{$errmsg};
                      }
                  }
  
                  # Specify a history set...
                  when (/^-history/) {
                      $option{-history}
                          = @_ && $_[0] !~ /^-/ ? shift @_
                          :                       undef;
                      _opt_err('Invalid', -history, 'history set name')
                          if ref($option{-history});
                  }
                  when (/^-h(.*)/)   { $option{-history} = length($1) ? $1 : undef; }
  
                  # Specify completions...
                  when (/^-comp(?:lete)?/) {
                      _opt_err('Missing', -complete, 'completions') if !@_;
                      my $comp_spec = shift @_;
                      my $comp_type = ref($comp_spec) || $comp_spec || '???';
                      if ($comp_type =~ m{\A(?: file\w* | dir\w* | ARRAY | HASH | CODE )\Z}xms) {
                          $option{-complete} = $comp_spec;
                      }
                      else {
                          _opt_err( 'Invalid', -complete,
                                      '"filenames", "dirnames", or reference to array, hash, or subroutine');
                      }
                  }
  
                  # Specify what to echo when a character is keyed...
                  when (/^-(echo|ret(?:urn)?)$/) {
                      my $flag = $1 eq 'echo' ? '-echo' : '-return';
                      if ($flag eq '-echo' && !eval { no warnings 'deprecated'; require Term::ReadKey }) {
                          _warn( bareword => "Warning: next input will be in plaintext\n");
                      }
                      my $arg = @_ && $_[0] !~ /^-/ ? shift(@_)
                              : $flag eq '-echo'    ? q{}
                              :                       qq{\n};
                      $option{$flag} = _gen_wrapper_for(_decode_echo($arg));
                  }
                  when (/^-e(.*)/) {
                      if (!eval { no warnings 'deprecated'; require Term::ReadKey }) {
                          _warn( bareword => "Warning: next input will be in plaintext\n");
                      }
                      my $arg = $1;
                      $option{-echo} = _gen_wrapper_for(_decode_echo($arg));
                  }
                  when (/^-r(.+)/) {
                      my $arg = $1;
                      $option{-return} = _gen_wrapper_for(_decode_echo($arg));
                  }
                  when (/^-r/) {
                      $option{-return} = sub{ "\n" };
                  }
  
                  # Explicit prompt replaces implicit prompts...
                  when (/^-prompt$/) {
                      _opt_err('Missing', '-prompt', 'prompt string') if !@_;
                      $option{-prompt} = shift @_;
                      _opt_err('Invalid', '-prompt', 'string')
                          if ref($option{-prompt});
                  }
                  when (/^-p(\S*)$/) {
                      $option{-prompt} = $1;
                  }
  
                  # Menus inject a placeholder in the prompt string...
                  when (/^-menu$/) {
                      _opt_err('Missing', '-menu', 'menu specification') if !@_;
                      $option{-menu}         = ref $_[0] ? shift(@_) : \shift(@_);
                      $option{-prompt}      .= $MENU_MK;
                      $option{-def_nocheck}  = 1;
                  }
  
                  # Anything else of the form '-...' is a misspelt option...
                  when (/^-\w+$/) { _warn(misc => "prompt(): Unknown option $arg ignored"); }
  
                  # Anything else is part fo the prompt...
                  default       { $option{-prompt} .= $arg; }
              }
  
              # Handle option bundling...
              redo DECODING if $redo && $arg =~ s{\A -.{$redo} (?=.)}{-}xms;
          }
      }
  
      # Precompute top-level menu, if menuing...
      if (exists $option{-menu}) {
          $option{-menu} = _build_menu($option{-menu},
                                       undef,
                                       $option{-number}||$option{-integer}
                           );
      }
  
      # Handle return magic on -single...
      if (defined $option{-single} && length($option{-echo}('X')//'echoself')) {
          $option{-return} //= sub{ "\n" };
      }
  
      # Adjust prompt as necessary...
      if ($option{-argv}) {
          my $progname = $option{-prompt} // $0;
          $progname =~ s{^.*/}{}xms;
  
          my $HINT = '[enter command line args here]';
          $option{-prompt} = "> $progname  $HINT\r> $progname ";
  
          $option{-complete} = 'filenames';
  
          my $not_first;
          $option{-echo}   = sub{
              my $char = shift;
              $option{-prompt} = "> $progname ";  # Sneaky resetting to handle completions
              return $char if $not_first++;
              return "\r> $progname  " . (q{ } x length $HINT) . "\r> $progname $char";
          }
      }
      elsif (!defined $option{-prompt}) {
          $option{-prompt} = '> ';
      }
      elsif ($option{-prompt} =~ m{ \S \z}xms) {
          # If prompt doesn't end in whitespace, make it so...
          $option{-prompt} .= ' ';
      }
      elsif ($option{-prompt} =~ m{ (.*) \n \z}xms) {
          # If prompt ends in a newline, remove it...
          $option{-prompt} = $1;
      }
  
      # Steal history set name if -h given without a specification...
      $option{-history} //= $option{-prompt};
  
      # Verify any default satisfies any constraints...
      if (exists $option{-def} && !$option{-def_nocheck}) {
          if (!_verify_input_constraints(\q{},undef,undef,\%option)) {
              _warn( misc =>
                  'prompt(): -default value does not satisfy -must constraints'
              );
          }
      }
  
      return \%option;
  }
  
  #====[ Error Handlers ]=========================================
  
  sub _opt_err {
      my ($problem, $option, $expectation) = @_;
      Carp::croak "prompt(): $problem value for $option (expected $expectation)";
  }
  
  sub _warn {
      my ($category, @message) = @_;
  
      return if !warnings::enabled($category);
  
      my $message = join(q{},@message);
      warn $message =~ /\n$/ ? $message : Carp::shortmess($message);
  }
  
  
  #====[ Utility subroutines ]====================================
  
  # Return the *ARGV filehandle, "magic-opening" it if necessary...
  sub _open_ARGV {
      if (!openhandle \*ARGV) {
          $ARGV = shift @ARGV // '-';
          open *ARGV or Carp::croak(qq{prompt(): Can't open *ARGV: $!});
      }
      return \*ARGV;
  }
  
  my $INTEGER_PAT = qr{ \A \s*+ [+-]?+ \d++ (?: [Ee] \+? \d+ )? \s*+ \Z }xms;
  
  my $NUMBER_PAT  = qr{
      \A \s*+ [+-]?+
      (?:
          \d++ (?: [.,] \d*+ )?
      |   [.,] \d++
      )
      (?: [eE] [+-]?+ \d++ )?
      \s*+ \Z
  }xms;
  
  # Verify interactive constraints...
  sub _verify_input_constraints {
      my ($input_ref, $local_fake_input_ref, $outputter_ref, $opt_ref, $extras)
          = @_;
  
      # Use default if appropriate (but short-circuit checks if -DEFAULT set)...
      my $input = ${$input_ref};
      if (${$input_ref} =~ m{^\R?$}xms && exists $opt_ref->{-def}) {
          return 1 if $opt_ref->{-def_nocheck};
          $input = $opt_ref->{-def}
      }
      chomp $input;
  
      my $failed;
      # Integer constraint is hard-coded...
      if ($opt_ref->{-integer} && $input !~ $INTEGER_PAT) {
          $failed = $opt_ref->{-prompt} . "(must be an integer) ";
      }
  
      # Numeric constraint is hard-coded...
      if (!$failed && $opt_ref->{-number} && $input !~ $NUMBER_PAT) {
          $failed = $opt_ref->{-prompt} . "(must be a number) ";
      }
  
      # Sort and clean up -must list...
      my $must_ref = $opt_ref->{-must} // {};
      my @must_keys     = sort keys %{$must_ref};
      my %clean_key_for = map { $_ => (/^\d+[.:]?\s*(.*)/s ? $1 : $_) } @must_keys;
      my @must_kv_list  = map { $clean_key_for{$_} => $must_ref->{$_} } @must_keys;
  
      # Combine -yesno and -must constraints...
      my %constraint_for = (
          %{ $extras // {} },
          %{ $opt_ref->{-yesno}{must} // {} },
          @must_kv_list,
      );
      my @constraints = (
          keys %{ $extras // {} },
          keys %{ $opt_ref->{-yesno}{must} // {} },
          @clean_key_for{@must_keys},
      );
  
      # User-specified constraints...
      if (!$failed && keys %constraint_for) {
          CONSTRAINT:
          for my $msg (@constraints) {
              my $constraint = $constraint_for{$msg};
              next CONSTRAINT if eval { no warnings; local $_ = $input; $input ~~ $constraint; };
              $failed = $msg =~ m{\A [[:upper:]] }xms ? "$msg "
                      : $msg =~ m{\A \W }xms          ? $opt_ref->{-prompt}
                                                      . "$msg "
                      :                                 $opt_ref->{-prompt}
                                                      . "(must $msg) "
                      ;
              last CONSTRAINT;
          }
      }
  
      # If any constraint not satisfied...
      if ($failed) {
          # Return failure if not actually prompting at the moment...
          return 0 if !$outputter_ref;
  
          # Redraw post-menu prompt with failure message appended...
          $failed =~ s{.*$MENU_MK}{}xms;
          $outputter_ref->(-style => _wipe_line(), $failed);
  
          # Reset input collector...
          ${$input_ref}  = q{};
  
          # Reset faked input, if any...
          if (defined $fake_input && length($fake_input) > 0) {
              $fake_input =~ s{ \A (.*) \R? }{}xm;
              ${$local_fake_input_ref} = $1;
          }
  
          no warnings 'exiting';
          next INPUT;
      }
  
      # Otherwise succeed...
      return 1;
  }
  
  # Build a sub to read from specified filehandle, with or without timeout...
  sub _generate_buffered_reader_from {
      my ($in_fh, $outputter_ref, $opt_ref) = @_;
  
      # Set-up for timeouts...
      my $fileno      = fileno($in_fh) // -1;
      my $has_timeout = exists $opt_ref->{-timeout} && $fileno >= 0;
      my $timeout     = $opt_ref->{-timeout};
      my $readbits    = q{};
      if ($has_timeout && $fileno >= 0) {
          vec($readbits,$fileno,1) = 1;
      }
  
      # Set up local faked input, if any...
      my $local_fake_input;
      my $orig_fake_input;
      if (defined $fake_input && length($fake_input) > 0) {
          $fake_input =~ s{ \A (.*) \R? }{}xm;
          $orig_fake_input = $local_fake_input = $1;
      }
  
      return sub {
          my ($extra_constraints) = @_;
  
          INPUT:
          while (1) {
              if (!$has_timeout || select $readbits, undef, undef, $timeout) {
                  my $input;
  
                  # Real input comes from real filehandles...
                  if (!defined $local_fake_input) {
                      $input = readline $in_fh;
                  }
                  # Fake input has to be typed...
                  else {
                      $input = $local_fake_input;
                      sleep 1;
                      for ($local_fake_input =~ m/\X/g) {
                          _simulate_typing();
                          $outputter_ref->(-echostyle => $opt_ref->{-echo}($_));
                      }
                      readline $in_fh;
  
                      # Check for simulated EOF...
                      if ($input =~ m{^ \s* (?: \cD | \cZ ) }xms) {
                          $input = undef;
                      }
                  }
  
                  if (defined $input) {
                      _verify_input_constraints(
                          \$input, \$local_fake_input, $outputter_ref, $opt_ref, $extra_constraints
                      );
                  }
  
                  return defined $input && $opt_ref->{-single}
                              ? substr($input, 0, 1)
                              : $input;
              }
              else {
                  return;
              }
          }
      }
  }
  
  sub _autoflush {
      my ($fh) = @_;
      my $prev_selected = select $fh;
      $| = 1;
      select $prev_selected;
      return;
  }
  
  sub _simulate_typing {
      state $TYPING_SPEED = 0.07; # seconds per character
      select undef, undef, undef, rand $TYPING_SPEED;
  }
  
  sub _term_width {
      my ($term_width) = eval { no warnings 'deprecated'; Term::ReadKey::GetTerminalSize(\*STDERR) };
      return $term_width // $DEFAULT_TERM_WIDTH;
  }
  
  sub _wipe_line {
      return qq{\r} . q{ } x (_term_width()-1) . qq{\r};
  }
  
  # Convert a specification into a list of possible completions...
  sub _current_completions_for {
      my ($input_text, $opt_ref) = @_;
      my $completer = $opt_ref->{-complete};
  
      # Isolate the final whitespace-separated word...
      my ($prefix, $lastword)
          = $input_text =~ m{
              (?| ^ (.*\s+) (.*)
                | ^ ()      (.*)
              )
            }xms;
  
      # Find candidates...
      my @candidates;
      given (ref($completer) || $completer // q{}) {
          # If completer is sub, recursively call it with input words...
          when ('CODE') {
              ($prefix, @candidates)
                  = _current_completions_for(
                      $input_text,
                      { %{$opt_ref},
                        -complete => $completer->(split /\s+/, $input_text, -1)
                      }
                    );
          }
  
          # If completer is array, grep the appropriate elements...
          when ('ARRAY') {
              @candidates = grep { /\A\Q$lastword\E/ } @{$completer};
          }
  
          # If completer is hash, grep the appropriate keys...
          when ('HASH') {
              @candidates = grep { /\A\Q$lastword\E/ } keys %{$completer};
          }
  
          # If completer is 'file...', glob up the appropriate filenames...
          when (/^file\w*$/) {
              @candidates = glob($lastword.'*');
          }
  
          # If completer is 'dir...', glob up the appropriate directories...
          when (/^dir\w*$/) {
              @candidates = grep {-d} glob($lastword.'*');
          }
      }
  
      chomp @candidates;
      return ($prefix, @candidates);
  }
  
  
  sub _current_history_for {
      my ($prefix, $opt_ref) = @_;
  
      my $prefix_len = length($prefix);
      return q{}, map { /\A (.*?) \R \Z/x ? $1 : $_ }
                 grep { substr($_,0,$prefix_len) eq $prefix }
                      @{ $history_cache{$opt_ref->{-history}} };
  }
  
  sub _longest_common_prefix_for {
      my $prefix = shift @_;
      for my $comparison (@_) {
          ($comparison ^ $prefix) =~ m{ \A (\0*) }xms;
          my $common_length = length($1);
          return q{} if !$common_length;
          $prefix = substr($prefix, 0, $common_length);
      }
      return $prefix;
  }
  
  sub _display_completions {
      my ($input, @candidates) = @_;
  
      return q{} if @candidates <= 1;
  
      # How big is each field in the table?
      my $field_width
          = _term_width() / $COMPLETE_DISPLAY_FIELDS - $COMPLETE_DISPLAY_GAP;
  
      # Crop the possibilities intelligently to that width...
      for my $candidate (@candidates) {
          substr($candidate, 0, length($input)) =~ s{ \A .* [/\\] }{}xms;
          $candidate
              = sprintf "%-*s", $field_width, substr($candidate,0,$field_width);
      }
  
      # Collect them into rows...
      my $display = "\n";
      my $gap     = q{ } x $COMPLETE_DISPLAY_GAP;
      while (@candidates) {
          $display .= $gap
                    . join($gap, splice(@candidates, 0, $COMPLETE_DISPLAY_FIELDS))
                    . "\n";
      }
  
      return $display;
  }
  
  sub _generate_unbuffered_reader_from {
      my ($in_fh, $outputter_ref, $opt_ref) = @_;
  
      my $has_readkey = eval { no warnings 'deprecated'; require Term::ReadKey };
  
      # If no per-character reads, fall back on buffered input...
      if (!-t $in_fh || !$has_readkey) {
          return _generate_buffered_reader_from($in_fh, $outputter_ref, $opt_ref);
      }
  
      # Adapt to local control characters...
      my %ctrl = eval { Term::ReadKey::GetControlChars($in_fh) };
      delete $ctrl{$_} for grep { $ctrl{$_} eq "\cA" } keys %ctrl;
  
      $ctrl{EOF}       //= "\4";
      $ctrl{INTERRUPT} //= "\3";
      $ctrl{ERASE}     //= $^O eq 'MSWin32' ? "\10" : "0177";
  
      my $ctrl           = join '|', values %ctrl;
  
      my $VERBATIM_KEY = $ctrl{QUOTENEXT} // $DEFAULT_VERBATIM_KEY;
  
      # Translate timeout for ReadKey (with 32-bit MAXINT workaround for Windows)...
      my $timeout = !defined $opt_ref->{-timeout} ? 0x7FFFFFFF    # 68 years
                  : $opt_ref->{-timeout} == 0     ? -1
                  :                                 $opt_ref->{-timeout}
                  ;
  
      return sub {
          my ($extra_constraints) = @_;
  
          # Short-circuit on unreadable filehandle...
          return if !openhandle($in_fh);
  
          # Set up direct reading, and prepare to clean up on abnormal exit...
          Term::ReadKey::ReadMode('raw', $in_fh);
          my $prev_SIGINT = $SIG{INT};
          local $SIG{INT} = sub { given ($prev_SIGINT) {
                                      when ('IGNORE')  { }
                                      Term::ReadKey::ReadMode('restore', $in_fh);
                                      when ('DEFAULT') { exit(1) }
                                      when (undef)     { exit(1) }
                                      default {
                                          package main;
                                          no strict 'refs';
                                          $prev_SIGINT->()
                                      }
                                  }
                            };
  
          # Set up local faked input, if any...
          my $local_fake_input;
          my $orig_fake_input;
          if (defined $fake_input && length($fake_input) > 0) {
              $fake_input =~ s{ \A (.*) \R? }{}xm;
              $orig_fake_input = $local_fake_input = $1;
          }
  
          my $input = q{};
          my $insert_offset = 0;
          INPUT:
          while (1) {
              state $prev_was_verbatim = 0;
              state $completion_level  = 0;
              state $completion_type   = q{};
  
              # Get next character entered...
              my $next = Term::ReadKey::ReadKey($timeout, $in_fh);
  
              # Finished with completion mode?
              if (($next//q{}) !~ m{ $COMPLETE_INIT | $COMPLETE_CYCLE }xms) {
                  $completion_level = 0;
                  $completion_type = q{};
              }
  
              # Are we faking input?
              my $faking = defined $local_fake_input;
  
              # If not EOF...
              if (defined $next) {
                  # Remember where we were parked...
                  my $prev_insert_offset = $insert_offset;
  
                  # Handle interrupts...
                  if ($next eq $ctrl{INTERRUPT}) {
                      $SIG{INT}();
                      next INPUT;
                  }
  
                  # Handle verbatim quoter...
                  elsif (!$prev_was_verbatim && $next eq $VERBATIM_KEY) {
                      $prev_was_verbatim = 1;
                      next INPUT;
                  }
  
                  # Handle completions...
                  elsif (!$prev_was_verbatim
                         && ( $next =~ $COMPLETE_INIT
                           || $completion_level > 0 && $next =~ $COMPLETE_CYCLE
                         )
                  ) {
                      state @completion_list;  # ...all candidates for completion
                      state @completion_ring;  # ..."next" candidate cycle
                      state $completion_ring_first;  # ...special case first time
                      state $completion_prefix;      # ...skipped before completing
  
                      # Track completion type and level (switch if necessary)...
                      if ($next =~ $COMPLETE_INIT && index($completion_type, $next) < 0) {
                          $completion_type = index($COMPLETE_KEY, $next) >= 0 ? $COMPLETE_KEY : $COMPLETE_HIST;
                          $completion_level = 1;
                      }
                      else {
                          $completion_level++;
                      }
  
                      # If starting completion, cache completions...
                      if ($completion_level == 1) {
                          ($completion_prefix, @completion_list)
                             = index($COMPLETE_KEY, $next) >= 0
                                  ? _current_completions_for($input, $opt_ref)
                                  : _current_history_for($input, $opt_ref);
                          @completion_ring = (@completion_list, q{});
                          $completion_ring_first = 1;
                      }
  
                      # Can only complete if there are completions to be had...
                      if (@completion_list) {
                          # Select the appropriate mode...
                          my $mode = $COMPLETE_MODE{$completion_type}[$completion_level-1]
                                  // $COMPLETE_MODE{$completion_type}[-1];
  
                          # 'longest mode' finds longest consistent prefix...
                          if ($mode =~ /longest/) {
                              $input
                                  = $completion_prefix
                                  . _longest_common_prefix_for(@completion_list);
                          }
                          # 'full mode' suggests next full match...
                          elsif ($mode =~ /full/) {
                              if (!$completion_ring_first) {
                                  if ($next eq $COMPLETE_PREV) {
                                      unshift @completion_ring,
                                              pop @completion_ring;
                                  }
                                  else {
                                      push @completion_ring,
                                           shift @completion_ring;
                                  }
                              }
                              $input = $completion_prefix . $completion_ring[0];
                              $completion_ring_first = 0;
                          }
                          # 'list mode' lists all possibilities...
                          my $list_display = $mode =~ /list/
                              ? _display_completions($input, @completion_list)
                              : q{};
  
                          # Update prompt with selected completion...
                          $outputter_ref->( -style =>
                              $list_display,
                              _wipe_line(),
                              $opt_ref->{-prompt}, $input
                          );
  
                          # If last completion was unique choice, completed...
                          if (@completion_list <= 1) {
                              $completion_level = 0;
                          }
                      }
                      next INPUT;
                  }
  
                  # Handle erasures (including pushbacks if faking)...
                  elsif (!$prev_was_verbatim && $next eq $ctrl{ERASE}) {
                      if (!length $input) {
                          # Do nothing...
                      }
                      elsif ($insert_offset) {
                          # Can't erase past start of input...
                          next INPUT if $insert_offset >= length($input);
  
                          # Erase character just before cursor...
                          substr($input, -$insert_offset-1, 1, q{});
  
                          # Redraw...
                          my $input_pre  = substr($input.' ',0,length($input)-$insert_offset+1);
                          my $input_post = substr($input.' ',length($input)-$insert_offset);
                          my $display_pre 
                              = join q{}, map { $opt_ref->{-echo}($_) } $input_pre =~ m/\X/g;
                          my $display_post
                              = join q{}, map { $opt_ref->{-echo}($_) } $input_post =~ m/\X/g;
                          $outputter_ref->( -echostyle =>
                                "\b" x length($display_pre)
                              . join(q{}, map { $opt_ref->{-echo}($_) } $input =~ m/\X/g)
                              . q{ } x length($opt_ref->{-echo}(q{ }))
                              . "\b" x length($display_post)
                          );
                      }
                      else {
                          my $erased = substr($input, -1, 1, q{});
                          if ($faking) {
                              substr($local_fake_input,0,0,$erased);
                          }
                          $outputter_ref->( -nostyle =>
                              map { $_ x (length($opt_ref->{-echo}($_)//'X')) }
                                  "\b", ' ', "\b"
                          );
                      }
                      next INPUT;
                  }
  
                  # Handle EOF (including cancelling any remaining fake input)...
                  elsif (!$prev_was_verbatim && $next eq $ctrl{EOF}) {
                      Term::ReadKey::ReadMode('restore', $in_fh);
                      close $in_fh;
                      undef $fake_input;
                      return length($input) ? $input : undef;
                  }
  
                  # Handle escape from faking...
                  elsif (!$prev_was_verbatim && $faking && $next eq $FAKE_ESC) {
                      my $lookahead = Term::ReadKey::ReadKey(0, $in_fh);
  
                      # Two <ESC> implies the current faked line is deferred...
                      if ($lookahead eq $FAKE_ESC) {
                          $fake_input =~ s{ \A }{$orig_fake_input\n}xm;
                      }
                      # Only one <ESC> implies the current faked line is replaced...
                      else {
                          $in_fh->ungetc(ord($lookahead));
                      }
                      undef $local_fake_input;
                      $faking = 0;
                      next INPUT;
                  }
  
                  # Handle returns...
                  elsif (!$prev_was_verbatim && $next =~ /\A\R\z/) {
                      # Complete faked line, if faked input incomplete...
                      if ($faking && length($local_fake_input)) {
                          for ($local_fake_input =~ m/\X/g) {
                              _simulate_typing();
                              $outputter_ref->(-echostyle => $opt_ref->{-echo}($_));
                          }
                          $input .= $local_fake_input;
                      }
  
                      # Add newline to the accumulated input string...
                      $input .= $next;
  
                      # Check that input satisfied any constraints...
                      _verify_input_constraints(
                          \$input, \$local_fake_input, $outputter_ref,
                          $opt_ref, $extra_constraints,
                      );
  
                      # Echo a default value if appropriate...
                      if ($input =~ m{\A\R?\Z}xms && defined $opt_ref->{-def}) {
                          my $def_val = $opt_ref->{-def};
  
                          # Try to find the key, for a menu...
                          if (exists $opt_ref->{-menu_curr_level}) {
                              for my $key ( keys %{$opt_ref->{-menu_curr_level}}) {
                                  if ($def_val ~~ $opt_ref->{-menu_curr_level}{$key}) {
                                      $def_val = $key;
                                      last;
                                  }
                              }
                          }
  
                          # Echo it as if it had been typed...
                          $outputter_ref->(-echostyle => $opt_ref->{-echo}($def_val));
                      }
  
                      # Echo the return (or otherwise, as specified)...
                      $outputter_ref->(-echostyle => $opt_ref->{-return}($next));
  
                      # Clean up, and return the input...
                      Term::ReadKey::ReadMode('restore', $in_fh);
  
                      # Handle fake EOF...
                      if ($faking && $input =~ m{^ (?: \cD | \cZ) }xms) {
                          return undef;
                      }
  
                      return $input;
                  }
  
                  # Handle anything else...
                  elsif ($prev_was_verbatim || $next !~ /$ctrl/) {
                      # If so, get the next fake character...
                      if ($faking) {
                          $next = length($local_fake_input)
                                      ? substr($local_fake_input,0,1,q{})
                                      : q{};
                      }
  
                      # Handle editing...
                      if ($next eq $EDIT{BACK}) {
                          $insert_offset += ($insert_offset < length $input) ? 1 : 0;
                      }
                      elsif ($next eq $EDIT{FORWARD}) {
                          $insert_offset += ($insert_offset > 0) ? -1 : 0;
                      }
                      elsif ($next eq $EDIT{START}) {
                          $insert_offset = length($input);
                      }
                      elsif ($next eq $EDIT{END}) {
                          $insert_offset = 0;
                      }
  
                      # Handle non-editing...
                      else {
                          # Check for input restrictions...
                          if (exists $opt_ref->{-guarantee}) {
                              next INPUT if ($input.$next) !~ $opt_ref->{-guarantee};
                          }
  
                          # Add the new input char to the accumulated input string...
                          if ($insert_offset) {
                              substr($input, -$insert_offset, 0) = $next;
                              $prev_insert_offset++;
                          }
                          else {
                              $input .= $next;
                          }
                      }
  
                      # Display the character (or whatever was specified)...
  
                      if ($insert_offset || $prev_insert_offset) {
                          my $input_pre  = substr($input,0,length($input)-$prev_insert_offset);
                          my $input_post = substr($input,length($input)-$insert_offset);
                          my $display_pre 
                              = join q{}, map { $opt_ref->{-echo}($_) } $input_pre =~ m/\X/g;
                          my $display_post
                              = join q{}, map { $opt_ref->{-echo}($_) } $input_post =~ m/\X/g;
                          $outputter_ref->( -echostyle =>
                                "\b" x length($display_pre)
                              . join(q{}, map { $opt_ref->{-echo}($_) } $input =~ m/\X/g)
                              . "\b" x length($display_post)
                          );
                      }
                      elsif ($next !~ $EDIT_KEY) {
                          $outputter_ref->(-echostyle => $opt_ref->{-echo}($next));
                      }
  
                      # Not verbatim after this...
                      $prev_was_verbatim = 0;
                  }
                  else {
                      # Not verbatim after mysterious ctrl input...
                      $prev_was_verbatim = 0;
  
                      next INPUT;
                  }
              }
              if ($opt_ref->{-single} || !defined $next || $input =~ m{\Q$/\E$}) {
                  # Did we get an acceptable value?
                  if (defined $next) {
                      _verify_input_constraints(
                         \$input, \$local_fake_input, $outputter_ref,
                         $opt_ref, $extra_constraints,
                      );
                  }
  
                  # Reset terminal...
                  Term::ReadKey::ReadMode('restore', $in_fh);
  
                  # Return failure if failed before input...
                  return undef if !defined $next && length($input) == 0;
  
                  # Otherwise supply a final newline if necessary...
                  if ( $opt_ref->{-single}
                  &&   exists $opt_ref->{-return}
                  &&   $input !~ /\A\R\z/ ) {
                      $outputter_ref->(-echostyle => $opt_ref->{-return}(q{}));
                  }
  
                  return $input;
              }
          }
      }
  }
  
  # Build a menu...
  sub _build_menu {
      my ($source_ref, $initial_prompt, $is_numeric) = @_;
      my $prompt = ($initial_prompt//q{}) . qq{\n};
      my $final = q{};
      my %value_for;
      my %key_for;
      my @selectors;
  
      given (ref $source_ref) {
          when ('HASH') {
              my @sorted_keys = sort(keys(%{$source_ref}));
              @selectors = $is_numeric ? (1..@sorted_keys) : ('a'..'z','A'..'Z');
              @key_for{@selectors}   = @sorted_keys;
              @value_for{@selectors} = @{$source_ref}{@sorted_keys};
              $source_ref = \@sorted_keys;
              $_ = 'ARRAY';
              continue;
          }
          when ('SCALAR') {
              $source_ref = [ split "\n", ${$source_ref} ];
              $_ = 'ARRAY';
              continue;
          }
          when ('ARRAY') {
              my @source = @{$source_ref};
              @selectors = $is_numeric ? (1..@source) : ('a'..'z','A'..'Z');
              if (!keys %value_for) {
                  @value_for{@selectors} = @source;
              }
              ITEM:
              for my $tag (@selectors) {
                  my $item = shift(@source) // last ITEM;
                  chomp $item;
                  $prompt .= sprintf("%4s. $item\n", $tag);
                  $final = $tag;
              }
              if (@source) {
                  _warn( misc =>
                      "prompt(): Too many menu items. Ignoring the final " . @source
                  );
              }
          }
      }
  
      my $constraint = $is_numeric       ? '(?:' . join('|',@selectors) .')'
                     : $final =~ /[A-Z]/ ? "[a-zA-$final]"
                     :                     "[a-$final]";
      my $constraint_desc = $is_numeric  ? "[1-$selectors[-1]]" : $constraint;
      $constraint = '\A\s*' . $constraint . '\s*\Z';
  
      return {
          data       => $source_ref,
          key_for    => \%key_for,
          value_for  => \%value_for,
          prompt     => "$prompt\n",
          is_numeric => $is_numeric,
          constraint => { "Enter $constraint_desc: " => qr/$constraint|$MENU_ESC/ },
      };
  }
  
  # Vocabulary that _stylize understands...
  my %synonyms = (
      bold      => [qw<boldly strong heavy emphasis emphatic highlight highlighted fort forte>],
      dark      => [qw<darkly dim deep>],
      faint     => [qw<faintly light soft>],
      underline => [qw<underlined underscore underscored italic italics>],
      blink     => [qw<blinking flicker flickering flash flashing>],
      reverse   => [qw<reversed inverse inverted>],
      concealed => [qw<hidden blank invisible>],
      reset     => [qw<normal default standard usual ordinary regular>],
      bright_   => [qw< bright\s+ vivid\s+ >],
      red       => [qw< scarlet vermilion crimson ruby cherry cerise cardinal carmine
                        burgundy claret chestnut copper garnet geranium russet
                        salmon titian coral cochineal rose cinnamon ginger gules >],
      yellow    => [qw< gold golden lemon cadmium daffodil mustard primrose tawny
                        amber aureate canary champagne citrine citron cream goldenrod honey straw >],
      green     => [qw< olive jade pea emerald lime chartreuse forest sage vert >],
      cyan      => [qw< aqua aquamarine teal turquoise ultramarine >],
      blue      => [qw< azure cerulean cobalt indigo navy sapphire >],
      magenta   => [qw< amaranthine amethyst lavender lilac mauve mulberry orchid periwinkle
                        plum pomegranate violet purple aubergine cyclamen fuchsia modena puce
                        purpure >],
      black     => [qw< charcoal ebon ebony jet obsidian onyx raven sable slate >],
      white     => [qw< alabaster ash chalk ivory milk pearl silver argent >],
  );
  
  # Back-mapping to standard terms...
  my %normalize
      = map { join('|', map { "$_\\b" } reverse sort @{$synonyms{$_}}) => $_ }
            keys %synonyms;
  
  my $BACKGROUND = qr{
       (\S+) \s+ (?: behind | beneath | below | under(?:neath)? )\b
     | \b (?:upon|over|on) \s+ (?:an?)? \s+ (.*?) \s+ (?:background|bg|field) \b
     | \b (?:upon\s+ | over\s+ | (?:(on|upon|over)\s+a\s+)?  (?:background|bg|field) \s+ (?:of\s+|in\s+)? | on\s+) (\S+)
  }ixms;
  
  # Convert a description to ANSI colour codes...
  sub _stylize {
      my $spec = shift // q{};
  
      # Handle arrays and hashes as args...
      if (ref($spec) eq 'ARRAY') {
          $spec = join q{ }, @{$spec};
      }
      elsif (ref($spec) eq 'HASH') {
          $spec = join q{ }, keys %{$spec};
      }
  
      # Ignore punctuation...
      $spec =~ s/[^\w\s]//g;
  
      # Handle backgrounds...
      $spec =~ s/$BACKGROUND/on_$+/g;
  
      # Apply standard translations...
      for my $pattern (keys %normalize) {
          $spec =~ s{\b(on_|\b) $pattern}{($1//q{}).$normalize{$pattern}}geixms;
      }
  
      # Ignore anything unknown...
      $spec =~ s{((?:on_)?(\S+))}{ exists $synonyms{$2} ? $1 : q{} }gxmse;
  
      # Build ANSI terminal codes around text...
      my $raw_text = join q{}, @_;
      my ($prews, $text, $postws) = $raw_text =~ m{\A (\s*) (.*?) (\s*) \Z}xms;
      my @style = split /\s+/, $spec;
      return $prews
           . ( @style ? Term::ANSIColor::colored(\@style, $text) : $text )
           . $postws;
  }
  
  # Build a subroutine that prints printable chars to the specified filehandle...
  sub _std_printer_to {
      my ($out_filehandle, $opt_ref) = @_;
      no strict 'refs';
      _autoflush($out_filehandle);
      if (eval { require Term::ANSIColor}) {
          return sub {
              my $style = shift;
              my @loc = (@_);
              s{\e}{^}gxms for @loc;
              print {$out_filehandle} _stylize($opt_ref->{$style}(@loc), @loc);
          };
      }
      else {
          return sub {
              shift; # ...ignore style
              my @loc = (@_);
              s{\e}{^}gxms for @loc;
              print {$out_filehandle} @loc;
          };
      }
  }
  
  # Build a subroutine that prints to nowhere...
  sub _null_printer {
      return sub {};
  }
  
  1; # Magic true value required at end of module
  __END__
  
  =head1 NAME
  
  IO::Prompter - Prompt for input, read it, clean it, return it.
  
  
  =head1 VERSION
  
  This document describes IO::Prompter version 0.004015
  
  
  =head1 SYNOPSIS
  
      use IO::Prompter;
  
      while (prompt -num, 'Enter a number') {
          say "You entered: $_";
      }
  
      my $passwd
          = prompt 'Enter your password', -echo=>'*';
  
      my $selection
          = prompt 'Choose wisely...', -menu => {
                  wealth => [ 'moderate', 'vast', 'incalculable' ],
                  health => [ 'hale', 'hearty', 'rude' ],
                  wisdom => [ 'cosmic', 'folk' ],
            }, '>';
  
  
  =head1 CAVEATS
  
  =over
  
  =item 1.
  
  Several features of this module are known to have problems under
  Windows. If using that platform, you may have more success
  (and less distress) by trying IO::Prompt::Tiny, IO::Prompt::Simple,
  or IO::Prompt::Hooked first.
  
  =item 2.
  
  By default the C<prompt()> subroutine does not return a string; it
  returns an object with overloaded string and boolean conversions.
  This object B<I<always>> evaluates true in boolean contexts, unless the
  read operation actually failed. This means that the object evaluates
  true I<even when the input value is zero or
  an empty string.> See L<"Returning raw data"> to turn off this 
  (occasionally counter-intuitive) behaviour.
  
  =back
  
  =head1 DESCRIPTION
  
  IO::Prompter exports a single subroutine, C<prompt>, that prints a
  prompt (but only if the program's selected input and output streams are
  connected to a terminal), then reads some input, then chomps it, and
  finally returns an object representing that text.
  
  The C<prompt()> subroutine expects zero-or-more arguments.
  
  Any argument that starts with a hyphen (C<->) is treated as a named
  option (many of which require an associated value, that may be passed as
  the next argument). See L<"Summary of options"> and L<"Options
  reference"> for details of the available options.
  
  Any other argument that is a string is treated as (part of) the prompt
  to be displayed. All such arguments are concatenated together before the
  prompt is issued. If no prompt string is provided, the string
  C<< '> ' >> is used instead.
  
  Normally, when C<prompt()> is called in either list or scalar context,
  it returns an opaque object that autoconverts to a string. In scalar
  boolean contexts this return object evaluates true if the input
  operation succeeded. In list contexts, if the input operation fails
  C<prompt()> returns an empty list instead of a return object. This
  allows failures in list context to behave correctly (i.e. be false).
  
  If you particularly need a list-context call to C<prompt()> to always
  return a value (i.e. even on failure), prefix the call with C<scalar>:
  
      # Only produces as many elements
      # as there were successful inputs...
      my @data = (
          prompt(' Name:'),
          prompt('  Age:'),
          prompt('Score:'),
      );
  
      # Always produces exactly three elements
      # (some of which may be failure objects)...
      my @data = (
          scalar prompt(' Name:'),
          scalar prompt('  Age:'),
          scalar prompt('Score:'),
      );
  
  In void contexts, C<prompt()> still requests input, but also issues a
  warning about the general uselessness of performing an I/O operation
  whose results are then immediately thrown away.
  See L<"Useful useless uses of C<prompt()>"> for an exception to this.
  
  The C<prompt()> function also sets C<$_> if it is called in a boolean
  context but its return value is not assigned to a variable. Hence, it is
  designed to be a drop-in replacement for C<readline> or C<< <> >>.
  
  =head1 INTERFACE
  
  All the options for C<prompt()> start with a hyphen (C<->).
  Most have both a short and long form. The short form is always
  the first letter of the long form.
  
  Most options have some associated value. For short-form options, this
  value is specified as a string appended to the option itself. The
  associated value for long-form options is always specified as a
  separated argument, immediately following the option (typically
  separated from it by a C<< => >>).
  
  Note that this implies that short-form options may not be able to
  specify every possible associated value (for example, the short-form
  C<-d> option cannot specify defaults with values C<'efault'> or
  C<'$%^!'>).  In such cases, just use the long form of the option
  (for example: S<< C<< -def => 'efault' >> >> or C<< -default=>'$%^!' >>).
  
  
  =head2 Summary of options
  
  Note: For options preceded by an asterisk, the short form is actually
  a Perl file operator, and hence cannot be used by itself.
  Either use the long form of these options,
  or L<bundle them with another option|"Bundling short-form options">,
  or add a L<"no-op"|"Escaping otherwise magic options"> to them.
  
  
      Short   Long
      form    form               Effect
      =====   =============      ======================================
  
      -a      -argv              Prompt for @ARGV data if !@ARGV
  
              -comp[lete]=>SPEC  Complete input on <TAB>, as specified
  
      -dSTR   -def[ault]=>STR    What to return if only <ENTER> typed
              -DEF[AULT]=>STR    (as above, but skip any -must checking)
  
    * -e[STR] -echo=>STR         Echo string for each character typed
  
              -echostyle=>SPEC   What colour/style to echo input in
  
    * -f      -filenames         Input should be name of a readable file
  
              -fail=>VALUE       Return failure if input smartmatches value
  
              -guar[antee]=>SPEC Only allow the specified words to be entered
  
      -h[STR] -hist[ory][=>SPEC] Specify the history set this call belongs to
  
              -in=>HANDLE        Read from specified handle
  
      -i      -integer[=>SPEC]   Accept only valid integers (that smartmatch SPEC)
  
      -k      -keyletters        Accept only keyletters (as specified in prompt)
  
    * -l      -line              Don't autochomp
  
              -menu=>SPEC        Specify a menu of responses to be displayed
  
              -must=>HASHREF     Specify requirements/constraints on input
  
      -n      -num[ber][=>SPEC]  Accept only valid numbers (that smartmatch SPEC)
  
              -out=>HANDLE       Prompt to specified handle
  
              -prompt=>STR       Specify prompt explicitly
  
    * -rSTR   -ret[urn]=>STR     After input, echo this string instead of <CR>
  
    * -s -1   -sing[le]          Return immediately after first key pressed
  
              -stdio             Use STDIN and STDOUT for prompting
  
              -style=>SPEC       What colour/style to display the prompt text in
  
      -tNUM   -time[out]=>NUM    Specify a timeout on the input operation
  
      -v      -verb[atim]        Return the input string (no context sensitivity)
  
              -void              Don't complain in void context
  
    * -w      -wipe              Clear screen
              -wipefirst         Clear screen on first prompt() call only
  
    * -y      -yes    [=> NUM]   Return true if [yY] entered, false otherwise
      -yn     -yesno  [=> NUM]   Return true if [yY] entered, false if [nN]
      -Y      -Yes    [=> NUM]   Return true if Y entered, false otherwise
      -YN     -YesNo  [=> NUM]   Return true if Y entered, false if N
  
    * -_                         No-op (handy for bundling ambiguous short forms)
  
  
  =head2 Automatic options
  
  Any of the options listed above (and described in detail below) can be
  automatically applied to every call to C<prompt()> in the current
  lexical scope, by passing them (via an array reference) as the arguments
  to a C<use IO::Prompter> statement.
  
  For example:
  
      use IO::Prompter;
  
      # This call has no automatically added options...
      my $assent = prompt "Do you wish to take the test?", -yn;
  
      {
          use IO::Prompter [-yesno, -single, -style=>'bold'];
  
          # These three calls all have: -yesno, -single, -style=>'bold' options
          my $ready = prompt 'Are you ready to begin?';
          my $prev  = prompt 'Have you taken this test before?';
          my $hints = prompt 'Do you want hints as we go?';
      }
  
      # This call has no automatically added options...
      scalar prompt 'Type any key to start...', -single;
  
  The current scope's lexical options are always I<prepended> to the
  argument list of any call to C<prompt()> in that scope.
  
  To turn off any existing automatic options for the rest of the current
  scope, use:
  
      use IO::Prompter [];
  
  
  =head2 Prebound options
  
  You can also ask IO::Prompter to export modified versions of C<prompt()>
  with zero or more options prebound. For example, you can request an
  C<ask()> subroutine that acts exactly like C<prompt()> but has the C<-
  yn> option pre-specified, or a C<pause()> subroutine that is C<prompt()>
  with a "canned" prompt and the C<-echo>, C<-single>, and C<-void> options.
  
  To specify such subroutines, pass a single hash reference when
  loading the module:
  
      use IO::Prompter {
          ask     => [-yn],
          pause   => [-prompt=>'(Press any key to continue)', -echo, -single, -void],
      }
  
  Each key will be used as the name of a separate subroutine to be
  exported, and each value must be an array reference, containing the
  arguments that are to be automatically supplied.
  
  The resulting subroutines are simply lexically scoped wrappers around
  C<prompt()>, with the specified arguments prepended to the normal
  argument list, equivalent to something like:
  
      my sub ask {
          return prompt(-yn, @_);
      }
  
      my sub pause {
          return prompt(-prompt=>'(Press any key to continue)', -echo, -single, -void, @_);
      }
  
  Note that these subroutines are lexically scoped, so if you want to use
  them throughtout a source file, they should be declared in the outermost
  scope of your program.
  
  
  =head2 Options reference
  
  =head3 Specifying what to prompt
  
  =over 4
  
  C<< -prompt => I<STRING> >>
  
  C<< -pI<STRING> >>
  
  =back
  
  By default, any argument passed to C<prompt()> that does not begin with
  a hyphen is taken to be part of the prompt string to be displayed before
  the input operation. Moreover, if no such string is specified in the
  argument list, the function supplies a default prompt (C<< '> ' >>)
  automatically.
  
  The C<-prompt> option allows you to specify a prompt explicitly, thereby
  enabling you to use a prompt that starts with a hyphen:
  
      my $input
          = prompt -prompt=>'-echo';
  
  or to disable prompting entirely:
  
      my $input
          = prompt -prompt => "";
  
  Note that the use of the C<-prompt> option doesn't override other string
  arguments, it merely adds its argument to the collective prompt.
  
  =head4 Prompt prettification
  
  If the specified prompt ends in a non-whitespace character, C<prompt()>
  adds a single space after it, to better format the output. On the other
  hand, if the prompt ends in a newline, C<prompt()> removes that
  character, to keep the input position on the same line as the prompt.
  
  You can use that second feature to override the first, if necessary. For
  example, if you wanted your prompt to look like:
  
      Load /usr/share/dict/_
  
  (where the _ represents the input cursor), then a call like:
  
      $filename = prompt 'Load /usr/share/dict/';
  
  would not work because it would automatically add a space, producing:
  
      Load /usr/share/dict/ _
  
  But since a terminal newline is removed, you could achieve the desired effect
  with:
  
      $filename = prompt "Load /usr/share/dict/\n";
  
  If for some reason you I<do> want a newline at the end of the prompt (i.e.
  with the input starting on the next line) just put two newlines at the end
  of the prompt. Only the very last one will be removed.
  
  
  =head3 Specifying how the prompt looks
  
  =over 4
  
  C<< -style  => I<SPECIFICATION> >>
  
  =back
  
  If the C<Term::ANSIColor> module is available, this option can be used
  to specify the colour and styling (e.g. bold, inverse, underlined, etc.)
  in which the prompt is displayed.
  
  You can can specify that styling as a single string:
  
      prompt 'next:' -style=>'bold red on yellow';
  
  or an array of styles:
  
      prompt 'next:' -style=>['bold', 'red', 'on_yellow'];
  
  The range of styles and colour names that the option understands is
  quite extensive. All of the following work as expected:
  
      prompt 'next:' -style=>'bold red on yellow';
  
      prompt 'next:' -style=>'strong crimson on gold';
  
      prompt 'next:' -style=>'highlighted vermilion, background of cadmium';
  
      prompt 'next:' -style=>'vivid russet over amber';
  
      prompt 'next:' -style=>'gules fort on a field or';
  
  However, because C<Term::ANSIColor> maps everything back to the
  standard eight ANSI text colours and seven ANSI text styles, all of the
  above will also be rendered identically. See that module's
  documentation for details.
  
  If C<Term::ANSIColor> is not available, this option is silently ignored.
  
  Please bear in mind that up to 10% of people using your interface will
  have some form of colour vision impairment, so its always a good idea
  to differentiate information by style I<and> colour, rather than by colour
  alone. For example:
  
      if ($dangerous_action) {
          prompt 'Really proceed?', -style=>'bold red underlined';
      }
      else {
          prompt 'Proceed?', -style=>'green';
      }
  
  Also bear in mind that (even though C<-style> does support the C<'blink'>
  style) up to 99% of people using your interface will have Flashing Text
  Tolerance Deficiency. Just say "no".
  
  
  =head3 Specifying where to prompt
  
  =over 4
  
  C<< -out => FILEHANDLE >>
  
  C<< -in => FILEHANDLE >>
  
  C<< -stdio >>
  
  =back
  
  The C<-out> option (which has no short form) is used to specify
  where the prompt should be written to. If this option is not specified,
  prompts are written to the currently C<select>-ed filehandle. The most
  common usage is:
  
      prompt(out => *STDERR)
  
  The C<-in> option (which also has no short form) specifies where the input
  should be read from. If this option is not specified, input is read from
  the C<*ARGV> filehandle. The most common usage is:
  
      prompt(in => *STDIN)
  
  in those cases where C<*ARGV> has been opened to a file, but you still
  wish to interact with the terminal (assuming C<*STDIN> is opened to that
  terminal).
  
  The C<-stdio> option (which again has no short form) is simply a shorthand
  for: C<< -in => *STDIN, -out => *STDOUT >>. This is particularly useful when
  there are arguments on the commandline, but you don't want prompt to treat
  those arguments as filenames for magic C<*ARGV> reads.
  
  
  =head3 Specifying how long to wait for input
  
  =over 4
  
  C<< -timeout => I<N> >>
  
  C<< -tI<N> >>
  
  =back
  
  Normally, the C<prompt()> function simply waits for input. However,
  you can use this option to specify a timeout on the read operation.
  If no input is received within the specified I<N> seconds, the call
  to C<prompt()> either returns the value specified by
  L<the C<-default> option|"Specifying what to return by default">
  (if any), or else an object indicating the read failed.
  
  Note that, if the short form is used, I<N> must be an integer. If the long
  form is used, I<N> may be an integer or floating point value.
  
  You can determine whether an input operation timed out, even if a
  default value was returned, by calling the C<timedout()> method on the
  object returned by C<prompt()>:
  
      if (prompt('Continue?', -y1, -timeout=>60) && !$_->timedout) {
          ...
      }
  
  If a time-out occurred, the return value of C<timedout()> is a string
  describing the timeout, such as:
  
      "timed out after 60 seconds"
  
  
  =head3 Providing a menu of responses
  
  =over
  
  =item C<< -menu => I<SPECIFICATION> >>
  
  =back
  
  You can limit the allowable responses to a prompt, by providing a menu.
  
  A menu is specified using the C<-menu> option, and the menu choices
  are specified as an argument to the option, either as a reference to
  an array, hash, or string, or else as a literal string.
  
  If the menu is specified in a hash, C<prompt()> displays the keys of the
  hash, sorted alphabetically, and with each alternative marked with a
  single alphabetic character (its "selector key").
  
  For example, given:
  
      prompt 'Choose...',
             -menu=>{ 'live free'=>1, 'die'=>0, 'transcend'=>-1 },
             '>';
  
  C<prompt()> will display:
  
      Choose...
          a. die
          b. live free
          c. transcend
      > _
  
  It will then only permit the user to enter a valid selector key (in the
  previous example: 'a', 'b', or 'c'). Once one of the alternatives is
  selected, C<prompt()> will return the corresponding value from the hash
  (0, 1, or -1, respectively, in this case).
  
  Note that the use of alphabetics as selector keys inherently limits the
  number of usable menu items to 52. See L<"Numeric menus"> for a way to
  overcome this limitation.
  
  A menu is treated like a special kind of prompt, so that any
  other prompt strings in the C<prompt()> call will appear either before or
  after the menu of choices, depending on whether they appear before or
  after the menu specification in the call to C<prompt()>.
  
  If an array is used to specify the choices:
  
      prompt 'Choose...',
             -menu=>[ 'live free', 'die', 'transcend' ],
             '>';
  
  then each array element is displayed (in the original array order) with
  a selector key:
  
      Choose...
          a. live free
          b. die
          c. transcend
      > _
  
  and C<prompt()> returns the element corresponding to the selection (i.e.
  it returns 'live free' if 'a' is entered, 'die' if 'b' is entered, or
  'transcend' if 'c' is entered).
  
  Hence, the difference between using an array and a hash is that the
  array allows you to control the order of items in the menu, whereas a
  hash allows you to show one thing (i.e. keys) but have something related
  (i.e. values) returned instead.
  
  If the argument after C<-menu> is a string or a reference to a string, the
  option splits the string on newlines, and treats the resulting list as if it
  were an array of choices. This is useful, for example, to request the user
  select a filename:
  
      my $files = `ls`;
      prompt 'Select a file...', -menu=>$files, '>';
  
  
  =head4 Numbered menus
  
  As the previous examples indicate, each menu item is given a unique
  alphabetic selector key. However, if the C<-number> or C<-integer>
  option is specified as well:
  
      prompt 'Choose...',
             -number,
             -menu=>{ 'live free'=>1, 'die'=>0, 'transcend'=>-1 },
             '>';
  
  C<prompt()> will number each menu item instead, using consecutive integers
  as the selector keys:
  
      Choose...
          1. die
          2. live free
          3. transcend
      > _
  
  This allows for an unlimited number of alternatives in a single menu,
  but prevents the use of C<-single> for one-key selection from menus if
  the menu has more than nine items.
  
  
  =head4 Hierarchical menus
  
  If you use a hash to specify a menu, the values of the hash do not have
  to be strings. Instead, they can be references to nested hashes or
  arrays.
  
  This allows you to create hierarchical menus, where a selection at the
  top level may lead to a secondary menu, etc. until an actual choice is
  possible. For example, the following call to prompt:
  
      my $choices = {
          animates => {
              animals => {
                  felines => [qw<cat lion lynx>],
                  canines => [qw<dog fox wolf>],
                  bovines => [qw<cow ox buffalo>],
              },
              fish => [qw<shark carp trout bream>],
          },
          inanimates => {
              rocks     => [qw<igneous metamorphic sedimentary>],
              languages => [qw<Perl Python Ruby Tcl>],
          },
      };
  
      my $result = prompt -1, 'Select a species...', -menu=>$choices, '> ';
  
  might result in an interaction like this:
  
      Select a species...
      a.  animates
      b.  inanimates
      > a
  
      Select from animates:
      a.  animals
      b.  fish
      > b
  
      Select from fish:
      a.  shark
      b.  carp
      c.  trout
      d.  bream
      > c
  
  At which point, C<prompt()> would return the string C<'trout'>.
  
  Note that you can nest an arbitrary number of hashes, but that each
  "bottom" level choice has to be either a single string, or an array
  of strings.
  
  
  =head4 Navigating hierarchical menus
  
  Within a hierarchical menu, the user must either select a valid option
  (by entering the corresponding letter), or else may request that they be
  taken back up a level in the hierarchy, by entering C<< <ESC> >>.
  Pressing C<< <ESC> >> at the top level of a menu causes the call to
  C<prompt()> to immediately return with failure.
  
  
  =head3 Simulating a command-line
  
  =over 4
  
  C<< -argv >>
  
  C<< -a  >>
  
  =back
  
  The C<prompt()> subroutine can be used to request that the user provide
  command-line arguments interactively. When requested, the input
  operation is only carried out if C<@ARGV> is empty.
  
  Whatever the user enters is broken into a list and assigned to C<@ARGV>.
  
  The input is first C<glob>bed for file expansions, and has any
  environment variables (of the form C<$VARNAME> interpolated). The
  resulting string is then broken into individual words, except where
  parts of it contain single or double quotes, the contents of which are
  always treated as a single string.
  
  This feature is most useful during development, to allow a program to be
  run from within an editor, and yet pass it a variety of command-lines. The
  typical usage is (at the start of a program):
  
      use IO::Prompter;
      BEGIN { prompt -argv }
  
  However, because this pattern is so typical, there is a shortcut:
  
      use IO::Prompter -argv;
  
  You can also specify the name with which the program args, are to
  be prompted, in the usual way (i.e. by providing a prompt):
  
      use IO::Prompter -argv, 'demo.pl';
  
  Note, however, the critical difference between that shortcut
  (which calls C<prompt -argv> when the module is loaded) and:
  
      use IO::Prompter [-argv];
  
  (which sets C<-argv> as an automatic option for every subsequent call to
  C<prompt()> in the current lexical scope).
  
  Note too that the C<-argv> option also implies C<-complete=>'filenames'>.
  
  
  =head3 Input autocompletion
  
  =over 4
  
  C<< -comp[lete] => I<SPECIFICATION> >>
  
  =back
  
  When this option is specified, the C<prompt()> subroutine will complete
  input using the specified collection of strings. By default, when
  completion is active, word completion is requested using the C<< <TAB> >>
  key, but this can be changed by setting the C<$IO_PROMPTER_COMPLETE_KEY>
  environment variable. Once completion has been initiated, you can use
  the completion key or else C<< <CTRL-N> >> to advance to the next completion
  candidate. You can also use C<< <CTRL-P> >> to back up to the previous
  candidate.
  
  The specific completion mechanism can be defined either using a
  subroutine, an array reference, a hash reference, or a special string:
  
      Specification       Possible completions supplied by...
  
        sub {...}         ...whatever non-subroutine specification
                          (as listed below) is returned when the
                          subroutine is called. The subroutine is passed
                          the words of the current input text, split on
                          whitespace, as its argument list.
  
          [...]           ...the elements of the array
  
          {...}           ...the keys of the hash
  
       'filenames'        ...the list of files supplied by globbing the
                          last whitespace-separated word of the input text
  
       'dirnames'         ...the list of directories supplied by globbing the
                          last whitespace-separated word of the input text
  
  If an array or hash is used, only those elements or keys that begin with
  the last whitespace-separated word of the current input are offered as
  completions.
  
  For example:
  
      # Complete with the possible commands...
      my $next_cmd
          = prompt -complete => \%cmds;
  
      # Complete with valid usernames...
      my $user
          = prompt -complete => \@usernames;
  
      # Complete with valid directory names...
      my $file
          = prompt -complete => 'dirnames';
  
      # Complete with cmds on the first word, and filenames on the rest...
      my $cmdline
          = prompt -complete => sub { @_ <= 1 ? \%cmds : 'filenames' };
  
  
  =head4 Completing from your own input history
  
  The C<prompt()> subroutine also tracks previous input and allows you to
  complete with that instead. No special option is required, as the
  feature is enabled by default.
  
  At the start of a prompted input, the user can cycle backwards through
  previous inputs by pressing C<< <CTRL-R> >> (this can be changed
  externally by setting the C<$IO_PROMPTER_HISTORY_KEY> environment
  variable, or internally by assigning a new keyname to
  C<$ENV{IO_PROMPTER_HISTORY_KEY}>). After the first C<< <CTRL-R> >>,
  subsequent C<< <CTRL-R> >>'s will recall earlier inputs. You can also
  use C<< <CTRL-N> >> and C<< <CTRL-P> >>
  (as in L<user-specified completions|"Input autocompletion">) to move
  back and forth through your input history.
  
  If the user has already typed some input, the completion mechanism
  will only show previous inputs that begin with that partial input.
  
  
  =head4 History sets
  
  =over 4
  
  =item C<< -h[NAME] >>
  
  =item C<< -hist[ory] [=> NAME] >>
  
  =back
  
  By default, IO::Prompter tracks every call to C<prompt()> within a
  program, and accumulates a single set of history completions for all of
  them. That means that, at any prompt, C<< <CTRL-R> >> will take the user
  back through I<every> previous input, regardless of which call to
  C<prompt()> originally retrieved it.
  
  Sometimes that's useful, but sometimes you might prefer that different
  calls to C<prompt()> retained distinct memories. For example, consider
  the following input loop:
  
      while (my $name = prompt 'Name:') {
          my $grade   = prompt 'Grade:', -integer;
          my $comment = prompt 'Comment:';
          ...
      }
  
  If you're entering a name, there's no point in C<prompt()> offering
  to complete it with previous grades or comments. In fact, that's
  just annoying.
  
  IO::Prompter allows you to specify that a particular call to
  C<prompt()> belongs to a particular "history set". Then it completes
  input history using only the history of those calls belonging to the
  same history set.
  
  So the previous example could be improved like so:
  
      while (my $name = prompt 'Name:', -hNAME) {
          my $grade   = prompt 'Grade:', -hGRADE, -integer;
          my $comment = prompt 'Comment:', -hOTHER;
          ...
      }
  
  Now, when prompting for a name, only those inputs in the C<'NAME'>
  history set will be offered as history completions. Likewise only
  previous grades will be recalled when prompting for grades and earlier
  only comments when requesting comments.
  
  If you specify the C<-h> or C<-history> option without providing the
  name of the required history set, C<prompt()> uses the prompt text
  itself as the name of the call's history set. So the previous example
  would work equally well if written:
  
      while (my $name = prompt 'Name:', -h) {
          my $grade   = prompt 'Grade:', -h, -integer;
          my $comment = prompt 'Comment:', -h;
          ...
      }
  
  though now the names of the respective history sets would now be
  C<'Name: '>, C<'Grade: '>, and C<'Comment: '>. This is by far the more
  common method of specifying history sets, with explicitly named sets
  generally only being used when two or more separate calls to
  C<prompt()> have to share a common history despite using distinct
  prompts. For example:
  
      for my $n (1..3) {
          $address .= prompt "Address (line $n):", -hADDR;
      }
  
  If you specify C<'NONE'> as the history set, the input is not
  recorded in the history. This is useful when inputting passwords.
  
  
  =head4 Configuring the autocompletion interaction
  
  By default, when user-defined autocompletion is requested, the
  C<prompt()> subroutine determines the list of possible completions,
  displays it above the prompt, and completes to the longest common
  prefix. If the completion key is pressed again immediately, the
  subroutine then proceeds to complete with each possible completion in a
  cyclic sequence. This is known as "list+longest full" mode.
  
  On the other hand, when historical completion is requested, C<prompt()>
  just immediately cycles through previous full inputs. This is known as "full"
  mode.
  
  You can change these behaviours by setting the
  C<$IO_PROMPTER_COMPLETE_MODES> and C<$IO_PROMPTER_HISTORY_MODES>
  environment variables I<before the module is loaded> (either in your shell,
  or in a C<BEGIN> block before the module is imported).
  
  Specifically, you can set the individual string values of either of
  these variables to a whitespace-separated sequence containing any of the
  following:
  
      list         List all options above the input line
  
      longest      Complete to the longest common prefix
  
      full         Complete with each full match in turn
  
  For example:
  
      # Just list options without actually completing...
      BEGIN{ $ENV{IO_PROMPTER_COMPLETE_MODES} = 'list'; }
  
      # Just cycle full alternatives on each <TAB>...
      BEGIN{ $ENV{IO_PROMPTER_COMPLETE_MODES} = 'full'; }
  
      # For history completion, always start with the
      # longest common prefix on the first <CTRL-R>,
      # then just list the alternatives on a subsequent press...
      BEGIN{ $ENV{IO_PROMPTER_HISTORY_MODES} = 'longest list'; }
  
  
  =head3 Specifying what to return by default
  
  =over
  
  C<< -DEF[AULT] => I<STRING> >>
  
  C<< -def[ault] => I<STRING> >>
  
  C<< -dI<STRING> >>
  
  =back
  
  If a default value is specified, that value will be returned if the user
  enters an empty string at the prompt (i.e. if they just hit
  C<< <ENTER>/<RETURN> >> immediately) or if the input operation times out under
  L<the C<timeout> option|"Specifying how long to wait for input">.
  
  Note that the default value is not added to the prompt, unless you
  do so yourself. A typical usage might therefore be:
  
      my $frequency
          = prompt "Enter polling frequency [default: $DEF_FREQ]",
                   -num, -def=>$DEF_FREQ;
  
  You can determine if the default value was autoselected (as opposed to
  the same value being typed in explicitly) by calling the C<defaulted()>
  method on the object returned by C<prompt()>, like so:
  
      if ($frequency->defaulted) {
          say "Using default frequency";
      }
  
  If you use the L<< C<-must> option|"Constraining what can be returned" >>
  any default value must also satisfy all the constraints you specify,
  unless you use the C<-DEFAULT> form, which skips constraint checking
  when the default value is selected.
  
  If you use the L<< C<-menu> option|"Providing a menu of responses" >>,
  the specified default value will be returned immediately C<< <ENTER>/<RETURN> >> is
  pressed, regardless of the depth you are within the menu. Note that the
  default value specifies the value to be returned, not the selector key
  to be entered. The default value does not even have to be one of the
  menu choices.
  
  
  =head3 Specifying what to echo on input
  
  =over
  
  C<< -echo => I<STR> >>
  
  C<< -eI<STR> >>
  
  =back
  
  When this option is specified, the C<prompt()> subroutine will echo the
  specified string once for each character that is entered. Typically this
  would be used to shroud a password entry, like so:
  
      # Enter password silently:
      my $passwd
          = prompt 'Password:', -echo=>"";
  
      # Echo password showing only asterisks:
      my $passwd
          = prompt 'Password:', -echo=>"*";
  
  As a special case, if the C<-echo> value contains a slash (C</>) and the
  any of the <-yesno> options is also specified, the substring before the
  slash is taken as the string to echo for a 'yes' input, and the
  substring after the slash is echoed for a 'no' input.
  
  Note that this option is only available when the Term::ReadKey module
  is installed. If it is used when that module is not available, a warning
  will be issued.
  
  
  =head4 Specifying how to echo on input
  
  C<< -echostyle => I<SPECIFICATION> >>
  
  The C<-echostyle> option works for the text the user types in
  the same way that the C<-style> option works for the prompt.
  That is, you can specify the style and colour in which the user's
  input will be rendered like so:
  
      # Echo password showing only black asterisks on a red background:
      my $passwd
          = prompt 'Password:', -echo=>"*", -echostyle=>'black on red';
  
  Note that C<-echostyle> is completely independent of C<-echo>:
  
      # Echo user's name input in bold white:
      my $passwd
          = prompt 'Name:', -echostyle=>'bold white';
  
  The C<-echostyle> option requires C<Term::ANSIColor>, and will
  be silently ignored if that module is not available.
  
  
  =head4 Input editing
  
  When the Term::ReadKey module is available, C<prompt()> also honours a
  subset of the usual input cursor motion commands:
  
  =over
  
  =item C<CTRL-B>
  
  Move the cursor back one character
  
  =item C<CTRL-F>
  
  Move the cursor forward one character
  
  =item C<CTRL-A>
  
  Move the cursor to the start of the input
  
  =item C<CTRL-E>
  
  Move the cursor to the end of the input
  
  =back
  
  
  =head3 Specifying when input should fail
  
  =over 4
  
  C<< -fail => I<VALUE> >>
  
  C<< -fI<STRING> >>
  
  =back
  
  If this option is specified, the final input value is compared with the
  associated string or value, by smartmatching just before the call to
  C<prompt()> returns. If the two match, C<prompt()> returns a failure
  value. This means that instead of writing:
  
      while (my $cmd = prompt '>') {
          last if $cmd eq 'quit';
          ...
      }
  
  you can just write:
  
      while (my $cmd = prompt '>', -fail=>'quit') {
          ...
      }
  
  
  =head3 Constraining what can be typed
  
  =over 4
  
  =item C<< -guar[antee] => SPEC >>
  
  =back
  
  This option allows you to control what input users can provide.
  The specification can be a regex or a reference to an array or a hash.
  
  If the specification is a regex, that regex is matched against the input
  so far, every time an extra character is input. If the regex ever fails
  to match, the guarantee fails.
  
  If the specification is an array, the input so far is matched against
  the same number of characters from the start of each of the (string)
  elements of the array. If none of these substrings match the input, the
  guarantee fails.
  
  If the specification is a hash, the input so far is matched against the
  same number of characters from the start of each key of the hash. If
  none of these substrings match the input, the guarantee fails.
  
  If the guarantee fails, the input is rejected
  (just as L<< the C<-must> option|"Constraining what can be returned" >>
  does). However, unlike C<-must>, C<-guarantee> rejects the input
  character-by-character as it typed, and I<before> it is even echoed. For
  example, if your call to C<prompt()> is:
  
      my $animal = prompt -guarantee=>['cat','dog','cow'];
  
  then at the prompt:
  
      > _
  
  you will only be able to type in 'c' or 'd'. If you typed 'c', then you would
  only be able to type 'a' or 'o'. If you then typed 'o', you would only be able
  to type 'w'.
  
  In other words, C<-guarantee> ensures that you can only type in a valid input,
  and simply ignores any typing that would not lead to such an input.
  
  To help users get the input right, specifying C<-guarantee> as an array
  or hash reference also automatically specifies a
  L<< C<-complete> option|"Input autocompletion" >> with the array or hash
  as its completion list as well. So, whenever a C<-guarantee> is in
  effect, the user can usually autocomplete the acceptable inputs.
  
  Note, however, that C<-guarantee> can only reject (or autocomplete)
  input as it is typed if the Term::ReadKey module is available. If that
  module cannot be loaded, C<-guarantee> only applies its test after the
  C<< <ENTER>/<RETURN> >> key is pressed, and there will be no autocompletion
  available.
  
  =head4 Constraining input to numbers
  
  =over 4
  
  =item C<< -i >>
  
  =item C<< -integer [=> SPEC] >>
  
  =item C<< -n  >>
  
  =item C<< -num[ber] [=> SPEC] >>
  
  =back
  
  If any of these options are specified, C<prompt()> will only accept a valid
  integer or number as input, and will reprompt until one is entered.
  
  If you need to restrict the kind of number further (say, to positive
  integers), you can supply an extra constraint as an argument to the
  long-form option. Any number entered must satisfy this constraint by
  successfully smart-matching it. For example:
  
      $rep_count = prompt 'How many reps?', -integer => sub{ $_ > 0 };
  
      $die_roll = prompt 'What did you roll?', -integer => [1..6];
  
      $factor = prompt 'Prime factor:', -integer => \&is_prime;
  
      $score = prompt 'Enter score:', -number => sub{ 0 <= $_ && $_ <= 100 };
  
  If the constraint is specified as a subroutine, the entered number will be
  passed to it both as its single argument and in C<$_>.
  
  You cannot pass a scalar value directly as a constraint, except those strings
  listed below. If you want a scalar value as a constraint, use a regex or
  array reference instead:
  
      # Wrong...
      $answer = prompt "What's the ultimate answer?",
                        -integer => 42;
  
      # Use this instead...
      $answer = prompt "What's the ultimate answer?",
                       -integer => qr/^42$/;
  
      # Or this...
      $answer = prompt "What's the ultimate answer?",
                       -integer => [42];
  
  
  Only the following strings may be passed directly as scalar value
  constraints. They do mot match exactly, but instead act as specifiers
  for one or more built-in constraints. You can also pass a string that
  contains two or more of them, separated by whitespace, in which case
  they must all be satisfied. The specifiers are:
  
  =over 4
  
  =item C<'pos'> or C<'positive'>
  
  The number must be greater than zero
  
  =item C<'neg'> or C<'negative'>
  
  The number must be less than zero
  
  =item C<'zero'>
  
  The number must be equal to zero
  
  =item C<'even'> or C<'odd'>
  
  The number must have the correct parity
  
  =back
  
  You can also prepend C<"non"> to any of the above to reverse their meaning.
  
  For example:
  
      $rep_count = prompt 'How much do you bid?', -number => 'positive';
  
      $step_value = prompt 'Next step:', -integer => 'even nonzero';
  
  
  =head4 Constraining input to filenames
  
  =over 4
  
  =item C<< -f >>
  
  =item C<< -filenames >>
  
  =back
  
  You can tell C<prompt()> to accept only valid filenames, using the
  C<-filenames> option (or its shortcut: C<-f>).
  
  This option is equivalent to the options:
  
      -must => {
          'File must exist'       => sub { -e },
          'File must be readable' => sub { -r },
      },
      -complete => 'filenames',
  
  In other words C<-filenames> requires C<prompt()> to accept only the name
  of an existing, readable file, and it also activates filename completion.
  
  
  =head4 Constraining input to "keyletters"
  
  =over
  
  =item C<< -k >>
  
  =item C<< -key[let[ter]][s] >>
  
  =back
  
  A common interaction is to offer the user a range of actions, each of
  which is specified by keying a unique letter, like so:
  
      INPUT:
      given (prompt '[S]ave, (R)evert, or (D)iscard:', -default=>'S') {
          when (/R/i) { revert_file()  }
          when (/D/i) { discard_file() }
          when (/S/i) { save_file()    }
          default     { goto INPUT;    }
      }
  
  This can be cleaned up (very slightly) by using a guarantee:
  
      given (prompt '[S]ave, (R)evert, or (D)iscard:', -default=>'S',
                    -guarantee=>qr/[SRD]/i
      ) {
          when (/R/i) { revert_file()  }
          when (/D/i) { discard_file() }
          default     { save_file()    }
      }
  
  However, it's still annoying to have to specify the three key letters
  twice (and the default choice three times) within the call to
  C<prompt()>. So IO::Prompter provides an option that extracts this
  information directly from the prompt itself:
  
      given (prompt '[S]ave, (R)evert, or (D)iscard:', -keyletters) {
          when (/R/i) { revert_file()  }
          when (/D/i) { discard_file() }
          default     { save_file()    }
      }
  
  This option scans the prompt string and extracts any purely alphanumeric
  character sequences that are enclosed in balanced brackets of any kind
  (square, angle, round, or curly). It then makes each of these character
  sequences a valid input (by implicitly setting the C<-guarantee>
  option), and adds the first option in square brackets (if any) as the
  C<-default> value of the prompt.
  
  Note that the key letters don't have to be at the start of a word, don't
  have to be a single character, and can be either upper or lower case.
  For example:
  
      my $action = prompt -k, '(S)ave, Save(a)ll, (Ex)it without saving';
  
  Multi-character key letters are often a good choice for options with
  serious or irreversible consequences.
  
  A common idiom with key letters is to use the C<-single> option as well,
  so that pressing any key letter immediately completes the input, without
  the user having to also press C<< <ENTER>/<RETURN> >>:
  
      given (prompt -k1, '[S]ave, (R)evert, or (D)iscard:') {
          when (/R/i) { revert_file()  }
          when (/D/i) { discard_file() }
          default     { save_file()    }
      }
  
  
  
  =head3 Preserving terminal newlines
  
  =over 4
  
  =item C<< -l  >>
  
  =item C<< -line >>
  
  =back
  
  The (encapsulated) string returned by C<prompt()> is automatically chomped by
  default. To prevent that chomping, specify this option.
  
  
  =head3 Constraining what can be returned
  
  =over 4
  
  =item C<< -must => HASHREF >>
  
  =back
  
  This option allows you to specify requirements and constraints on the input
  string that is returned by C<prompt()>. These limitations are specified as the
  values of a hash.
  
  If the C<-must> option is specified, once input is complete every value in the
  specified hash is smartmatched against the input text. If any of them fail to
  match, the input is discarded, the corresponding hash key is printed as an
  error message, and the prompt is repeated.
  
  Note that the values of the constraint hash cannot be single strings or
  numbers, except for certain strings (such as C<'pos'>, C<'nonzero'>, or
  C<'even'>, as described in L<"Constraining input to numbers">).
  
  If you want to constrain the input to a single string or number (a very
  unusual requirement), just place the value in an array, or match it
  with a regex:
  
      # This doesn't work...
      my $magic_word = prompt "What's the magic word?",
                              -must => { 'be polite' => 'please' };
  
      # Use this instead...
      my $magic_word = prompt "What's the magic word?",
                              -must => { 'be polite' => ['please'] };
  
      # Or, better still...
      my $magic_word = prompt "What's the magic word?",
                              -must => { 'be polite' => qr/please/i };
  
  
  The C<-must> option allows you to test inputs against multiple
  conditions and have the appropriate error messages for each displayed.
  It also ensures that, when C<prompt()> eventually returns, you are
  guaranteed that the input meets all the specified conditions.
  
  For example, suppose the user is required to enter a positive odd prime
  number less than 100. You could enforce that with:
  
      my $opnlt100 = prompt 'Enter your guess:',
                            -integer,
                            -must => { 'be odd'                 => 'odd',
                                       'be in range'            => [1..100],
                                       'It must also be prime:' => \&isprime,
                                     };
  
  Note that, if the error message begins with anything except an uppercase
  character, the prompt is reissued followed by the error message in
  parentheses with the word "must" prepended (where appropriate).
  Otherwise, if the error message does start with an uppercase character,
  the prompt is not reissued and the error message is printed verbatim. So
  a typical input sequence for the previous example might look like:
  
      Enter your guess: 101
      Enter your guess: (must be in range) 42
      It must also be prime: 2
      Enter your guess: (must be odd) 7
  
  at which point, the call to C<prompt()> would accept the input and return.
  
  See also L<the C<-guarantee> option|"Constraining what can be typed">,
  which allows you to constrain inputs as they are typed, rather than
  after they are entered.
  
  
  =head3 Changing how returns are echoed
  
  =over 4
  
  =item C<< -r[STR] >>
  
  =item C<< -ret[urn] [=> STR] >>
  
  =back
  
  When C<< <ENTER>/<RETURN> >> is pressed, C<prompt()> usually echoes a carriage return.
  However, if this option is given, C<prompt()> echoes the specified string
  instead. If the string is omitted, it defaults to C<"\n">.
  
  For example:
  
      while (1) {
          my $expr = prompt 'Calculate:', -ret=>' = ';
          say evaluate($expr);
      }
  
  would prompt for something like this:
  
      Calculate: 2*3+4^5_
  
  and when the C<< <ENTER>/<RETURN> >> key is pressed, respond with:
  
      Calculate: 2*3+4^5 = 1030
      Calculate: _
  
  The string specified with C<-return> is also automatically echoed if the
  L<< C<-single> option|"Single-character input" >> is used. So if you
  don't want the automatic carriage return that C<-single> mode supplies,
  specify C<< -return=>"" >>.
  
  
  =head3 Single-character input
  
  =over 4
  
  =item C<< -s >>
  
  =item C<< -1 >>
  
  =item C<< -sing[le] >>
  
  =back
  
  This option causes C<prompt()> to return immediately once any single
  character is input. The user does not have to push the C<< <ENTER>/<RETURN> >>
  key to complete the input operation. C<-single> mode input is only
  available if the Term::ReadKey module can be loaded.
  
  By default, C<prompt()> echoes the single character that is entered. Use
  the L<C<-echo> option|"Specifying what to echo on input"> to change or
  prevent that.
  
      # Let user navigate through maze by single, silent keypresses...
      while ($nextdir = prompt "\n", -single, -echo, -guarantee=>qr/[nsew]/) {
          move_player($nextdir);
      }
  
  Unless echoing has been disabled, by default C<prompt()> also supplies a
  carriage return after the input character. Use
  L<the C<-return> option|"Changing how returns are echoed"> to change
  that behaviour. For example, this:
  
      my $question = <<END_QUESTION;
      Bast is the goddess of: (a) dogs  (b) cats  (c) cooking  (d) war?
      Your answer:
      END_QUESTION
  
      my $response = prompt $question, -1, -return=>' is ', -g=>['a'..'d'];
      say $response eq $answer ? 'CORRECT' : 'incorrect';
  
  prompts like this:
  
      Bast is the goddess of: (a) dogs  (b) cats  (c) cooking  (d) war?
      Your answer: _
  
  accepts a single character, like so:
  
      Bast is the goddess of: (a) dogs  (b) cats  (c) cooking  (d) war?
      Your answer: b_
  
  and completes the line thus:
  
      Bast is the goddess of: (a) dogs  (b) cats  (c) cooking  (d) war?
      Your answer: b is CORRECT
      _
  
  
  =head3 Returning raw data
  
  =over 4
  
  =item C<< -v >>
  
  =item C<< -verb[atim] >>
  
  =back
  
  Normally, C<prompt()> returns a special object that contains the text
  input, the success value, and other information such as whether the
  default was selected and whether the input operation timed out.
  
  However, if you prefer to have C<prompt()> just return the input text string
  directly, you can specify this option.
  
  Note however that, under C<-verbatim>, the input is still
  autochomped (unless you also specify
  L<the C<-line> option|"Preserving terminal newlines">.
  
  
  =head3 Prompting on a clear screen
  
  =over 4
  
  =item C<< -w >>
  
  =item C<< -wipe[first] >>
  
  =back
  
  If this option is present, C<prompt()> prints 1000 newlines before
  printing its prompt, effectively wiping the screen clear of other text.
  
  If the C<-wipefirst> variant is used, the wipe will only occur if the
  particular call to C<prompt()> is the first such call anywhere in your
  program. This is useful if you'd like the screen cleared at the start of
  input only, but you're not sure which call to C<prompt()> will happen
  first: just use C<-wipefirst> on all possible initial calls and only the
  actual first call will wipe the screen.
  
  
  =head3 Requesting confirmations
  
  =over 4
  
  =item C<< -y[n] >> or C<< -Y[N] >>
  
  =item C<< -yes[no] >> or C<< -Yes[No] >>
  
  =item C<< -yes[no] => COUNT >> or C<< -Yes[No] => COUNT >>
  
  =back
  
  This option invokes a special mode that can be used to confirm (or deny)
  something. If one of these options is specified, C<prompt> still
  returns the user's input, but the success or failure of the object returned
  now depends on what the user types in.
  
  A true result is returned if C<'y'> is the first character entered. If
  the flag includes an C<n> or C<N>, a false result is returned if C<'n'>
  is the first character entered (and any other input causes the prompt to
  be reissued). If the option doesn't contain an C<n> or C<N>, any input
  except C<'y'> is treated as a "no" and a false value is returned.
  
  If the option is capitalized (C<-Y> or C<-YN>), the first letter of the
  input must be likewise a capital (this is a handy means of slowing down
  automatic unthinking C<y>..."Oh no!" responses to potentially serious
  decisions).
  
  This option is most often used in conjunction with the C<-single> option, like
  so:
  
      $continue = prompt("Continue? ", -yn1);
  
  so that the user can just hit C<y> or C<n> to continue, without having to hit
  C<< <ENTER>/<RETURN> >> as well.
  
  If the optional I<COUNT> argument is supplied, the prompting is repeated
  that many times, with increasingly insistent requests for confirmation.
  The answer must be "yes" in each case for the final result to be true.
  For example:
  
      $rm_star = prompt("Do you want to delete all files? ", -Yes=>3 );
  
  might prompt:
  
      Do you want to delete all files?  Y
      Really?  Y
      Are you sure?  Y
  
  
  
  =head3 Bundling short-form options
  
  You can bundle together any number of short-form options, including those that
  take string arguments. For example, instead of writing:
  
      if (prompt "Continue? ", -yes, -1, -t10, -dn) {
  
  you could just write:
  
      if (prompt "Continue? ", -y1t10dn) {...}
  
  This often does I<not> improve readability (as the preceding example
  demonstrates), but is handy for common usages such as C<-y1> ("ask for
  confirmation, don't require an C<< <ENTER>/<RETURN> >>) or C<-vl>
  ("Return a verbatim and unchomped string").
  
  
  =head3 Escaping otherwise-magic options
  
  =over 4
  
  C<< -_ >>
  
  =back
  
  The C<-_> option exists only to be an explicit no-op. It allows you to
  specify short-form options that would otherwise be interpreted as Perl
  file operators or other special constructs, simply by prepending or
  appending a C<_> to them. For example:
  
      my $input
          = prompt -l_;  # option -l, not the -l file operator.
  
  The following single-letter options require an underscore to chaperone them
  when they're on their own: C<-e>, C<-l>, C<-r>, C<-s>, C<-w>, and C<-y>.
  However, an underscore is not required if two or more are bundled together.
  
  
  =head2 Useful useless uses of C<prompt()>
  
  Normally, in a void context, a call to C<prompt()> issues a warning that
  you are doing an input operation whose input is immediately thrown away.
  
  There is, however, one situation where this useless use of C<prompt()> in a
  void context is actually useful:
  
      say $data;
      prompt('END OF DATA. Press any key to exit', -echo, -single);
      exit;
  
  Here, we're using prompt simply to pause the application after the data is
  printed. It doesn't matter what the user types in; the typing itself is the
  message (and the message is "move along").
  
  In such cases, the "useless use..." warning can be suppressed using the 
  C<< -void >> option:
  
      say $data;
      prompt('END OF DATA. Press any key to exit', -echo, -single, -void);
      exit;
  
  
  =head2 Simulating input
  
  IO::Prompter provides a mechanism with which you can "script" a sequence of
  inputs to an application. This is particularly useful when demonstrating
  software during a presentation, as you do not have to remember what to type,
  or concentrate on typing at all.
  
  If you pass a string as an argument to C<use IO::Prompter>, the
  individual lines of that string are used as successive input lines to
  any call to C<prompt()>. So for example, you could specify several sets
  of input data, like so:
  
      use IO::Prompter <<END_DATA
      Leslie
      45
      165
      Jessie
      28
      178
      Dana
      12
      120
      END_DATA
  
  and then read this data in an input loop:
  
      while (my $name   = prompt 'Name:') {
             my $age    = prompt 'Age:';
             my $height = prompt 'Height:';
  
             process($name, $age, $height);
      }
  
  Because the C<use IO::Prompter> supplies input data,
  the three calls to C<prompt()> will no longer read
  data from C<*ARGV>. Instead they will read it from
  the supplied input data.
  
  Moreover, each call to C<prompt()> will simulate the typing-in process
  automatically. That is, C<prompt()> uses a special input mode where,
  each time you press a keyboard letter, it echoes not that character, but
  rather the next character from the specified input. The effect is that
  you can just type on the keyboard at random, but have the correct input
  appear. This greatly increases the convincingness of the simulation.
  
  If at any point, you hit C<< <ENTER>/<RETURN> >> on the keyboard, C<prompt()>
  finishes typing in the input for you (using a realistic typing speed),
  and returns the input string. So you can also just hit C<< <ENTER>/<RETURN> >>
  when the prompt first appears, to have the entire line of input typed
  for you.
  
  Alternatively, if you hit C<< <ESC> >> at any point, C<prompt()> escapes
  from the simulated input mode for that particular call to C<prompt()>,
  and allows you to (temporarily) type text in directly. If you enter only
  a single C<< <ESC> >>, then C<prompt()> throws away the current line of
  simulated input; if you enter two C<< <ESC> >>'s, the simulated input is
  merely deferred to the next call to C<prompt()>.
  
  All these keyboard behaviours require the Term::ReadKey module to be
  available. If it isn't, C<prompt()> falls back on a simpler simulation,
  where it just autotypes each entire line for you and pauses at the
  end of the line, waiting for you to hit C<< <ENTER>/<RETURN> >> manually.
  
  Note that any line of the simulated input that begins with
  a <CTRL-D> or <CTRL-Z> is treated as an input failure (just as
  if you'd typed that character as input).
  
  =head1 DIAGNOSTICS
  
  All non-fatal diagnostics can be disabled using a C<no warnings> with the
  appropriate category.
  
  =over
  
  =item C<< prompt(): Can't open *ARGV: %s >>
  
  (F)  By default, C<prompt()> attempts to read input from
       the C<*ARGV> filehandle. However, it failed to open
       that filehandle. The reason is specified at the end of
       the message.
  
  
  =item C<< prompt(): Missing value for %s (expected %s) >>
  
  (F)  A named option that requires an argument was specified,
       but no argument was provided after the option. See
       L<"Summary of options">.
  
  
  =item C<< prompt(): Invalid value for %s (expected %s) >>
  
  (F)  The named option specified expects an particular type
       of argument, but found one of an incompatible type
       instead. See L<"Summary of options">.
  
  
  =item C<< prompt(): Unknown option %s ignored >>
  
  (W misc)  C<prompt()> was passed a string starting with
            a hyphen, but could not parse that string as a
            valid option. The option may have been misspelt.
            Alternatively, if the string was supposed to be
            (part of) the prompt, it will be necessary to use
            L<the C<-prompt> option|"Specifying what to
            prompt"> to specify it.
  
  
  =item C<< prompt(): Unexpected argument (% ref) ignored >>
  
  (W reserved)  C<prompt()> was passed a reference to
                an array or hash or subroutine in a position
                where an option flag or a prompt string was
                expected. This may indicate that a string
                variable in the argument list didn't contain
                what was expected, or a reference variable was
                not properly dereferenced. Alternatively, the
                argument may have been intended as the
                argument to an option, but has become
                separated from it somehow, or perhaps the
                option was deleted without removing the
                argument as well.
  
  
  =item C<< Useless use of prompt() in void context >>
  
  (W void)  C<prompt()> was called but its return value was
            not stored or used in any way. Since the
            subroutine has no side effects in void context,
            calling it this way achieves nothing. Either make
            use of the return value directly or, if the usage
            is deliberate, put a C<scalar> in front of the
            call to remove the void context.
  
  
  =item C<< prompt(): -default value does not satisfy -must constraints >>
  
  (W misc)  The C<-must> flag was used to specify one or more
            input constraints. The C<-default> flag was also
            specified. Unfortunately, the default value
            provided did not satisfy the requirements
            specified by the C<-must> flag. The call to
            C<prompt()> will still go ahead (after issuing the
            warning), but the default value will never be
            returned, since the constraint check will reject
            it. It is probably better simply to include the
            default value in the list of constraints.
  
  
  =item C<< prompt(): -keyletters found too many defaults >>
  
  (W ambiguous)  The C<-keyletters> option was specified,
                 but analysis of the prompt revealed two or
                 more character sequences enclosed in square
                 brackets. Since such sequences are taken to
                 indicate a default value, having two or more
                 makes the default ambiguous. The prompt
                 should be rewritten with no more than one set
                 of square brackets.
  
  
  =item C<< Warning: next input will be in plaintext >>
  
  (W bareword)  The C<prompt()> subroutine was called with
                the C<-echo> flag, but the Term::ReadKey
                module was not available to implement this
                feature. The input will proceed as normal, but
                this warning is issued to ensure that the user
                doesn't type in something secret, expecting it
                to remain hidden, which it won't.
  
  
  =item C<< prompt(): Too many menu items. Ignoring the final %d >>
  
  (W misc)  A C<-menu> was specified with more than 52 choices.
            Because, by default, menus use upper and lower-
            case alphabetic characters as their selectors,
            there were no available selectors for the extra
            items after the first 52. Either reduce the number
            of choices to 52 or less, or else add the
            C<-number> option to use numeric selectors instead.
  
  =back
  
  
  =head1 CONFIGURATION AND ENVIRONMENT
  
  IO::Prompter can be configured by setting any of the following
  environment variables:
  
  =over
  
  =item C<$IO_PROMPTER_COMPLETE_KEY>
  
  Specifies the key used to initiate
  L<user-specified completions|"Input autocompletion">.
  Defaults to <TAB>
  
  =item C<$IO_PROMPTER_HISTORY_KEY>
  
  Specifies the key used to initiate
  L<history completions|"Completing from your input history">.
  Defaults to <CTRL-R>
  
  =item C<$IO_PROMPTER_COMPLETE_MODES>
  
  Specifies the
  L<response sequence|"Configuring the autocompletion interaction">
  for user-defined completions.  Defaults to C<'list+longest  full'>
  
  =item C<$IO_PROMPTER_HISTORY_MODES>
  
  Specifies the
  L<response sequence|"Configuring the autocompletion interaction">
  for history completions.  Defaults to C<'full'>.
  
  =back
  
  
  =head1 DEPENDENCIES
  
  Requires the Contextual::Return module.
  
  The module also works much better if Term::ReadKey is available
  (though this is not essential).
  
  
  =head1 INCOMPATIBILITIES
  
  This module does not play well with Moose (or more specifically, with
  Moose::Exporter) because both of them try to play sneaky games with
  Scalar::Util::blessed.
  
  The current solution is to make sure that you load Moose before
  loading IO::Prompter. Even just doing this:
  
      use Moose ();
      use IO::Prompter;
  
  is sufficient.
  
  
  =head1 BUGS AND LIMITATIONS
  
  No unresolved bugs have been reported.
  
  Please report any bugs or feature requests to
  C<bug-io-prompter@rt.cpan.org>, or through the web interface at
  L<http://rt.cpan.org>.
  
  
  =head1 AUTHOR
  
  Damian Conway  C<< <DCONWAY@CPAN.org> >>
  
  
  =head1 LICENCE AND COPYRIGHT
  
  Copyright (c) 2009, Damian Conway C<< <DCONWAY@CPAN.org> >>.
  All rights reserved.
  
  This module is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself. See L<perlartistic>.
  
  
  =head1 DISCLAIMER OF WARRANTY
  
  BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
  PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
  EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
  ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
  YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
  NECESSARY SERVICING, REPAIR, OR CORRECTION.
  
  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
  LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
  OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
  THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
  FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
  SUCH DAMAGES.
IO_PROMPTER

$fatpacked{"IPC/Run.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN';
  package IPC::Run;
  use bytes;
  
  =pod
  
  =head1 NAME
  
  IPC::Run - system() and background procs w/ piping, redirs, ptys (Unix, Win32)
  
  =head1 SYNOPSIS
  
     ## First,a command to run:
        my @cat = qw( cat );
  
     ## Using run() instead of system():
        use IPC::Run qw( run timeout );
  
        run \@cat, \$in, \$out, \$err, timeout( 10 ) or die "cat: $?";
  
        # Can do I/O to sub refs and filenames, too:
        run \@cat, '<', "in.txt", \&out, \&err or die "cat: $?";
        run \@cat, '<', "in.txt", '>>', "out.txt", '2>>', "err.txt";
  
  
        # Redirecting using pseudo-terminals instead of pipes.
        run \@cat, '<pty<', \$in,  '>pty>', \$out_and_err;
  
     ## Scripting subprocesses (like Expect):
  
        use IPC::Run qw( start pump finish timeout );
  
        # Incrementally read from / write to scalars. 
        # $in is drained as it is fed to cat's stdin,
        # $out accumulates cat's stdout
        # $err accumulates cat's stderr
        # $h is for "harness".
        my $h = start \@cat, \$in, \$out, \$err, timeout( 10 );
  
        $in .= "some input\n";
        pump $h until $out =~ /input\n/g;
  
        $in .= "some more input\n";
        pump $h until $out =~ /\G.*more input\n/;
  
        $in .= "some final input\n";
        finish $h or die "cat returned $?";
  
        warn $err if $err; 
        print $out;         ## All of cat's output
  
     # Piping between children
        run \@cat, '|', \@gzip;
  
     # Multiple children simultaneously (run() blocks until all
     # children exit, use start() for background execution):
        run \@foo1, '&', \@foo2;
  
     # Calling \&set_up_child in the child before it executes the
     # command (only works on systems with true fork() & exec())
     # exceptions thrown in set_up_child() will be propagated back
     # to the parent and thrown from run().
        run \@cat, \$in, \$out,
           init => \&set_up_child;
  
     # Read from / write to file handles you open and close
        open IN,  '<in.txt'  or die $!;
        open OUT, '>out.txt' or die $!;
        print OUT "preamble\n";
        run \@cat, \*IN, \*OUT or die "cat returned $?";
        print OUT "postamble\n";
        close IN;
        close OUT;
  
     # Create pipes for you to read / write (like IPC::Open2 & 3).
        $h = start
           \@cat,
              '<pipe', \*IN, # may also be a lexical filehandle e.g. \my $infh
              '>pipe', \*OUT,
              '2>pipe', \*ERR 
           or die "cat returned $?";
        print IN "some input\n";
        close IN;
        print <OUT>, <ERR>;
        finish $h;
  
     # Mixing input and output modes
        run \@cat, 'in.txt', \&catch_some_out, \*ERR_LOG;
  
     # Other redirection constructs
        run \@cat, '>&', \$out_and_err;
        run \@cat, '2>&1';
        run \@cat, '0<&3';
        run \@cat, '<&-';
        run \@cat, '3<', \$in3;
        run \@cat, '4>', \$out4;
        # etc.
  
     # Passing options:
        run \@cat, 'in.txt', debug => 1;
  
     # Call this system's shell, returns TRUE on 0 exit code
     # THIS IS THE OPPOSITE SENSE OF system()'s RETURN VALUE
        run "cat a b c" or die "cat returned $?";
  
     # Launch a sub process directly, no shell.  Can't do redirection
     # with this form, it's here to behave like system() with an
     # inverted result.
        $r = run "cat a b c";
  
     # Read from a file in to a scalar
        run io( "filename", 'r', \$recv );
        run io( \*HANDLE,   'r', \$recv );
  
  =head1 DESCRIPTION
  
  IPC::Run allows you to run and interact with child processes using files, pipes,
  and pseudo-ttys.  Both system()-style and scripted usages are supported and
  may be mixed.  Likewise, functional and OO API styles are both supported and
  may be mixed.
  
  Various redirection operators reminiscent of those seen on common Unix and DOS
  command lines are provided.
  
  Before digging in to the details a few LIMITATIONS are important enough
  to be mentioned right up front:
  
  =over
  
  =item Win32 Support
  
  Win32 support is working but B<EXPERIMENTAL>, but does pass all relevant tests
  on NT 4.0.  See L</Win32 LIMITATIONS>.
  
  =item pty Support
  
  If you need pty support, IPC::Run should work well enough most of the
  time, but IO::Pty is being improved, and IPC::Run will be improved to
  use IO::Pty's new features when it is released.
  
  The basic problem is that the pty needs to initialize itself before the
  parent writes to the master pty, or the data written gets lost.  So
  IPC::Run does a sleep(1) in the parent after forking to (hopefully) give
  the child a chance to run.  This is a kludge that works well on non
  heavily loaded systems :(.
  
  ptys are not supported yet under Win32, but will be emulated...
  
  =item Debugging Tip
  
  You may use the environment variable C<IPCRUNDEBUG> to see what's going on
  under the hood:
  
     $ IPCRUNDEBUG=basic   myscript     # prints minimal debugging
     $ IPCRUNDEBUG=data    myscript     # prints all data reads/writes
     $ IPCRUNDEBUG=details myscript     # prints lots of low-level details
     $ IPCRUNDEBUG=gory    myscript     # (Win32 only) prints data moving through
                                        # the helper processes.
  
  =back
  
  We now return you to your regularly scheduled documentation.
  
  =head2 Harnesses
  
  Child processes and I/O handles are gathered in to a harness, then
  started and run until the processing is finished or aborted.
  
  =head2 run() vs. start(); pump(); finish();
  
  There are two modes you can run harnesses in: run() functions as an
  enhanced system(), and start()/pump()/finish() allow for background
  processes and scripted interactions with them.
  
  When using run(), all data to be sent to the harness is set up in
  advance (though one can feed subprocesses input from subroutine refs to
  get around this limitation). The harness is run and all output is
  collected from it, then any child processes are waited for:
  
     run \@cmd, \<<IN, \$out;
     blah
     IN
  
     ## To precompile harnesses and run them later:
     my $h = harness \@cmd, \<<IN, \$out;
     blah
     IN
  
     run $h;
  
  The background and scripting API is provided by start(), pump(), and
  finish(): start() creates a harness if need be (by calling harness())
  and launches any subprocesses, pump() allows you to poll them for
  activity, and finish() then monitors the harnessed activities until they
  complete.
  
     ## Build the harness, open all pipes, and launch the subprocesses
     my $h = start \@cat, \$in, \$out;
     $in = "first input\n";
  
     ## Now do I/O.  start() does no I/O.
     pump $h while length $in;  ## Wait for all input to go
  
     ## Now do some more I/O.
     $in = "second input\n";
     pump $h until $out =~ /second input/;
  
     ## Clean up
     finish $h or die "cat returned $?";
  
  You can optionally compile the harness with harness() prior to
  start()ing or run()ing, and you may omit start() between harness() and
  pump().  You might want to do these things if you compile your harnesses
  ahead of time.
  
  =head2 Using regexps to match output
  
  As shown in most of the scripting examples, the read-to-scalar facility
  for gathering subcommand's output is often used with regular expressions
  to detect stopping points.  This is because subcommand output often
  arrives in dribbles and drabs, often only a character or line at a time.
  This output is input for the main program and piles up in variables like
  the C<$out> and C<$err> in our examples.
  
  Regular expressions can be used to wait for appropriate output in
  several ways.  The C<cat> example in the previous section demonstrates
  how to pump() until some string appears in the output.  Here's an
  example that uses C<smb> to fetch files from a remote server:
  
     $h = harness \@smbclient, \$in, \$out;
  
     $in = "cd /src\n";
     $h->pump until $out =~ /^smb.*> \Z/m;
     die "error cding to /src:\n$out" if $out =~ "ERR";
     $out = '';
  
     $in = "mget *\n";
     $h->pump until $out =~ /^smb.*> \Z/m;
     die "error retrieving files:\n$out" if $out =~ "ERR";
  
     $in = "quit\n";
     $h->finish;
  
  Notice that we carefully clear $out after the first command/response
  cycle? That's because IPC::Run does not delete $out when we continue,
  and we don't want to trip over the old output in the second
  command/response cycle.
  
  Say you want to accumulate all the output in $out and analyze it
  afterwards.  Perl offers incremental regular expression matching using
  the C<m//gc> and pattern matching idiom and the C<\G> assertion.
  IPC::Run is careful not to disturb the current C<pos()> value for
  scalars it appends data to, so we could modify the above so as not to
  destroy $out by adding a couple of C</gc> modifiers.  The C</g> keeps us
  from tripping over the previous prompt and the C</c> keeps us from
  resetting the prior match position if the expected prompt doesn't
  materialize immediately:
  
     $h = harness \@smbclient, \$in, \$out;
  
     $in = "cd /src\n";
     $h->pump until $out =~ /^smb.*> \Z/mgc;
     die "error cding to /src:\n$out" if $out =~ "ERR";
  
     $in = "mget *\n";
     $h->pump until $out =~ /^smb.*> \Z/mgc;
     die "error retrieving files:\n$out" if $out =~ "ERR";
  
     $in = "quit\n";
     $h->finish;
  
     analyze( $out );
  
  When using this technique, you may want to preallocate $out to have
  plenty of memory or you may find that the act of growing $out each time
  new input arrives causes an C<O(length($out)^2)> slowdown as $out grows.
  Say we expect no more than 10,000 characters of input at the most.  To
  preallocate memory to $out, do something like:
  
     my $out = "x" x 10_000;
     $out = "";
  
  C<perl> will allocate at least 10,000 characters' worth of space, then
  mark the $out as having 0 length without freeing all that yummy RAM.
  
  =head2 Timeouts and Timers
  
  More than likely, you don't want your subprocesses to run forever, and
  sometimes it's nice to know that they're going a little slowly.
  Timeouts throw exceptions after a some time has elapsed, timers merely
  cause pump() to return after some time has elapsed.  Neither is
  reset/restarted automatically.
  
  Timeout objects are created by calling timeout( $interval ) and passing
  the result to run(), start() or harness().  The timeout period starts
  ticking just after all the child processes have been fork()ed or
  spawn()ed, and are polled for expiration in run(), pump() and finish().
  If/when they expire, an exception is thrown.  This is typically useful
  to keep a subprocess from taking too long.
  
  If a timeout occurs in run(), all child processes will be terminated and
  all file/pipe/ptty descriptors opened by run() will be closed.  File
  descriptors opened by the parent process and passed in to run() are not
  closed in this event.
  
  If a timeout occurs in pump(), pump_nb(), or finish(), it's up to you to
  decide whether to kill_kill() all the children or to implement some more
  graceful fallback.  No I/O will be closed in pump(), pump_nb() or
  finish() by such an exception (though I/O is often closed down in those
  routines during the natural course of events).
  
  Often an exception is too harsh.  timer( $interval ) creates timer
  objects that merely prevent pump() from blocking forever.  This can be
  useful for detecting stalled I/O or printing a soothing message or "."
  to pacify an anxious user.
  
  Timeouts and timers can both be restarted at any time using the timer's
  start() method (this is not the start() that launches subprocesses).  To
  restart a timer, you need to keep a reference to the timer:
  
     ## Start with a nice long timeout to let smbclient connect.  If
     ## pump or finish take too long, an exception will be thrown.
  
   my $h;
   eval {
     $h = harness \@smbclient, \$in, \$out, \$err, ( my $t = timeout 30 );
     sleep 11;  # No effect: timer not running yet
  
     start $h;
     $in = "cd /src\n";
     pump $h until ! length $in;
  
     $in = "ls\n";
     ## Now use a short timeout, since this should be faster
     $t->start( 5 );
     pump $h until ! length $in;
  
     $t->start( 10 );  ## Give smbclient a little while to shut down.
     $h->finish;
   };
   if ( $@ ) {
     my $x = $@;    ## Preserve $@ in case another exception occurs
     $h->kill_kill; ## kill it gently, then brutally if need be, or just
                     ## brutally on Win32.
     die $x;
   }
  
  Timeouts and timers are I<not> checked once the subprocesses are shut
  down; they will not expire in the interval between the last valid
  process and when IPC::Run scoops up the processes' result codes, for
  instance.
  
  =head2 Spawning synchronization, child exception propagation
  
  start() pauses the parent until the child executes the command or CODE
  reference and propagates any exceptions thrown (including exec()
  failure) back to the parent.  This has several pleasant effects: any
  exceptions thrown in the child, including exec() failure, come flying
  out of start() or run() as though they had occurred in the parent.
  
  This includes exceptions your code thrown from init subs.  In this
  example:
  
     eval {
        run \@cmd, init => sub { die "blast it! foiled again!" };
     };
     print $@;
  
  the exception "blast it! foiled again" will be thrown from the child
  process (preventing the exec()) and printed by the parent.
  
  In situations like
  
     run \@cmd1, "|", \@cmd2, "|", \@cmd3;
  
  @cmd1 will be initted and exec()ed before @cmd2, and @cmd2 before @cmd3.
  This can save time and prevent oddball errors emitted by later commands
  when earlier commands fail to execute.  Note that IPC::Run doesn't start
  any commands unless it can find the executables referenced by all
  commands.  These executables must pass both the C<-f> and C<-x> tests
  described in L<perlfunc>.
  
  Another nice effect is that init() subs can take their time doing things
  and there will be no problems caused by a parent continuing to execute
  before a child's init() routine is complete.  Say the init() routine
  needs to open a socket or a temp file that the parent wants to connect
  to; without this synchronization, the parent will need to implement a
  retry loop to wait for the child to run, since often, the parent gets a
  lot of things done before the child's first timeslice is allocated.
  
  This is also quite necessary for pseudo-tty initialization, which needs
  to take place before the parent writes to the child via pty.  Writes
  that occur before the pty is set up can get lost.
  
  A final, minor, nicety is that debugging output from the child will be
  emitted before the parent continues on, making for much clearer debugging
  output in complex situations.
  
  The only drawback I can conceive of is that the parent can't continue to
  operate while the child is being initted.  If this ever becomes a
  problem in the field, we can implement an option to avoid this behavior,
  but I don't expect it to.
  
  B<Win32>: executing CODE references isn't supported on Win32, see
  L</Win32 LIMITATIONS> for details.
  
  =head2 Syntax
  
  run(), start(), and harness() can all take a harness specification
  as input.  A harness specification is either a single string to be passed
  to the systems' shell:
  
     run "echo 'hi there'";
  
  or a list of commands, io operations, and/or timers/timeouts to execute.
  Consecutive commands must be separated by a pipe operator '|' or an '&'.
  External commands are passed in as array references or L<IPC::Run::Win32Process>
  objects.  On systems supporting fork(), Perl code may be passed in as subs:
  
     run \@cmd;
     run \@cmd1, '|', \@cmd2;
     run \@cmd1, '&', \@cmd2;
     run \&sub1;
     run \&sub1, '|', \&sub2;
     run \&sub1, '&', \&sub2;
  
  '|' pipes the stdout of \@cmd1 the stdin of \@cmd2, just like a
  shell pipe.  '&' does not.  Child processes to the right of a '&'
  will have their stdin closed unless it's redirected-to.
  
  L<IPC::Run::IO> objects may be passed in as well, whether or not
  child processes are also specified:
  
     run io( "infile", ">", \$in ), io( "outfile", "<", \$in );
        
  as can L<IPC::Run::Timer> objects:
  
     run \@cmd, io( "outfile", "<", \$in ), timeout( 10 );
  
  Commands may be followed by scalar, sub, or i/o handle references for
  redirecting
  child process input & output:
  
     run \@cmd,  \undef,            \$out;
     run \@cmd,  \$in,              \$out;
     run \@cmd1, \&in, '|', \@cmd2, \*OUT;
     run \@cmd1, \*IN, '|', \@cmd2, \&out;
  
  This is known as succinct redirection syntax, since run(), start()
  and harness(), figure out which file descriptor to redirect and how.
  File descriptor 0 is presumed to be an input for
  the child process, all others are outputs.  The assumed file
  descriptor always starts at 0, unless the command is being piped to,
  in which case it starts at 1.
  
  To be explicit about your redirects, or if you need to do more complex
  things, there's also a redirection operator syntax:
  
     run \@cmd, '<', \undef, '>',  \$out;
     run \@cmd, '<', \undef, '>&', \$out_and_err;
     run(
        \@cmd1,
           '<', \$in,
        '|', \@cmd2,
           \$out
     );
  
  Operator syntax is required if you need to do something other than simple
  redirection to/from scalars or subs, like duping or closing file descriptors
  or redirecting to/from a named file.  The operators are covered in detail
  below.
  
  After each \@cmd (or \&foo), parsing begins in succinct mode and toggles to
  operator syntax mode when an operator (ie plain scalar, not a ref) is seen.
  Once in
  operator syntax mode, parsing only reverts to succinct mode when a '|' or
  '&' is seen.
  
  In succinct mode, each parameter after the \@cmd specifies what to
  do with the next highest file descriptor. These File descriptor start
  with 0 (stdin) unless stdin is being piped to (C<'|', \@cmd>), in which
  case they start with 1 (stdout).  Currently, being on the left of
  a pipe (C<\@cmd, \$out, \$err, '|'>) does I<not> cause stdout to be
  skipped, though this may change since it's not as DWIMerly as it
  could be.  Only stdin is assumed to be an
  input in succinct mode, all others are assumed to be outputs.
  
  If no piping or redirection is specified for a child, it will inherit
  the parent's open file handles as dictated by your system's
  close-on-exec behavior and the $^F flag, except that processes after a
  '&' will not inherit the parent's stdin. Also note that $^F does not
  affect file descriptors obtained via POSIX, since it only applies to
  full-fledged Perl file handles.  Such processes will have their stdin
  closed unless it has been redirected-to.
  
  If you want to close a child processes stdin, you may do any of:
  
     run \@cmd, \undef;
     run \@cmd, \"";
     run \@cmd, '<&-';
     run \@cmd, '0<&-';
  
  Redirection is done by placing redirection specifications immediately 
  after a command or child subroutine:
  
     run \@cmd1,      \$in, '|', \@cmd2,      \$out;
     run \@cmd1, '<', \$in, '|', \@cmd2, '>', \$out;
  
  If you omit the redirection operators, descriptors are counted
  starting at 0.  Descriptor 0 is assumed to be input, all others
  are outputs.  A leading '|' consumes descriptor 0, so this
  works as expected.
  
     run \@cmd1, \$in, '|', \@cmd2, \$out;
     
  The parameter following a redirection operator can be a scalar ref,
  a subroutine ref, a file name, an open filehandle, or a closed
  filehandle.
  
  If it's a scalar ref, the child reads input from or sends output to
  that variable:
  
     $in = "Hello World.\n";
     run \@cat, \$in, \$out;
     print $out;
  
  Scalars used in incremental (start()/pump()/finish()) applications are treated
  as queues: input is removed from input scalers, resulting in them dwindling
  to '', and output is appended to output scalars.  This is not true of 
  harnesses run() in batch mode.
  
  It's usually wise to append new input to be sent to the child to the input
  queue, and you'll often want to zap output queues to '' before pumping.
  
     $h = start \@cat, \$in;
     $in = "line 1\n";
     pump $h;
     $in .= "line 2\n";
     pump $h;
     $in .= "line 3\n";
     finish $h;
  
  The final call to finish() must be there: it allows the child process(es)
  to run to completion and waits for their exit values.
  
  =head1 OBSTINATE CHILDREN
  
  Interactive applications are usually optimized for human use.  This
  can help or hinder trying to interact with them through modules like
  IPC::Run.  Frequently, programs alter their behavior when they detect
  that stdin, stdout, or stderr are not connected to a tty, assuming that
  they are being run in batch mode.  Whether this helps or hurts depends
  on which optimizations change.  And there's often no way of telling
  what a program does in these areas other than trial and error and
  occasionally, reading the source.  This includes different versions
  and implementations of the same program.
  
  All hope is not lost, however.  Most programs behave in reasonably
  tractable manners, once you figure out what it's trying to do.
  
  Here are some of the issues you might need to be aware of.
  
  =over
  
  =item *
  
  fflush()ing stdout and stderr
  
  This lets the user see stdout and stderr immediately.  Many programs
  undo this optimization if stdout is not a tty, making them harder to
  manage by things like IPC::Run.
  
  Many programs decline to fflush stdout or stderr if they do not
  detect a tty there.  Some ftp commands do this, for instance.
  
  If this happens to you, look for a way to force interactive behavior,
  like a command line switch or command.  If you can't, you will
  need to use a pseudo terminal ('<pty<' and '>pty>').
  
  =item *
  
  false prompts
  
  Interactive programs generally do not guarantee that output from user
  commands won't contain a prompt string.  For example, your shell prompt
  might be a '$', and a file named '$' might be the only file in a directory
  listing.
  
  This can make it hard to guarantee that your output parser won't be fooled
  into early termination of results.
  
  To help work around this, you can see if the program can alter it's 
  prompt, and use something you feel is never going to occur in actual
  practice.
  
  You should also look for your prompt to be the only thing on a line:
  
     pump $h until $out =~ /^<SILLYPROMPT>\s?\z/m;
  
  (use C<(?!\n)\Z> in place of C<\z> on older perls).
  
  You can also take the approach that IPC::ChildSafe takes and emit a
  command with known output after each 'real' command you issue, then
  look for this known output.  See new_appender() and new_chunker() for
  filters that can help with this task.
  
  If it's not convenient or possibly to alter a prompt or use a known
  command/response pair, you might need to autodetect the prompt in case
  the local version of the child program is different then the one
  you tested with, or if the user has control over the look & feel of
  the prompt.
  
  =item *
  
  Refusing to accept input unless stdin is a tty.
  
  Some programs, for security reasons, will only accept certain types
  of input from a tty.  su, notable, will not prompt for a password unless
  it's connected to a tty.
  
  If this is your situation, use a pseudo terminal ('<pty<' and '>pty>').
  
  =item *
  
  Not prompting unless connected to a tty.
  
  Some programs don't prompt unless stdin or stdout is a tty.  See if you can
  turn prompting back on.  If not, see if you can come up with a command that
  you can issue after every real command and look for it's output, as
  IPC::ChildSafe does.   There are two filters included with IPC::Run that
  can help with doing this: appender and chunker (see new_appender() and
  new_chunker()).
  
  =item *
  
  Different output format when not connected to a tty.
  
  Some commands alter their formats to ease machine parsability when they
  aren't connected to a pipe.  This is actually good, but can be surprising.
  
  =back
  
  =head1 PSEUDO TERMINALS
  
  On systems providing pseudo terminals under /dev, IPC::Run can use IO::Pty
  (available on CPAN) to provide a terminal environment to subprocesses.
  This is necessary when the subprocess really wants to think it's connected
  to a real terminal.
  
  =head2 CAVEATS
  
  Pseudo-terminals are not pipes, though they are similar.  Here are some
  differences to watch out for.
  
  =over
  
  =item Echoing
  
  Sending to stdin will cause an echo on stdout, which occurs before each
  line is passed to the child program.  There is currently no way to
  disable this, although the child process can and should disable it for
  things like passwords.
  
  =item Shutdown
  
  IPC::Run cannot close a pty until all output has been collected.  This
  means that it is not possible to send an EOF to stdin by half-closing
  the pty, as we can when using a pipe to stdin.
  
  This means that you need to send the child process an exit command or
  signal, or run() / finish() will time out.  Be careful not to expect a
  prompt after sending the exit command.
  
  =item Command line editing
  
  Some subprocesses, notable shells that depend on the user's prompt
  settings, will reissue the prompt plus the command line input so far
  once for each character.
  
  =item '>pty>' means '&>pty>', not '1>pty>'
  
  The pseudo terminal redirects both stdout and stderr unless you specify
  a file descriptor.  If you want to grab stderr separately, do this:
  
     start \@cmd, '<pty<', \$in, '>pty>', \$out, '2>', \$err;
  
  =item stdin, stdout, and stderr not inherited
  
  Child processes harnessed to a pseudo terminal have their stdin, stdout,
  and stderr completely closed before any redirection operators take
  effect.  This casts of the bonds of the controlling terminal.  This is
  not done when using pipes.
  
  Right now, this affects all children in a harness that has a pty in use,
  even if that pty would not affect a particular child.  That's a bug and
  will be fixed.  Until it is, it's best not to mix-and-match children.
  
  =back
  
  =head2 Redirection Operators
  
     Operator       SHNP   Description
     ========       ====   ===========
     <, N<          SHN    Redirects input to a child's fd N (0 assumed)
  
     >, N>          SHN    Redirects output from a child's fd N (1 assumed)
     >>, N>>        SHN    Like '>', but appends to scalars or named files
     >&, &>         SHN    Redirects stdout & stderr from a child process
  
     <pty, N<pty    S      Like '<', but uses a pseudo-tty instead of a pipe
     >pty, N>pty    S      Like '>', but uses a pseudo-tty instead of a pipe
  
     N<&M                  Dups input fd N to input fd M
     M>&N                  Dups output fd N to input fd M
     N<&-                  Closes fd N
  
     <pipe, N<pipe     P   Pipe opens H for caller to read, write, close.
     >pipe, N>pipe     P   Pipe opens H for caller to read, write, close.
                        
  'N' and 'M' are placeholders for integer file descriptor numbers.  The
  terms 'input' and 'output' are from the child process's perspective.
  
  The SHNP field indicates what parameters an operator can take:
  
     S: \$scalar or \&function references.  Filters may be used with
        these operators (and only these).
     H: \*HANDLE or IO::Handle for caller to open, and close
     N: "file name".
     P: \*HANDLE or lexical filehandle opened by IPC::Run as the parent end of a pipe, but read
        and written to and closed by the caller (like IPC::Open3).
  
  =over
  
  =item Redirecting input: [n]<, [n]<pipe
  
  You can input the child reads on file descriptor number n to come from a
  scalar variable, subroutine, file handle, or a named file.  If stdin
  is not redirected, the parent's stdin is inherited.
  
     run \@cat, \undef          ## Closes child's stdin immediately
        or die "cat returned $?"; 
  
     run \@cat, \$in;
  
     run \@cat, \<<TOHERE;
     blah
     TOHERE
  
     run \@cat, \&input;       ## Calls &input, feeding data returned
                                ## to child's.  Closes child's stdin
                                ## when undef is returned.
  
  Redirecting from named files requires you to use the input
  redirection operator:
  
     run \@cat, '<.profile';
     run \@cat, '<', '.profile';
  
     open IN, "<foo";
     run \@cat, \*IN;
     run \@cat, *IN{IO};
  
  The form used second example here is the safest,
  since filenames like "0" and "&more\n" won't confuse &run:
  
  You can't do either of
  
     run \@a, *IN;      ## INVALID
     run \@a, '<', *IN; ## BUGGY: Reads file named like "*main::A"
     
  because perl passes a scalar containing a string that
  looks like "*main::A" to &run, and &run can't tell the difference
  between that and a redirection operator or a file name.  &run guarantees
  that any scalar you pass after a redirection operator is a file name.
  
  If your child process will take input from file descriptors other
  than 0 (stdin), you can use a redirection operator with any of the
  valid input forms (scalar ref, sub ref, etc.):
  
     run \@cat, '3<', \$in3;
  
  When redirecting input from a scalar ref, the scalar ref is
  used as a queue.  This allows you to use &harness and pump() to
  feed incremental bits of input to a coprocess.  See L</Coprocesses>
  below for more information.
  
  The <pipe operator opens the write half of a pipe on the filehandle
  glob reference it takes as an argument:
  
     $h = start \@cat, '<pipe', \*IN;
     print IN "hello world\n";
     pump $h;
     close IN;
     finish $h;
  
  Unlike the other '<' operators, IPC::Run does nothing further with
  it: you are responsible for it.  The previous example is functionally
  equivalent to:
  
     pipe( \*R, \*IN ) or die $!;
     $h = start \@cat, '<', \*IN;
     print IN "hello world\n";
     pump $h;
     close IN;
     finish $h;
  
  This is like the behavior of IPC::Open2 and IPC::Open3.
  
  B<Win32>: The handle returned is actually a socket handle, so you can
  use select() on it.
  
  =item Redirecting output: [n]>, [n]>>, [n]>&[m], [n]>pipe
  
  You can redirect any output the child emits
  to a scalar variable, subroutine, file handle, or file name.  You
  can have &run truncate or append to named files or scalars.  If
  you are redirecting stdin as well, or if the command is on the
  receiving end of a pipeline ('|'), you can omit the redirection
  operator:
  
     @ls = ( 'ls' );
     run \@ls, \undef, \$out
        or die "ls returned $?"; 
  
     run \@ls, \undef, \&out;  ## Calls &out each time some output
                                ## is received from the child's 
                                ## when undef is returned.
  
     run \@ls, \undef, '2>ls.err';
     run \@ls, '2>', 'ls.err';
  
  The two parameter form guarantees that the filename
  will not be interpreted as a redirection operator:
  
     run \@ls, '>', "&more";
     run \@ls, '2>', ">foo\n";
  
  You can pass file handles you've opened for writing:
  
     open( *OUT, ">out.txt" );
     open( *ERR, ">err.txt" );
     run \@cat, \*OUT, \*ERR;
  
  Passing a scalar reference and a code reference requires a little
  more work, but allows you to capture all of the output in a scalar
  or each piece of output by a callback:
  
  These two do the same things:
  
     run( [ 'ls' ], '2>', sub { $err_out .= $_[0] } );
  
  does the same basic thing as:
  
     run( [ 'ls' ], '2>', \$err_out );
  
  The subroutine will be called each time some data is read from the child.
  
  The >pipe operator is different in concept than the other '>' operators,
  although it's syntax is similar:
  
     $h = start \@cat, $in, '>pipe', \*OUT, '2>pipe', \*ERR;
     $in = "hello world\n";
     finish $h;
     print <OUT>;
     print <ERR>;
     close OUT;
     close ERR;
  
  causes two pipe to be created, with one end attached to cat's stdout
  and stderr, respectively, and the other left open on OUT and ERR, so
  that the script can manually
  read(), select(), etc. on them.  This is like
  the behavior of IPC::Open2 and IPC::Open3.
  
  B<Win32>: The handle returned is actually a socket handle, so you can
  use select() on it.
  
  =item Duplicating output descriptors: >&m, n>&m
  
  This duplicates output descriptor number n (default is 1 if n is omitted)
  from descriptor number m.
  
  =item Duplicating input descriptors: <&m, n<&m
  
  This duplicates input descriptor number n (default is 0 if n is omitted)
  from descriptor number m
  
  =item Closing descriptors: <&-, 3<&-
  
  This closes descriptor number n (default is 0 if n is omitted).  The
  following commands are equivalent:
  
     run \@cmd, \undef;
     run \@cmd, '<&-';
     run \@cmd, '<in.txt', '<&-';
  
  Doing
  
     run \@cmd, \$in, '<&-';    ## SIGPIPE recipe.
  
  is dangerous: the parent will get a SIGPIPE if $in is not empty.
  
  =item Redirecting both stdout and stderr: &>, >&, &>pipe, >pipe&
  
  The following pairs of commands are equivalent:
  
     run \@cmd, '>&', \$out;       run \@cmd, '>', \$out,     '2>&1';
     run \@cmd, '>&', 'out.txt';   run \@cmd, '>', 'out.txt', '2>&1';
  
  etc.
  
  File descriptor numbers are not permitted to the left or the right of
  these operators, and the '&' may occur on either end of the operator.
  
  The '&>pipe' and '>pipe&' variants behave like the '>pipe' operator, except
  that both stdout and stderr write to the created pipe.
  
  =item Redirection Filters
  
  Both input redirections and output redirections that use scalars or
  subs as endpoints may have an arbitrary number of filter subs placed
  between them and the child process.  This is useful if you want to
  receive output in chunks, or if you want to massage each chunk of
  data sent to the child.  To use this feature, you must use operator
  syntax:
  
     run(
        \@cmd
           '<', \&in_filter_2, \&in_filter_1, $in,
           '>', \&out_filter_1, \&in_filter_2, $out,
     );
  
  This capability is not provided for IO handles or named files.
  
  Two filters are provided by IPC::Run: appender and chunker.  Because
  these may take an argument, you need to use the constructor functions
  new_appender() and new_chunker() rather than using \& syntax:
  
     run(
        \@cmd
           '<', new_appender( "\n" ), $in,
           '>', new_chunker, $out,
     );
  
  =back
  
  =head2 Just doing I/O
  
  If you just want to do I/O to a handle or file you open yourself, you
  may specify a filehandle or filename instead of a command in the harness
  specification:
  
     run io( "filename", '>', \$recv );
  
     $h = start io( $io, '>', \$recv );
  
     $h = harness \@cmd, '&', io( "file", '<', \$send );
  
  =head2 Options
  
  Options are passed in as name/value pairs:
  
     run \@cat, \$in, debug => 1;
  
  If you pass the debug option, you may want to pass it in first, so you
  can see what parsing is going on:
  
     run debug => 1, \@cat, \$in;
  
  =over
  
  =item debug
  
  Enables debugging output in parent and child.  Debugging info is emitted
  to the STDERR that was present when IPC::Run was first C<use()>ed (it's
  C<dup()>ed out of the way so that it can be redirected in children without
  having debugging output emitted on it).
  
  =back
  
  =head1 RETURN VALUES
  
  harness() and start() return a reference to an IPC::Run harness.  This is
  blessed in to the IPC::Run package, so you may make later calls to
  functions as members if you like:
  
     $h = harness( ... );
     $h->start;
     $h->pump;
     $h->finish;
  
     $h = start( .... );
     $h->pump;
     ...
  
  Of course, using method call syntax lets you deal with any IPC::Run
  subclasses that might crop up, but don't hold your breath waiting for
  any.
  
  run() and finish() return TRUE when all subcommands exit with a 0 result
  code.  B<This is the opposite of perl's system() command>.
  
  All routines raise exceptions (via die()) when error conditions are
  recognized.  A non-zero command result is not treated as an error
  condition, since some commands are tests whose results are reported 
  in their exit codes.
  
  =head1 ROUTINES
  
  =over
  
  =cut
  
  use strict;
  use warnings;
  use Exporter ();
  use vars qw{$VERSION @ISA @FILTER_IMP @FILTERS @API @EXPORT_OK %EXPORT_TAGS};
  
  BEGIN {
      $VERSION = '20220807.0';
      @ISA     = qw{ Exporter };
  
      ## We use @EXPORT for the end user's convenience: there's only one function
      ## exported, it's homonymous with the module, it's an unusual name, and
      ## it can be suppressed by "use IPC::Run ();".
      @FILTER_IMP = qw( input_avail get_more_input );
      @FILTERS    = qw(
        new_appender
        new_chunker
        new_string_source
        new_string_sink
      );
      @API = qw(
        run
        harness start pump pumpable finish
        signal kill_kill reap_nb
        io timer timeout
        close_terminal
        binary
      );
      @EXPORT_OK = ( @API, @FILTER_IMP, @FILTERS, qw( Win32_MODE ) );
      %EXPORT_TAGS = (
          'filter_imp' => \@FILTER_IMP,
          'all'        => \@EXPORT_OK,
          'filters'    => \@FILTERS,
          'api'        => \@API,
      );
  
  }
  
  use strict;
  use warnings;
  use IPC::Run::Debug;
  use Exporter;
  use Fcntl;
  use POSIX ();
  
  BEGIN {
      if ( $] < 5.008 ) { require Symbol; }
  }
  use Carp;
  use File::Spec ();
  use IO::Handle;
  require IPC::Run::IO;
  require IPC::Run::Timer;
  
  use constant Win32_MODE => $^O =~ /os2|Win32/i;
  
  BEGIN {
      if (Win32_MODE) {
          eval "use IPC::Run::Win32Helper; 1;"
            or ( $@ && die )
            or die "$!";
      }
      else {
          eval "use File::Basename; 1;" or die $!;
      }
  }
  
  sub input_avail();
  sub get_more_input();
  
  ###############################################################################
  
  ##
  ## Error constants, not too locale-dependent
  use vars qw( $_EIO $_EAGAIN );
  use Errno qw(   EIO   EAGAIN );
  
  BEGIN {
      local $!;
      $!       = EIO;
      $_EIO    = qr/^$!/;
      $!       = EAGAIN;
      $_EAGAIN = qr/^$!/;
  }
  
  ##
  ## State machine states, set in $self->{STATE}
  ##
  ## These must be in ascending order numerically
  ##
  sub _newed()     { 0 }
  sub _harnessed() { 1 }
  sub _finished()  { 2 }    ## _finished behave almost exactly like _harnessed
  sub _started()   { 3 }
  
  ##
  ## Which fds have been opened in the parent.  This may have extra fds, since
  ## we aren't all that rigorous about closing these off, but that's ok.  This
  ## is used on Unixish OSs to close all fds in the child that aren't needed
  ## by that particular child.
  my %fds;
  
  ## There's a bit of hackery going on here.
  ##
  ## We want to have any code anywhere be able to emit
  ## debugging statements without knowing what harness the code is
  ## being called in/from, since we'd need to pass a harness around to
  ## everything.
  ##
  ## Thus, $cur_self was born.
  
  use vars qw( $cur_self );
  
  sub _debug_fd {
      return fileno STDERR unless defined $cur_self;
  
      if ( _debugging && !defined $cur_self->{DEBUG_FD} ) {
          my $fd = select STDERR;
          $| = 1;
          select $fd;
          $cur_self->{DEBUG_FD} = POSIX::dup fileno STDERR;
          _debug("debugging fd is $cur_self->{DEBUG_FD}\n")
            if _debugging_details;
      }
  
      return fileno STDERR unless defined $cur_self->{DEBUG_FD};
  
      return $cur_self->{DEBUG_FD};
  }
  
  sub DESTROY {
      ## We absolutely do not want to do anything else here.  We are likely
      ## to be in a child process and we don't want to do things like kill_kill
      ## ourself or cause other destruction.
      my IPC::Run $self = shift;
      POSIX::close $self->{DEBUG_FD} if defined $self->{DEBUG_FD};
      $self->{DEBUG_FD} = undef;
  
      for my $kid ( @{$self->{KIDS}} ) {
          for my $op ( @{$kid->{OPS}} ) {
              delete $op->{FILTERS};
          }
      }
  }
  
  ##
  ## Support routines (NOT METHODS)
  ##
  my %cmd_cache;
  
  sub _search_path {
      my ($cmd_name) = @_;
      if ( File::Spec->file_name_is_absolute($cmd_name) && -x $cmd_name ) {
          _debug "'", $cmd_name, "' is absolute"
            if _debugging_details;
          return $cmd_name;
      }
  
      my $dirsep = (
            Win32_MODE     ? '[/\\\\]'
          : $^O =~ /MacOS/ ? ':'
          : $^O =~ /VMS/   ? '[\[\]]'
          :                  '/'
      );
  
      if (   Win32_MODE
          && ( $cmd_name =~ /$dirsep/ )
          && ( $cmd_name !~ m!\.[^\\/\.]+$! ) ) {
  
          _debug "no extension(.exe), checking ENV{PATHEXT}" if _debugging;
          for ( split /;/, $ENV{PATHEXT} || ".COM;.BAT;.EXE" ) {
              my $name = "$cmd_name$_";
              $cmd_name = $name, last if -f $name && -x _;
          }
          _debug "cmd_name is now '$cmd_name'" if _debugging;
      }
  
      if ( $cmd_name =~ /($dirsep)/ ) {
          _debug "'$cmd_name' contains '$1'" if _debugging;
          croak "file not found: $cmd_name"    unless -e $cmd_name;
          croak "not a file: $cmd_name"        unless -f $cmd_name;
          croak "permission denied: $cmd_name" unless -x $cmd_name;
          return $cmd_name;
      }
  
      if ( exists $cmd_cache{$cmd_name} ) {
          _debug "'$cmd_name' found in cache: '$cmd_cache{$cmd_name}'"
            if _debugging;
          return $cmd_cache{$cmd_name} if -x $cmd_cache{$cmd_name};
          _debug "'$cmd_cache{$cmd_name}' no longer executable, searching..."
            if _debugging;
          delete $cmd_cache{$cmd_name};
      }
  
      my @searched_in;
  
      ## This next bit is Unix/Win32 specific, unfortunately.
      ## There's been some conversation about extending File::Spec to provide
      ## a universal interface to PATH, but I haven't seen it yet.
      my $re = Win32_MODE ? qr/;/ : qr/:/;
  
    LOOP:
      for ( split( $re, $ENV{PATH} || '', -1 ) ) {
          $_ = "." unless length $_;
          push @searched_in, $_;
  
          my $prospect = File::Spec->catfile( $_, $cmd_name );
          my @prospects;
  
          @prospects =
            ( Win32_MODE && !( -f $prospect && -x _ ) )
            ? map "$prospect$_", split /;/, $ENV{PATHEXT} || ".COM;.BAT;.EXE"
            : ($prospect);
  
          for my $found (@prospects) {
              if ( -f $found && -x _ ) {
                  $cmd_cache{$cmd_name} = $found;
                  last LOOP;
              }
          }
      }
  
      if ( exists $cmd_cache{$cmd_name} ) {
          _debug "'", $cmd_name, "' added to cache: '", $cmd_cache{$cmd_name}, "'"
            if _debugging_details;
          return $cmd_cache{$cmd_name};
      }
  
      croak "Command '$cmd_name' not found in " . join( ", ", @searched_in );
  }
  
  # Translate a command or CODE reference (a $kid->{VAL}) to a list of strings
  # suitable for passing to _debug().
  sub _debugstrings {
      my $operand = shift;
      if ( !defined $operand ) {
          return '<undef>';
      }
  
      my $ref = ref $operand;
      if ( !$ref ) {
          return length $operand < 50
            ? "'$operand'"
            : join( '', "'", substr( $operand, 0, 10 ), "...'" );
      }
      elsif ( $ref eq 'ARRAY' ) {
          return (
              '[ ',
              join( " ", map /[^\w.-]/ ? "'$_'" : $_, @$operand ),
              ' ]'
          );
      }
      elsif ( UNIVERSAL::isa( $operand, 'IPC::Run::Win32Process' ) ) {
          return "$operand";
      }
      return $ref;
  }
  
  sub _empty($) { !( defined $_[0] && length $_[0] ) }
  
  ## 'safe' versions of otherwise fun things to do. See also IPC::Run::Win32Helper.
  sub _close {
      confess 'undef' unless defined $_[0];
      my $fd = $_[0] =~ /^\d+$/ ? $_[0] : fileno $_[0];
      if (Win32_MODE) {
  
          # Perl close() or POSIX::close() on the read end of a pipe hangs if
          # another process is in a read attempt on the same pipe
          # (https://github.com/Perl/perl5/issues/19963).  Since IPC::Run creates
          # pipes and shares them with user-defined kids, it's affected.  Work
          # around that by first using dup2() to replace the FD with a non-pipe.
          # Unfortunately, for socket FDs, dup2() closes the SOCKET with
          # CloseHandle().  CloseHandle() documentation leaves its behavior
          # undefined for sockets.  However, tests on Windows Server 2022 did not
          # leak memory, leak ports, or reveal any other obvious trouble.
          #
          # No failure here is fatal.  (_close() has worked that way, either due
          # to a principle or just due to a history of callers passing closed
          # FDs.)  croak() on EMFILE would be a bad user experience.  Better to
          # proceed and hope that $fd is not a being-read pipe.
          #
          # Since start() and other user-facing methods _close() many FDs, we
          # could optimize this by opening and closing the non-pipe FD just once
          # per method call.  The overhead of this simple approach was in the
          # noise, however.
          my $nul_fd = POSIX::open 'NUL';
          if ( !defined $nul_fd ) {
              _debug "open( NUL ) = ERROR $!" if _debugging_details;
          }
          else {
              my $r = POSIX::dup2( $nul_fd, $fd );
              _debug "dup2( $nul_fd, $fd ) = ERROR $!"
                if _debugging_details && !defined $r;
              $r = POSIX::close $nul_fd;
              _debug "close( $nul_fd (NUL) ) = ERROR $!"
                if _debugging_details && !defined $r;
          }
      }
      my $r = POSIX::close $fd;
      $r = $r ? '' : " ERROR $!";
      delete $fds{$fd};
      _debug "close( $fd ) = " . ( $r || 0 ) if _debugging_details;
  }
  
  sub _dup {
      confess 'undef' unless defined $_[0];
      my $r = POSIX::dup( $_[0] );
      croak "$!: dup( $_[0] )" unless defined $r;
      $r = 0 if $r eq '0 but true';
      _debug "dup( $_[0] ) = $r" if _debugging_details;
      $fds{$r} = {};
      return $r;
  }
  
  sub _dup2_rudely {
      confess 'undef' unless defined $_[0] && defined $_[1];
      my $r = POSIX::dup2( $_[0], $_[1] );
      croak "$!: dup2( $_[0], $_[1] )" unless defined $r;
      $r = 0 if $r eq '0 but true';
      _debug "dup2( $_[0], $_[1] ) = $r" if _debugging_details;
      $fds{$r} = {};
      return $r;
  }
  
  sub _exec {
      confess 'undef passed' if grep !defined, @_;
  
      #   exec @_ or croak "$!: exec( " . join( ', ', @_ ) . " )";
      _debug 'exec()ing ', join " ", map "'$_'", @_ if _debugging_details;
  
      #   {
  ## Commented out since we don't call this on Win32.
      #      # This works around the bug where 5.6.1 complains
      #      # "Can't exec ...: No error" after an exec on NT, where
      #      # exec() is simulated and actually returns in Perl's C
      #      # code, though Perl's &exec does not...
      #      no warnings "exec";
      #
      #      # Just in case the no warnings workaround
      #      # stops being a workaround, we don't want
      #      # old values of $! causing spurious strerr()
      #      # messages to appear in the "Can't exec" message
      #      undef $!;
      exec { $_[0] } @_;
  
      #   }
      #   croak "$!: exec( " . join( ', ', map "'$_'", @_ ) . " )";
      ## Fall through so $! can be reported to parent.
  }
  
  sub _sysopen {
      confess 'undef' unless defined $_[0] && defined $_[1];
      _debug sprintf( "O_RDONLY=0x%02x ", O_RDONLY ),
        sprintf( "O_WRONLY=0x%02x ", O_WRONLY ),
        sprintf( "O_RDWR=0x%02x ",   O_RDWR ),
        sprintf( "O_TRUNC=0x%02x ",  O_TRUNC ),
        sprintf( "O_CREAT=0x%02x ",  O_CREAT ),
        sprintf( "O_APPEND=0x%02x ", O_APPEND ),
        if _debugging_details;
      my $r = POSIX::open( $_[0], $_[1], 0666 );
      croak "$!: open( $_[0], ", sprintf( "0x%03x", $_[1] ), " )" unless defined $r;
      _debug "open( $_[0], ", sprintf( "0x%03x", $_[1] ), " ) = $r"
        if _debugging_data;
      $fds{$r} = {};
      return $r;
  }
  
  sub _pipe {
      ## Normal, blocking write for pipes that we read and the child writes,
      ## since most children expect writes to stdout to block rather than
      ## do a partial write.
      my ( $r, $w ) = POSIX::pipe;
      croak "$!: pipe()" unless defined $r;
      _debug "pipe() = ( $r, $w ) " if _debugging_details;
      @fds{$r, $w} = ( {}, {} );
      return ( $r, $w );
  }
  
  sub _pipe_nb {
      ## For pipes that we write, unblock the write side, so we can fill a buffer
      ## and continue to select().
      ## Contributed by Borislav Deianov <borislav@ensim.com>, with minor
      ## bugfix on fcntl result by me.
      local ( *R, *W );
      my $f = pipe( R, W );
      croak "$!: pipe()" unless defined $f;
      my ( $r, $w ) = ( fileno R, fileno W );
      _debug "pipe_nb pipe() = ( $r, $w )" if _debugging_details;
      unless (Win32_MODE) {
          ## POSIX::fcntl doesn't take fd numbers, so gotta use Perl's and
          ## then _dup the originals (which get closed on leaving this block)
          my $fres = fcntl( W, &F_SETFL, O_WRONLY | O_NONBLOCK );
          croak "$!: fcntl( $w, F_SETFL, O_NONBLOCK )" unless $fres;
          _debug "fcntl( $w, F_SETFL, O_NONBLOCK )" if _debugging_details;
      }
      ( $r, $w ) = ( _dup($r), _dup($w) );
      _debug "pipe_nb() = ( $r, $w )" if _debugging_details;
      return ( $r, $w );
  }
  
  sub _pty {
      require IO::Pty;
      my $pty = IO::Pty->new();
      croak "$!: pty ()" unless $pty;
      $pty->autoflush();
      $pty->blocking(0) or croak "$!: pty->blocking ( 0 )";
      _debug "pty() = ( ", $pty->fileno, ", ", $pty->slave->fileno, " )"
        if _debugging_details;
      @fds{ $pty->fileno, $pty->slave->fileno } = ( {}, {} );
      return $pty;
  }
  
  sub _read {
      confess 'undef' unless defined $_[0];
      my $s = '';
      my $r = POSIX::read( $_[0], $s, 10_000 );
      croak "$!: read( $_[0] )" if not($r) and !$!{EINTR};
      $r ||= 0;
      _debug "read( $_[0] ) = $r chars '$s'" if _debugging_data;
      return $s;
  }
  
  ## A METHOD, not a function.
  sub _spawn {
      my IPC::Run $self = shift;
      my ($kid) = @_;
  
      croak "Can't spawn IPC::Run::Win32Process except on Win32"
        if UNIVERSAL::isa( $kid->{VAL}, 'IPC::Run::Win32Process' );
  
      _debug "opening sync pipe ", $kid->{PID} if _debugging_details;
      my $sync_reader_fd;
      ( $sync_reader_fd, $self->{SYNC_WRITER_FD} ) = _pipe;
      $kid->{PID} = fork();
      croak "$! during fork" unless defined $kid->{PID};
  
      unless ( $kid->{PID} ) {
          ## _do_kid_and_exit closes sync_reader_fd since it closes all unwanted and
          ## unloved fds.
          $self->_do_kid_and_exit($kid);
      }
      _debug "fork() = ", $kid->{PID} if _debugging_details;
  
      ## Wait for kid to get to it's exec() and see if it fails.
      _close $self->{SYNC_WRITER_FD};
      my $sync_pulse = _read $sync_reader_fd;
      _close $sync_reader_fd;
  
      if ( !defined $sync_pulse || length $sync_pulse ) {
          if ( waitpid( $kid->{PID}, 0 ) >= 0 ) {
              $kid->{RESULT} = $?;
          }
          else {
              $kid->{RESULT} = -1;
          }
          $sync_pulse = "error reading synchronization pipe for $kid->{NUM}, pid $kid->{PID}"
            unless length $sync_pulse;
          croak $sync_pulse;
      }
      return $kid->{PID};
  
  ## Wait for pty to get set up.  This is a hack until we get synchronous
  ## selects.
      if ( keys %{ $self->{PTYS} } && $IO::Pty::VERSION < 0.9 ) {
          _debug "sleeping to give pty a chance to init, will fix when newer IO::Pty arrives.";
          sleep 1;
      }
  }
  
  sub _write {
      confess 'undef' unless defined $_[0] && defined $_[1];
      my $r = POSIX::write( $_[0], $_[1], length $_[1] );
      croak "$!: write( $_[0], '$_[1]' )" unless $r;
      _debug "write( $_[0], '$_[1]' ) = $r" if _debugging_data;
      return $r;
  }
  
  =pod
  
  =over
  
  =item run
  
  Run takes a harness or harness specification and runs it, pumping
  all input to the child(ren), closing the input pipes when no more
  input is available, collecting all output that arrives, until the
  pipes delivering output are closed, then waiting for the children to
  exit and reaping their result codes.
  
  You may think of C<run( ... )> as being like 
  
     start( ... )->finish();
  
  , though there is one subtle difference: run() does not
  set \$input_scalars to '' like finish() does.  If an exception is thrown
  from run(), all children will be killed off "gently", and then "annihilated"
  if they do not go gently (in to that dark night. sorry).
  
  If any exceptions are thrown, this does a L</kill_kill> before propagating
  them.
  
  =cut
  
  use vars qw( $in_run );    ## No, not Enron;)
  
  sub run {
      local $in_run = 1;     ## Allow run()-only optimizations.
      my IPC::Run $self = start(@_);
      my $r = eval {
          $self->{clear_ins} = 0;
          $self->finish;
      };
      if ($@) {
          my $x = $@;
          $self->kill_kill;
          die $x;
      }
      return $r;
  }
  
  =pod
  
  =item signal
  
     ## To send it a specific signal by name ("USR1"):
     signal $h, "USR1";
     $h->signal ( "USR1" );
  
  If $signal is provided and defined, sends a signal to all child processes.  Try
  not to send numeric signals, use C<"KILL"> instead of C<9>, for instance.
  Numeric signals aren't portable.
  
  Throws an exception if $signal is undef.
  
  This will I<not> clean up the harness, C<finish> it if you kill it.
  
  Normally TERM kills a process gracefully (this is what the command line utility
  C<kill> does by default), INT is sent by one of the keys C<^C>, C<Backspace> or
  C<E<lt>DelE<gt>>, and C<QUIT> is used to kill a process and make it coredump.
  
  The C<HUP> signal is often used to get a process to "restart", rereading 
  config files, and C<USR1> and C<USR2> for really application-specific things.
  
  Often, running C<kill -l> (that's a lower case "L") on the command line will
  list the signals present on your operating system.
  
  B<WARNING>: The signal subsystem is not at all portable.  We *may* offer
  to simulate C<TERM> and C<KILL> on some operating systems, submit code
  to me if you want this.
  
  B<WARNING 2>: Up to and including perl v5.6.1, doing almost anything in a
  signal handler could be dangerous.  The most safe code avoids all
  mallocs and system calls, usually by preallocating a flag before
  entering the signal handler, altering the flag's value in the
  handler, and responding to the changed value in the main system:
  
     my $got_usr1 = 0;
     sub usr1_handler { ++$got_signal }
  
     $SIG{USR1} = \&usr1_handler;
     while () { sleep 1; print "GOT IT" while $got_usr1--; }
  
  Even this approach is perilous if ++ and -- aren't atomic on your system
  (I've never heard of this on any modern CPU large enough to run perl).
  
  =cut
  
  sub signal {
      my IPC::Run $self = shift;
  
      local $cur_self = $self;
  
      $self->_kill_kill_kill_pussycat_kill unless @_;
  
      Carp::cluck "Ignoring extra parameters passed to kill()" if @_ > 1;
  
      my ($signal) = @_;
      croak "Undefined signal passed to signal" unless defined $signal;
      for ( grep $_->{PID} && !defined $_->{RESULT}, @{ $self->{KIDS} } ) {
          _debug "sending $signal to $_->{PID}"
            if _debugging;
          kill $signal, $_->{PID}
            or _debugging && _debug "$! sending $signal to $_->{PID}";
      }
  
      return;
  }
  
  =pod
  
  =item kill_kill
  
     ## To kill off a process:
     $h->kill_kill;
     kill_kill $h;
  
     ## To specify the grace period other than 30 seconds:
     kill_kill $h, grace => 5;
  
     ## To send QUIT instead of KILL if a process refuses to die:
     kill_kill $h, coup_d_grace => "QUIT";
  
  Sends a C<TERM>, waits for all children to exit for up to 30 seconds, then
  sends a C<KILL> to any that survived the C<TERM>.
  
  Will wait for up to 30 more seconds for the OS to successfully C<KILL> the
  processes.
  
  The 30 seconds may be overridden by setting the C<grace> option, this
  overrides both timers.
  
  The harness is then cleaned up.
  
  The doubled name indicates that this function may kill again and avoids
  colliding with the core Perl C<kill> function.
  
  Returns a 1 if the C<TERM> was sufficient, or a 0 if C<KILL> was 
  required.  Throws an exception if C<KILL> did not permit the children
  to be reaped.
  
  B<NOTE>: The grace period is actually up to 1 second longer than that
  given.  This is because the granularity of C<time> is 1 second.  Let me
  know if you need finer granularity, we can leverage Time::HiRes here.
  
  B<Win32>: Win32 does not know how to send real signals, so C<TERM> is
  a full-force kill on Win32.  Thus all talk of grace periods, etc. do
  not apply to Win32.
  
  =cut
  
  sub kill_kill {
      my IPC::Run $self = shift;
  
      my %options = @_;
      my $grace   = $options{grace};
      $grace = 30 unless defined $grace;
      ++$grace;    ## Make grace time a _minimum_
  
      my $coup_d_grace = $options{coup_d_grace};
      $coup_d_grace = "KILL" unless defined $coup_d_grace;
  
      delete $options{$_} for qw( grace coup_d_grace );
      Carp::cluck "Ignoring unknown options for kill_kill: ",
        join " ", keys %options
        if keys %options;
  
      if (Win32_MODE) {
  	# immediate brutal death for Win32
  	# TERM has unfortunate side-effects
  	$self->signal("KILL")
      }
      else {
  	$self->signal("TERM");
      }
  
      my $quitting_time = time + $grace;
      my $delay         = 0.01;
      my $accum_delay;
  
      my $have_killed_before;
  
      while () {
          ## delay first to yield to other processes
          select undef, undef, undef, $delay;
          $accum_delay += $delay;
  
          $self->reap_nb;
          last unless $self->_running_kids;
  
          if ( $accum_delay >= $grace * 0.8 ) {
              ## No point in checking until delay has grown some.
              if ( time >= $quitting_time ) {
                  if ( !$have_killed_before ) {
                      $self->signal($coup_d_grace);
                      $have_killed_before = 1;
                      $quitting_time += $grace;
                      $delay       = 0.01;
                      $accum_delay = 0;
                      next;
                  }
                  croak "Unable to reap all children, even after KILLing them";
              }
          }
  
          $delay *= 2;
          $delay = 0.5 if $delay >= 0.5;
      }
  
      $self->_cleanup;
      return $have_killed_before;
  }
  
  =pod
  
  =item harness
  
  Takes a harness specification and returns a harness.  This harness is
  blessed in to IPC::Run, allowing you to use method call syntax for
  run(), start(), et al if you like.
  
  harness() is provided so that you can pre-build harnesses if you
  would like to, but it's not required..
  
  You may proceed to run(), start() or pump() after calling harness() (pump()
  calls start() if need be).  Alternatively, you may pass your
  harness specification to run() or start() and let them harness() for
  you.  You can't pass harness specifications to pump(), though.
  
  =cut
  
  ##
  ## Notes: I've avoided handling a scalar that doesn't look like an
  ## opcode as a here document or as a filename, though I could DWIM
  ## those.  I'm not sure that the advantages outweigh the danger when
  ## the DWIMer guesses wrong.
  ##
  ## TODO: allow user to spec default shell. Hmm, globally, in the
  ## lexical scope hash, or per instance?  'Course they can do that
  ## now by using a [...] to hold the command.
  ##
  my $harness_id = 0;
  
  sub harness {
      my $options;
      if ( @_ && ref $_[-1] eq 'HASH' ) {
          $options = pop;
          require Data::Dumper;
          carp "Passing in options as a hash is deprecated:\n", Data::Dumper::Dumper($options);
      }
  
      #   local $IPC::Run::debug = $options->{debug}
      #      if $options && defined $options->{debug};
  
      my @args;
      if ( @_ == 1 && !ref $_[0] ) {
          if (Win32_MODE) {
              my $command = $ENV{ComSpec} || 'cmd';
              @args = ( [ $command, '/c', win32_parse_cmd_line $_[0] ] );
          }
          else {
              @args = ( [ qw( sh -c ), @_ ] );
          }
      }
      elsif ( @_ > 1 && !grep ref $_, @_ ) {
          @args = ( [@_] );
      }
      else {
          @args = map { !defined $_ ? bless(\$_, 'IPC::Run::Undef') : $_ } @_;
      }
  
      my @errs;    # Accum errors, emit them when done.
  
      my $succinct;    # set if no redir ops are required yet.  Cleared
                       # if an op is seen.
  
      my $cur_kid;     # references kid or handle being parsed
      my $next_kid_close_stdin = 0;
  
      my $assumed_fd = 0;    # fd to assume in succinct mode (no redir ops)
      my $handle_num = 0;    # 1... is which handle we're parsing
  
      my IPC::Run $self = bless {}, __PACKAGE__;
  
      local $cur_self = $self;
  
      $self->{ID}    = ++$harness_id;
      $self->{IOS}   = [];
      $self->{KIDS}  = [];
      $self->{PIPES} = [];
      $self->{PTYS}  = {};
      $self->{STATE} = _newed;
  
      if ($options) {
          $self->{$_} = $options->{$_} for keys %$options;
      }
  
      _debug "****** harnessing *****" if _debugging;
  
      my $first_parse;
      local $_;
      my $arg_count = @args;
      while (@args) {
          for ( shift @args ) {
              eval {
                  $first_parse = 1;
                  _debug( "parsing ", _debugstrings($_) ) if _debugging;
  
                REPARSE:
                  if (   ref eq 'ARRAY'
                      || UNIVERSAL::isa( $_, 'IPC::Run::Win32Process' )
                      || ( !$cur_kid && ref eq 'CODE' ) ) {
                      croak "Process control symbol ('|', '&') missing" if $cur_kid;
                      croak "Can't spawn a subroutine on Win32"
                        if Win32_MODE && ref eq "CODE";
                      $cur_kid = {
                          TYPE   => 'cmd',
                          VAL    => $_,
                          NUM    => @{ $self->{KIDS} } + 1,
                          OPS    => [],
                          PID    => '',
                          RESULT => undef,
                      };
  
                      unshift @{ $cur_kid->{OPS} }, {
                          TYPE => 'close',
                          KFD  => 0,
                      } if $next_kid_close_stdin;
                      $next_kid_close_stdin = 0;
  
                      push @{ $self->{KIDS} }, $cur_kid;
                      $succinct = 1;
                  }
  
                  elsif ( UNIVERSAL::isa( $_, 'IPC::Run::IO' ) ) {
                      push @{ $self->{IOS} }, $_;
                      $cur_kid  = undef;
                      $succinct = 1;
                  }
  
                  elsif ( UNIVERSAL::isa( $_, 'IPC::Run::Timer' ) ) {
                      push @{ $self->{TIMERS} }, $_;
                      $cur_kid  = undef;
                      $succinct = 1;
                  }
  
                  elsif (/^(\d*)>&(\d+)$/) {
                      croak "No command before '$_'" unless $cur_kid;
                      push @{ $cur_kid->{OPS} }, {
                          TYPE => 'dup',
                          KFD1 => $2,
                          KFD2 => length $1 ? $1 : 1,
                      };
                      _debug "redirect operators now required" if _debugging_details;
                      $succinct = !$first_parse;
                  }
  
                  elsif (/^(\d*)<&(\d+)$/) {
                      croak "No command before '$_'" unless $cur_kid;
                      push @{ $cur_kid->{OPS} }, {
                          TYPE => 'dup',
                          KFD1 => $2,
                          KFD2 => length $1 ? $1 : 0,
                      };
                      $succinct = !$first_parse;
                  }
  
                  elsif (/^(\d*)<&-$/) {
                      croak "No command before '$_'" unless $cur_kid;
                      push @{ $cur_kid->{OPS} }, {
                          TYPE => 'close',
                          KFD  => length $1 ? $1 : 0,
                      };
                      $succinct = !$first_parse;
                  }
  
                  elsif (/^(\d*) (<pipe)()            ()  ()  $/x
                      || /^(\d*) (<pty) ((?:\s+\S+)?) (<) ()  $/x
                      || /^(\d*) (<)    ()            ()  (.*)$/x ) {
                      croak "No command before '$_'" unless $cur_kid;
  
                      $succinct = !$first_parse;
  
                      my $type = $2 . $4;
  
                      my $kfd = length $1 ? $1 : 0;
  
                      my $pty_id;
                      if ( $type eq '<pty<' ) {
                          $pty_id = length $3 ? $3 : '0';
                          ## do the require here to cause early error reporting
                          require IO::Pty;
                          ## Just flag the pyt's existence for now.  It'll be
                          ## converted to a real IO::Pty by _open_pipes.
                          $self->{PTYS}->{$pty_id} = undef;
                      }
  
                      my $source = $5;
  
                      my @filters;
                      my $binmode;
  
                      unless ( length $source ) {
                          if ( !$succinct ) {
                              while ( @args > 1
                                  && ( ( ref $args[1] && !UNIVERSAL::isa $args[1], "IPC::Run::Timer" ) || UNIVERSAL::isa $args[0], "IPC::Run::binmode_pseudo_filter" ) ) {
                                  if ( UNIVERSAL::isa $args[0], "IPC::Run::binmode_pseudo_filter" ) {
                                      $binmode = shift(@args)->();
                                  }
                                  else {
                                      push @filters, shift @args;
                                  }
                              }
                          }
                          $source = shift @args;
                          croak "'$_' missing a source" if _empty $source;
  
                          _debug(
                              'Kid ',  $cur_kid->{NUM},  "'s input fd ", $kfd,
                              ' has ', scalar(@filters), ' filters.'
                          ) if _debugging_details && @filters;
                      }
  
                      my IPC::Run::IO $pipe = IPC::Run::IO->_new_internal( $type, $kfd, $pty_id, $source, $binmode, @filters );
  
                      if ( ( ref $source eq 'GLOB' || UNIVERSAL::isa $source, 'IO::Handle' )
                          && $type !~ /^<p(ty<|ipe)$/ ) {
                          _debug "setting DONT_CLOSE" if _debugging_details;
                          $pipe->{DONT_CLOSE} = 1;    ## this FD is not closed by us.
                          _dont_inherit($source) if Win32_MODE;
                      }
  
                      push @{ $cur_kid->{OPS} }, $pipe;
                  }
  
                  elsif (
                         /^()   (>>?)  (&)     ()      (.*)$/x
                      || /^()   (&)    (>pipe) ()      ()  $/x
                      || /^()   (>pipe)(&)     ()      ()  $/x
                      || /^(\d*)()     (>pipe) ()      ()  $/x
                      || /^()   (&)    (>pty)  ( \w*)> ()  $/x
  ## TODO:    ||   /^()   (>pty) (\d*)> (&) ()  $/x
                      || /^(\d*)()     (>pty)  ( \w*)> ()  $/x
                      || /^()   (&)    (>>?)   ()      (.*)$/x || /^(\d*)()     (>>?)   ()      (.*)$/x
                    ) {
                      croak "No command before '$_'" unless $cur_kid;
  
                      $succinct = !$first_parse;
  
                      my $type = (
                            $2 eq '>pipe' || $3 eq '>pipe' ? '>pipe'
                          : $2 eq '>pty'  || $3 eq '>pty'  ? '>pty>'
                          :                                  '>'
                      );
                      my $kfd = length $1 ? $1 : 1;
                      my $trunc = !( $2 eq '>>' || $3 eq '>>' );
                      my $pty_id = (
                            $2 eq '>pty' || $3 eq '>pty'
                          ? length $4
                                ? $4
                                : 0
                          : undef
                      );
  
                      my $stderr_too =
                           $2 eq '&'
                        || $3 eq '&'
                        || ( !length $1 && substr( $type, 0, 4 ) eq '>pty' );
  
                      my $dest = $5;
                      my @filters;
                      my $binmode = 0;
                      unless ( length $dest ) {
                          if ( !$succinct ) {
                              ## unshift...shift: '>' filters source...sink left...right
                              while ( @args > 1
                                  && ( ( ref $args[1] && !UNIVERSAL::isa $args[1], "IPC::Run::Timer" ) || UNIVERSAL::isa $args[0], "IPC::Run::binmode_pseudo_filter" ) ) {
                                  if ( UNIVERSAL::isa $args[0], "IPC::Run::binmode_pseudo_filter" ) {
                                      $binmode = shift(@args)->();
                                  }
                                  else {
                                      unshift @filters, shift @args;
                                  }
                              }
                          }
  
  			if ( @args && ref $args[0] eq 'IPC::Run::Undef' ) {
  			    require Symbol;
  			    ${ $args[0] } = $dest = Symbol::gensym();
  			    shift @args;
  			}
  			else {
  			    $dest = shift @args;
  			}
  
                          _debug(
                              'Kid ',  $cur_kid->{NUM},  "'s output fd ", $kfd,
                              ' has ', scalar(@filters), ' filters.'
                          ) if _debugging_details && @filters;
  
                          if ( $type eq '>pty>' ) {
                              ## do the require here to cause early error reporting
                              require IO::Pty;
                              ## Just flag the pyt's existence for now.  _open_pipes()
                              ## will new an IO::Pty for each key.
                              $self->{PTYS}->{$pty_id} = undef;
                          }
                      }
  
                      croak "'$_' missing a destination" if _empty $dest;
                      my $pipe = IPC::Run::IO->_new_internal( $type, $kfd, $pty_id, $dest, $binmode, @filters );
                      $pipe->{TRUNC} = $trunc;
  
                      if ( ( UNIVERSAL::isa( $dest, 'GLOB' ) || UNIVERSAL::isa( $dest, 'IO::Handle' ) )
                          && $type !~ /^>(pty>|pipe)$/ ) {
                          _debug "setting DONT_CLOSE" if _debugging_details;
                          $pipe->{DONT_CLOSE} = 1;    ## this FD is not closed by us.
                      }
                      push @{ $cur_kid->{OPS} }, $pipe;
                      push @{ $cur_kid->{OPS} }, {
                          TYPE => 'dup',
                          KFD1 => 1,
                          KFD2 => 2,
                      } if $stderr_too;
                  }
  
                  elsif ( $_ eq "|" ) {
                      croak "No command before '$_'" unless $cur_kid;
                      unshift @{ $cur_kid->{OPS} }, {
                          TYPE => '|',
                          KFD  => 1,
                      };
                      $succinct   = 1;
                      $assumed_fd = 1;
                      $cur_kid    = undef;
                  }
  
                  elsif ( $_ eq "&" ) {
                      croak "No command before '$_'" unless $cur_kid;
                      $next_kid_close_stdin = 1;
                      $succinct             = 1;
                      $assumed_fd           = 0;
                      $cur_kid              = undef;
                  }
  
                  elsif ( $_ eq 'init' ) {
                      croak "No command before '$_'" unless $cur_kid;
                      push @{ $cur_kid->{OPS} }, {
                          TYPE => 'init',
                          SUB  => shift @args,
                      };
                  }
  
                  elsif ( !ref $_ ) {
                      $self->{$_} = shift @args;
                  }
  
                  elsif ( $_ eq 'init' ) {
                      croak "No command before '$_'" unless $cur_kid;
                      push @{ $cur_kid->{OPS} }, {
                          TYPE => 'init',
                          SUB  => shift @args,
                      };
                  }
  
                  elsif ( $succinct && $first_parse ) {
                      ## It's not an opcode, and no explicit opcodes have been
                      ## seen yet, so assume it's a file name.
                      unshift @args, $_;
                      if ( !$assumed_fd ) {
                          $_ = "$assumed_fd<",
                      }
                      else {
                          $_ = "$assumed_fd>",
                      }
                      _debug "assuming '", $_, "'" if _debugging_details;
                      ++$assumed_fd;
                      $first_parse = 0;
                      goto REPARSE;
                  }
  
                  else {
                      croak join(
                          '',
                          'Unexpected ',
                          ( ref() ? $_ : 'scalar' ),
                          ' in harness() parameter ',
                          $arg_count - @args
                      );
                  }
              };
              if ($@) {
                  push @errs, $@;
                  _debug 'caught ', $@ if _debugging;
              }
          }
      }
  
      die join( '', @errs ) if @errs;
  
      $self->{STATE} = _harnessed;
  
      #   $self->timeout( $options->{timeout} ) if exists $options->{timeout};
      return $self;
  }
  
  sub _open_pipes {
      my IPC::Run $self = shift;
  
      my @errs;
  
      my @close_on_fail;
  
      ## When a pipe character is seen, a pipe is created.  $pipe_read_fd holds
      ## the dangling read end of the pipe until we get to the next process.
      my $pipe_read_fd;
  
      ## Output descriptors for the last command are shared by all children.
      ## @output_fds_accum accumulates the current set of output fds.
      my @output_fds_accum;
  
      for ( sort keys %{ $self->{PTYS} } ) {
          _debug "opening pty '", $_, "'" if _debugging_details;
          my $pty = _pty;
          $self->{PTYS}->{$_} = $pty;
      }
  
      for ( @{ $self->{IOS} } ) {
          eval { $_->init; };
          if ($@) {
              push @errs, $@;
              _debug 'caught ', $@ if _debugging;
          }
          else {
              push @close_on_fail, $_;
          }
      }
  
      ## Loop through the kids and their OPS, interpreting any that require
      ## parent-side actions.
      for my $kid ( @{ $self->{KIDS} } ) {
          if ( ref $kid->{VAL} eq 'ARRAY' ) {
              $kid->{PATH} = _search_path $kid->{VAL}->[0];
          }
          if ( defined $pipe_read_fd ) {
              _debug "placing write end of pipe on kid $kid->{NUM}'s stdin"
                if _debugging_details;
              unshift @{ $kid->{OPS} }, {
                  TYPE => 'PIPE',          ## Prevent next loop from triggering on this
                  KFD  => 0,
                  TFD  => $pipe_read_fd,
              };
              $pipe_read_fd = undef;
          }
          @output_fds_accum = ();
          for my $op ( @{ $kid->{OPS} } ) {
  
              #         next if $op->{IS_DEBUG};
              my $ok = eval {
                  if ( $op->{TYPE} eq '<' ) {
                      my $source = $op->{SOURCE};
                      if ( !ref $source ) {
                          _debug(
                              "kid ",              $kid->{NUM}, " to read ", $op->{KFD},
                              " from '" . $source, "' (read only)"
                          ) if _debugging_details;
                          croak "simulated open failure"
                            if $self->{_simulate_open_failure};
                          $op->{TFD} = _sysopen( $source, O_RDONLY );
                          push @close_on_fail, $op->{TFD};
                      }
                      elsif (UNIVERSAL::isa( $source, 'GLOB' )
                          || UNIVERSAL::isa( $source, 'IO::Handle' ) ) {
                          croak "Unopened filehandle in input redirect for $op->{KFD}"
                            unless defined fileno $source;
                          $op->{TFD} = fileno $source;
                          _debug(
                              "kid ",      $kid->{NUM}, " to read ", $op->{KFD},
                              " from fd ", $op->{TFD}
                          ) if _debugging_details;
                      }
                      elsif ( UNIVERSAL::isa( $source, 'SCALAR' ) ) {
                          _debug(
                              "kid ", $kid->{NUM}, " to read ", $op->{KFD},
                              " from SCALAR"
                          ) if _debugging_details;
  
                          $op->open_pipe( $self->_debug_fd );
                          push @close_on_fail, $op->{KFD}, $op->{FD};
  
                          my $s = '';
                          $op->{KIN_REF} = \$s;
                      }
                      elsif ( UNIVERSAL::isa( $source, 'CODE' ) ) {
                          _debug( 'kid ', $kid->{NUM}, ' to read ', $op->{KFD}, ' from CODE' ) if _debugging_details;
  
                          $op->open_pipe( $self->_debug_fd );
                          push @close_on_fail, $op->{KFD}, $op->{FD};
  
                          my $s = '';
                          $op->{KIN_REF} = \$s;
                      }
                      else {
                          croak( "'" . ref($source) . "' not allowed as a source for input redirection" );
                      }
                      $op->_init_filters;
                  }
                  elsif ( $op->{TYPE} eq '<pipe' ) {
                      _debug(
                          'kid to read ', $op->{KFD},
                          ' from a pipe IPC::Run opens and returns',
                      ) if _debugging_details;
  
                      my ( $r, $w ) = $op->open_pipe( $self->_debug_fd, $op->{SOURCE} );
                      _debug "caller will write to ", fileno $op->{SOURCE}
                        if _debugging_details;
  
                      $op->{TFD} = $r;
                      $op->{FD}  = undef;    # we don't manage this fd
                      $op->_init_filters;
                  }
                  elsif ( $op->{TYPE} eq '<pty<' ) {
                      _debug(
                          'kid to read ', $op->{KFD}, " from pty '", $op->{PTY_ID}, "'",
                      ) if _debugging_details;
  
                      for my $source ( $op->{SOURCE} ) {
                          if ( UNIVERSAL::isa( $source, 'SCALAR' ) ) {
                              _debug(
                                  "kid ",                   $kid->{NUM},   " to read ", $op->{KFD},
                                  " from SCALAR via pty '", $op->{PTY_ID}, "'"
                              ) if _debugging_details;
  
                              my $s = '';
                              $op->{KIN_REF} = \$s;
                          }
                          elsif ( UNIVERSAL::isa( $source, 'CODE' ) ) {
                              _debug(
                                  "kid ",                 $kid->{NUM},   " to read ", $op->{KFD},
                                  " from CODE via pty '", $op->{PTY_ID}, "'"
                              ) if _debugging_details;
                              my $s = '';
                              $op->{KIN_REF} = \$s;
                          }
                          else {
                              croak( "'" . ref($source) . "' not allowed as a source for '<pty<' redirection" );
                          }
                      }
                      $op->{FD}  = $self->{PTYS}->{ $op->{PTY_ID} }->fileno;
                      $op->{TFD} = undef;                                      # The fd isn't known until after fork().
                      $op->_init_filters;
                  }
                  elsif ( $op->{TYPE} eq '>' ) {
                      ## N> output redirection.
                      my $dest = $op->{DEST};
                      if ( !ref $dest ) {
                          _debug(
                              "kid ",  $kid->{NUM}, " to write ", $op->{KFD},
                              " to '", $dest,       "' (write only, create, ",
                              ( $op->{TRUNC} ? 'truncate' : 'append' ),
                              ")"
                          ) if _debugging_details;
                          croak "simulated open failure"
                            if $self->{_simulate_open_failure};
                          $op->{TFD} = _sysopen(
                              $dest,
                              ( O_WRONLY | O_CREAT | ( $op->{TRUNC} ? O_TRUNC : O_APPEND ) )
                          );
                          if (Win32_MODE) {
                              ## I have no idea why this is needed to make the current
                              ## file position survive the gyrations TFD must go
                              ## through...
                              POSIX::lseek( $op->{TFD}, 0, POSIX::SEEK_END() );
                          }
                          push @close_on_fail, $op->{TFD};
                      }
                      elsif ( UNIVERSAL::isa( $dest, 'GLOB' ) ) {
                          croak("Unopened filehandle in output redirect, command $kid->{NUM}") unless defined fileno $dest;
                          ## Turn on autoflush, mostly just to flush out
                          ## existing output.
                          my $old_fh = select($dest);
                          $| = 1;
                          select($old_fh);
                          $op->{TFD} = fileno $dest;
                          _debug( 'kid to write ', $op->{KFD}, ' to handle ', $op->{TFD} ) if _debugging_details;
                      }
                      elsif ( UNIVERSAL::isa( $dest, 'SCALAR' ) ) {
                          _debug( "kid ", $kid->{NUM}, " to write $op->{KFD} to SCALAR" ) if _debugging_details;
  
                          $op->open_pipe( $self->_debug_fd );
                          push @close_on_fail, $op->{FD}, $op->{TFD};
                          $$dest = '' if $op->{TRUNC};
                      }
                      elsif ( UNIVERSAL::isa( $dest, 'CODE' ) ) {
                          _debug("kid $kid->{NUM} to write $op->{KFD} to CODE") if _debugging_details;
  
                          $op->open_pipe( $self->_debug_fd );
                          push @close_on_fail, $op->{FD}, $op->{TFD};
                      }
                      else {
                          croak( "'" . ref($dest) . "' not allowed as a sink for output redirection" );
                      }
                      $output_fds_accum[ $op->{KFD} ] = $op;
                      $op->_init_filters;
                  }
  
                  elsif ( $op->{TYPE} eq '>pipe' ) {
                      ## N> output redirection to a pipe we open, but don't select()
                      ## on.
                      _debug(
                          "kid ", $kid->{NUM}, " to write ", $op->{KFD},
                          ' to a pipe IPC::Run opens and returns'
                      ) if _debugging_details;
  
                      my ( $r, $w ) = $op->open_pipe( $self->_debug_fd, $op->{DEST} );
                      _debug "caller will read from ", fileno $op->{DEST}
                        if _debugging_details;
  
                      $op->{TFD} = $w;
                      $op->{FD}  = undef;    # we don't manage this fd
                      $op->_init_filters;
  
                      $output_fds_accum[ $op->{KFD} ] = $op;
                  }
                  elsif ( $op->{TYPE} eq '>pty>' ) {
                      my $dest = $op->{DEST};
                      if ( UNIVERSAL::isa( $dest, 'SCALAR' ) ) {
                          _debug(
                              "kid ",                 $kid->{NUM},   " to write ", $op->{KFD},
                              " to SCALAR via pty '", $op->{PTY_ID}, "'"
                          ) if _debugging_details;
  
                          $$dest = '' if $op->{TRUNC};
                      }
                      elsif ( UNIVERSAL::isa( $dest, 'CODE' ) ) {
                          _debug(
                              "kid ",               $kid->{NUM},   " to write ", $op->{KFD},
                              " to CODE via pty '", $op->{PTY_ID}, "'"
                          ) if _debugging_details;
                      }
                      else {
                          croak( "'" . ref($dest) . "' not allowed as a sink for output redirection" );
                      }
  
                      $op->{FD}                       = $self->{PTYS}->{ $op->{PTY_ID} }->fileno;
                      $op->{TFD}                      = undef;                                      # The fd isn't known until after fork().
                      $output_fds_accum[ $op->{KFD} ] = $op;
                      $op->_init_filters;
                  }
                  elsif ( $op->{TYPE} eq '|' ) {
                      _debug( "pipelining $kid->{NUM} and " . ( $kid->{NUM} + 1 ) ) if _debugging_details;
                      ( $pipe_read_fd, $op->{TFD} ) = _pipe;
                      if (Win32_MODE) {
                          _dont_inherit($pipe_read_fd);
                          _dont_inherit( $op->{TFD} );
                      }
                      @output_fds_accum = ();
                  }
                  elsif ( $op->{TYPE} eq '&' ) {
                      @output_fds_accum = ();
                  }    # end if $op->{TYPE} tree
                  1;
              };    # end eval
              unless ($ok) {
                  push @errs, $@;
                  _debug 'caught ', $@ if _debugging;
              }
          }    # end for ( OPS }
      }
  
      if (@errs) {
          for (@close_on_fail) {
              _close($_);
              $_ = undef;
          }
          for ( keys %{ $self->{PTYS} } ) {
              next unless $self->{PTYS}->{$_};
              close $self->{PTYS}->{$_};
              $self->{PTYS}->{$_} = undef;
          }
          die join( '', @errs );
      }
  
      ## give all but the last child all of the output file descriptors
      ## These will be reopened (and thus rendered useless) if the child
      ## dup2s on to these descriptors, since we unshift these.  This way
      ## each process emits output to the same file descriptors that the
      ## last child will write to.  This is probably not quite correct,
      ## since each child should write to the file descriptors inherited
      ## from the parent.
      ## TODO: fix the inheritance of output file descriptors.
      ## NOTE: This sharing of OPS among kids means that we can't easily put
      ## a kid number in each OPS structure to ping the kid when all ops
      ## have closed (when $self->{PIPES} has emptied).  This means that we
      ## need to scan the KIDS whenever @{$self->{PIPES}} is empty to see
      ## if there any of them are still alive.
      for ( my $num = 0; $num < $#{ $self->{KIDS} }; ++$num ) {
          for ( reverse @output_fds_accum ) {
              next unless defined $_;
              _debug(
                  'kid ', $self->{KIDS}->[$num]->{NUM}, ' also to write ', $_->{KFD},
                  ' to ', ref $_->{DEST}
              ) if _debugging_details;
              unshift @{ $self->{KIDS}->[$num]->{OPS} }, $_;
          }
      }
  
      ## Open the debug pipe if we need it
      ## Create the list of PIPES we need to scan and the bit vectors needed by
      ## select().  Do this first so that _cleanup can _clobber() them if an
      ## exception occurs.
      @{ $self->{PIPES} } = ();
      $self->{RIN} = '';
      $self->{WIN} = '';
      $self->{EIN} = '';
      ## PIN is a vec()tor that indicates who's paused.
      $self->{PIN} = '';
      for my $kid ( @{ $self->{KIDS} } ) {
          for ( @{ $kid->{OPS} } ) {
              if ( defined $_->{FD} ) {
                  _debug(
                      'kid ',    $kid->{NUM}, '[', $kid->{PID}, "]'s ", $_->{KFD},
                      ' is my ', $_->{FD}
                  ) if _debugging_details;
                  vec( $self->{ $_->{TYPE} =~ /^</ ? 'WIN' : 'RIN' }, $_->{FD}, 1 ) = 1;
  
                  #	    vec( $self->{EIN}, $_->{FD}, 1 ) = 1;
                  push @{ $self->{PIPES} }, $_;
              }
          }
      }
  
      for my $io ( @{ $self->{IOS} } ) {
          my $fd = $io->fileno;
          vec( $self->{RIN}, $fd, 1 ) = 1 if $io->mode =~ /r/;
          vec( $self->{WIN}, $fd, 1 ) = 1 if $io->mode =~ /w/;
  
          #      vec( $self->{EIN}, $fd, 1 ) = 1;
          push @{ $self->{PIPES} }, $io;
      }
  
      ## Put filters on the end of the filter chains to read & write the pipes.
      ## Clear pipe states
      for my $pipe ( @{ $self->{PIPES} } ) {
          $pipe->{SOURCE_EMPTY} = 0;
          $pipe->{PAUSED}       = 0;
          if ( $pipe->{TYPE} =~ /^>/ ) {
              my $pipe_reader = sub {
                  my ( undef, $out_ref ) = @_;
  
                  return undef unless defined $pipe->{FD};
                  return 0 unless vec( $self->{ROUT}, $pipe->{FD}, 1 );
  
                  vec( $self->{ROUT}, $pipe->{FD}, 1 ) = 0;
  
                  _debug_desc_fd( 'reading from', $pipe ) if _debugging_details;
                  my $in = eval { _read( $pipe->{FD} ) };
                  if ($@) {
                      $in = '';
                      ## IO::Pty throws the Input/output error if the kid dies.
                      ## read() throws the bad file descriptor message if the
                      ## kid dies on Win32.
                      die $@
                        unless $@ =~ $_EIO
                        || ( $@ =~ /input or output/ && $^O =~ /aix/ )
                        || ( Win32_MODE && $@ =~ /Bad file descriptor/ );
                  }
  
                  unless ( length $in ) {
                      $self->_clobber($pipe);
                      return undef;
                  }
  
                  ## Protect the position so /.../g matches may be used.
                  my $pos = pos $$out_ref;
                  $$out_ref .= $in;
                  pos($$out_ref) = $pos;
                  return 1;
              };
              ## Input filters are the last filters
              push @{ $pipe->{FILTERS} },      $pipe_reader;
              push @{ $self->{TEMP_FILTERS} }, $pipe_reader;
          }
          else {
              my $pipe_writer = sub {
                  my ( $in_ref, $out_ref ) = @_;
                  return undef unless defined $pipe->{FD};
                  return 0
                    unless vec( $self->{WOUT}, $pipe->{FD}, 1 )
                    || $pipe->{PAUSED};
  
                  vec( $self->{WOUT}, $pipe->{FD}, 1 ) = 0;
  
                  if ( !length $$in_ref ) {
                      if ( !defined get_more_input ) {
                          $self->_clobber($pipe);
                          return undef;
                      }
                  }
  
                  unless ( length $$in_ref ) {
                      unless ( $pipe->{PAUSED} ) {
                          _debug_desc_fd( 'pausing', $pipe ) if _debugging_details;
                          vec( $self->{WIN}, $pipe->{FD}, 1 ) = 0;
  
                          #		  vec( $self->{EIN}, $pipe->{FD}, 1 ) = 0;
                          vec( $self->{PIN}, $pipe->{FD}, 1 ) = 1;
                          $pipe->{PAUSED} = 1;
                      }
                      return 0;
                  }
                  _debug_desc_fd( 'writing to', $pipe ) if _debugging_details;
  
                  if ( length $$in_ref && $$in_ref ) {
                      my $c = _write( $pipe->{FD}, $$in_ref );
                      substr( $$in_ref, 0, $c, '' );
                  }
                  else {
                      $self->_clobber($pipe);
                      return undef;
                  }
  
                  return 1;
              };
              ## Output filters are the first filters
              unshift @{ $pipe->{FILTERS} }, $pipe_writer;
              push @{ $self->{TEMP_FILTERS} }, $pipe_writer;
          }
      }
  }
  
  sub _dup2_gently {
      ## A METHOD, NOT A FUNCTION, NEEDS $self!
      my IPC::Run $self = shift;
      my ( $files, $fd1, $fd2 ) = @_;
      ## Moves TFDs that are using the destination fd out of the
      ## way before calling _dup2
      for (@$files) {
          next unless defined $_->{TFD};
          $_->{TFD} = _dup( $_->{TFD} ) if $_->{TFD} == $fd2;
      }
      if ( defined $self->{DEBUG_FD} && $self->{DEBUG_FD} == $fd2 ) {
          $self->{DEBUG_FD} = _dup $self->{DEBUG_FD};
          $fds{$self->{DEBUG_FD}}{needed} = 1;
      }
      _dup2_rudely( $fd1, $fd2 );
  }
  
  =pod
  
  =item close_terminal
  
  This is used as (or in) an init sub to cast off the bonds of a controlling
  terminal.  It must precede all other redirection ops that affect
  STDIN, STDOUT, or STDERR to be guaranteed effective.
  
  =cut
  
  sub close_terminal {
      ## Cast of the bonds of a controlling terminal
  
      # Just in case the parent (I'm talking to you FCGI) had these tied.
      untie *STDIN;
      untie *STDOUT;
      untie *STDERR;
  
      POSIX::setsid() || croak "POSIX::setsid() failed";
      _debug "closing stdin, out, err"
        if _debugging_details;
      close STDIN;
      close STDERR;
      close STDOUT;
  }
  
  sub _do_kid_and_exit {
      my IPC::Run $self = shift;
      my ($kid) = @_;
  
      my ( $s1, $s2 );
      if ( $] < 5.008 ) {
          ## For unknown reasons, placing these two statements in the eval{}
          ## causes the eval {} to not catch errors after they are executed in
          ## perl 5.6.0, godforsaken version that it is...not sure about 5.6.1.
          ## Part of this could be that these symbols get destructed when
          ## exiting the eval, and that destruction might be what's (wrongly)
          ## confusing the eval{}, allowing the exception to propagate.
          $s1 = Symbol::gensym();
          $s2 = Symbol::gensym();
      }
  
      eval {
          local $cur_self = $self;
  
          if (_debugging) {
              _set_child_debug_name(
                  ref $kid->{VAL} eq "CODE"
                  ? "CODE"
                  : basename( $kid->{VAL}->[0] )
              );
          }
  
          ## close parent FD's first so they're out of the way.
          ## Don't close STDIN, STDOUT, STDERR: they should be inherited or
          ## overwritten below.
          do { $_->{needed} = 1 for @fds{0..2} }
             unless $self->{noinherit};
  
          $fds{$self->{SYNC_WRITER_FD}}{needed} = 1;
          $fds{$self->{DEBUG_FD}}{needed} = 1 if defined $self->{DEBUG_FD};
  
          $fds{$_->{TFD}}{needed} = 1
             foreach grep { defined $_->{TFD} } @{$kid->{OPS} };
  
  
          ## TODO: use the forthcoming IO::Pty to close the terminal and
          ## make the first pty for this child the controlling terminal.
          ## This will also make it so that pty-laden kids don't cause
          ## other kids to lose stdin/stdout/stderr.
  
          if ( %{ $self->{PTYS} } ) {
              ## Clean up the parent's fds.
              for ( keys %{ $self->{PTYS} } ) {
                  _debug "Cleaning up parent's ptty '$_'" if _debugging_details;
                  $self->{PTYS}->{$_}->make_slave_controlling_terminal;
                  my $slave = $self->{PTYS}->{$_}->slave;
   	        delete $fds{$self->{PTYS}->{$_}->fileno};
                  close $self->{PTYS}->{$_};
                  $self->{PTYS}->{$_} = $slave;
              }
  
              close_terminal;
              delete @fds{0..2};
          }
  
          for my $sibling ( @{ $self->{KIDS} } ) {
              for ( @{ $sibling->{OPS} } ) {
                  if ( $_->{TYPE} =~ /^.pty.$/ ) {
                      $_->{TFD} = $self->{PTYS}->{ $_->{PTY_ID} }->fileno;
                      $fds{$_->{TFD}}{needed} = 1;
                  }
  
                  #	    for ( $_->{FD}, ( $sibling != $kid ? $_->{TFD} : () ) ) {
                  #	       if ( defined $_ && ! $closed[$_] && ! $needed[$_] ) {
                  #		  _close( $_ );
                  #		  $closed[$_] = 1;
                  #		  $_ = undef;
                  #	       }
                  #	    }
              }
          }
  
          ## This is crude: we have no way of keeping track of browsing all open
          ## fds, so we scan to a fairly high fd.
          _debug "open fds: ", join " ", keys %fds if _debugging_details;
  
          _close( $_ ) foreach grep { ! $fds{$_}{needed} } keys %fds;
  
          for ( @{ $kid->{OPS} } ) {
              if ( defined $_->{TFD} ) {
  
                  # we're always creating KFD
                  $fds{$_->{KFD}}{needed} = 1;
  
                  unless ( $_->{TFD} == $_->{KFD} ) {
                      $self->_dup2_gently( $kid->{OPS}, $_->{TFD}, $_->{KFD} );
                      $fds{$_->{TFD}}{lazy_close} = 1;
                  } else {
                      my $fd = _dup($_->{TFD});
                      $self->_dup2_gently( $kid->{OPS}, $fd, $_->{KFD} );
                      _close($fd);
                  }
              }
              elsif ( $_->{TYPE} eq 'dup' ) {
                  $self->_dup2_gently( $kid->{OPS}, $_->{KFD1}, $_->{KFD2} )
                    unless $_->{KFD1} == $_->{KFD2};
                  $fds{$_->{KFD2}}{needed} = 1;
              }
              elsif ( $_->{TYPE} eq 'close' ) {
                  for ( $_->{KFD} ) {
                      if ( $fds{$_} ) {
                          _close($_);
                          $_ = undef;
                      }
                  }
              }
              elsif ( $_->{TYPE} eq 'init' ) {
                  $_->{SUB}->();
              }
          }
  
          _close( $_ ) foreach grep { $fds{$_}{lazy_close} } keys %fds;
  
          if ( ref $kid->{VAL} ne 'CODE' ) {
              open $s1, ">&=$self->{SYNC_WRITER_FD}"
                or croak "$! setting filehandle to fd SYNC_WRITER_FD";
              fcntl $s1, F_SETFD, 1;
  
              if ( defined $self->{DEBUG_FD} ) {
                  open $s2, ">&=$self->{DEBUG_FD}"
                    or croak "$! setting filehandle to fd DEBUG_FD";
                  fcntl $s2, F_SETFD, 1;
              }
  
              if (_debugging) {
                  my @cmd = ( $kid->{PATH}, @{ $kid->{VAL} }[ 1 .. $#{ $kid->{VAL} } ] );
                  _debug 'execing ', join " ", map { /[\s\"]/ ? "'$_'" : $_ } @cmd;
              }
  
              die "exec failed: simulating exec() failure"
                if $self->{_simulate_exec_failure};
  
              _exec $kid->{PATH}, @{ $kid->{VAL} }[ 1 .. $#{ $kid->{VAL} } ];
  
              croak "exec failed: $!";
          }
      };
      if ($@) {
          _write $self->{SYNC_WRITER_FD}, $@;
          ## Avoid DESTROY.
          POSIX::_exit(1);
      }
  
      ## We must be executing code in the child, otherwise exec() would have
      ## prevented us from being here.
      _close $self->{SYNC_WRITER_FD};
      _debug 'calling fork()ed CODE ref' if _debugging;
      POSIX::close $self->{DEBUG_FD} if defined $self->{DEBUG_FD};
      ## TODO: Overload CORE::GLOBAL::exit...
      $kid->{VAL}->();
  
      ## There are bugs in perl closures up to and including 5.6.1
      ## that may keep this next line from having any effect, and it
      ## won't have any effect if our caller has kept a copy of it, but
      ## this may cause the closure to be cleaned up.  Maybe.
      $kid->{VAL} = undef;
  
      ## Use POSIX::_exit to avoid global destruction, since this might
      ## cause DESTROY() to be called on objects created in the parent
      ## and thus cause double cleanup.  For instance, if DESTROY() unlinks
      ## a file in the child, we don't want the parent to suddenly miss
      ## it.
      POSIX::_exit(0);
  }
  
  =pod
  
  =item start
  
     $h = start(
        \@cmd, \$in, \$out, ...,
        timeout( 30, name => "process timeout" ),
        $stall_timeout = timeout( 10, name => "stall timeout"   ),
     );
  
     $h = start \@cmd, '<', \$in, '|', \@cmd2, ...;
  
  start() accepts a harness or harness specification and returns a harness
  after building all of the pipes and launching (via fork()/exec(), or, maybe
  someday, spawn()) all the child processes.  It does not send or receive any
  data on the pipes, see pump() and finish() for that.
  
  You may call harness() and then pass it's result to start() if you like,
  but you only need to if it helps you structure or tune your application.
  If you do call harness(), you may skip start() and proceed directly to
  pump.
  
  start() also starts all timers in the harness.  See L<IPC::Run::Timer>
  for more information.
  
  start() flushes STDOUT and STDERR to help you avoid duplicate output.
  It has no way of asking Perl to flush all your open filehandles, so
  you are going to need to flush any others you have open.  Sorry.
  
  Here's how if you don't want to alter the state of $| for your
  filehandle:
  
     $ofh = select HANDLE; $of = $|; $| = 1; $| = $of; select $ofh;
  
  If you don't mind leaving output unbuffered on HANDLE, you can do
  the slightly shorter
  
     $ofh = select HANDLE; $| = 1; select $ofh;
  
  Or, you can use IO::Handle's flush() method:
  
     use IO::Handle;
     flush HANDLE;
  
  Perl needs the equivalent of C's fflush( (FILE *)NULL ).
  
  =cut
  
  sub start {
  
      # $SIG{__DIE__} = sub { my $s = shift; Carp::cluck $s; die $s };
      my $options;
      if ( @_ && ref $_[-1] eq 'HASH' ) {
          $options = pop;
          require Data::Dumper;
          carp "Passing in options as a hash is deprecated:\n", Data::Dumper::Dumper($options);
      }
  
      my IPC::Run $self;
      if ( @_ == 1 && UNIVERSAL::isa( $_[0], __PACKAGE__ ) ) {
          $self = shift;
          $self->{$_} = $options->{$_} for keys %$options;
      }
      else {
          $self = harness( @_, $options ? $options : () );
      }
  
      local $cur_self = $self;
  
      $self->kill_kill if $self->{STATE} == _started;
  
      _debug "** starting" if _debugging;
  
      $_->{RESULT} = undef for @{ $self->{KIDS} };
  
      ## Assume we're not being called from &run.  It will correct our
      ## assumption if need be.  This affects whether &_select_loop clears
      ## input queues to '' when they're empty.
      $self->{clear_ins} = 1;
  
      IPC::Run::Win32Helper::optimize $self
        if Win32_MODE && $in_run;
  
      my @errs;
  
      for ( @{ $self->{TIMERS} } ) {
          eval { $_->start };
          if ($@) {
              push @errs, $@;
              _debug 'caught ', $@ if _debugging;
          }
      }
  
      eval { $self->_open_pipes };
      if ($@) {
          push @errs, $@;
          _debug 'caught ', $@ if _debugging;
      }
  
      if ( !@errs ) {
          ## This is a bit of a hack, we should do it for all open filehandles.
          ## Since there's no way I know of to enumerate open filehandles, we
          ## autoflush STDOUT and STDERR.  This is done so that the children don't
          ## inherit output buffers chock full o' redundant data.  It's really
          ## confusing to track that down.
          { my $ofh = select STDOUT; my $of = $|; $| = 1; $| = $of; select $ofh; }
          { my $ofh = select STDERR; my $of = $|; $| = 1; $| = $of; select $ofh; }
          for my $kid ( @{ $self->{KIDS} } ) {
              $kid->{RESULT} = undef;
              _debug "child: ", _debugstrings( $kid->{VAL} )
                if _debugging_details;
              eval {
                  croak "simulated failure of fork"
                    if $self->{_simulate_fork_failure};
                  unless (Win32_MODE) {
                      $self->_spawn($kid);
                  }
                  else {
  ## TODO: Test and debug spawning code.  Someday.
                      _debug(
                          'spawning ',
                          _debugstrings(
                              [
                                  $kid->{PATH},
                                  @{ $kid->{VAL} }[ 1 .. $#{ $kid->{VAL} } ]
                              ]
                          )
                      ) if $kid->{PATH} && _debugging;
                      ## The external kid wouldn't know what to do with it anyway.
                      ## This is only used by the "helper" pump processes on Win32.
                      _dont_inherit( $self->{DEBUG_FD} );
                      ( $kid->{PID}, $kid->{PROCESS} ) = IPC::Run::Win32Helper::win32_spawn(
                          ref( $kid->{VAL} ) eq "ARRAY"
                          ? [ $kid->{PATH}, @{ $kid->{VAL} }[ 1 .. $#{ $kid->{VAL} } ] ]
                          : $kid->{VAL},
                          $kid->{OPS},
                      );
                      _debug "spawn() = ", $kid->{PID} if _debugging;
                      if ($self->{_sleep_after_win32_spawn}) {
                        sleep $self->{_sleep_after_win32_spawn};
                        _debug "after sleep $self->{_sleep_after_win32_spawn}"
                            if _debugging;
                      }
                  }
              };
              if ($@) {
                  push @errs, $@;
                  _debug 'caught ', $@ if _debugging;
              }
          }
      }
  
      ## Close all those temporary filehandles that the kids needed.
      for my $pty ( values %{ $self->{PTYS} } ) {
          close $pty->slave;
      }
  
      my @closed;
      for my $kid ( @{ $self->{KIDS} } ) {
          for ( @{ $kid->{OPS} } ) {
              my $close_it = eval {
                       defined $_->{TFD}
                    && !$_->{DONT_CLOSE}
                    && !$closed[ $_->{TFD} ]
                    && ( !Win32_MODE || !$_->{RECV_THROUGH_TEMP_FILE} )    ## Win32 hack
              };
              if ($@) {
                  push @errs, $@;
                  _debug 'caught ', $@ if _debugging;
              }
              if ( $close_it || $@ ) {
                  eval {
                      _close( $_->{TFD} );
                      $closed[ $_->{TFD} ] = 1;
                      $_->{TFD} = undef;
                  };
                  if ($@) {
                      push @errs, $@;
                      _debug 'caught ', $@ if _debugging;
                  }
              }
          }
      }
      confess "gak!" unless defined $self->{PIPES};
  
      if (@errs) {
          eval { $self->_cleanup };
          warn $@ if $@;
          die join( '', @errs );
      }
  
      $self->{STATE} = _started;
      return $self;
  }
  
  =item adopt
  
  Experimental feature. NOT FUNCTIONAL YET, NEED TO CLOSE FDS BETTER IN CHILDREN.  SEE t/adopt.t for a test suite.
  
  =cut
  
  sub adopt {
      my IPC::Run $self = shift;
  
      for my $adoptee (@_) {
          push @{ $self->{IOS} }, @{ $adoptee->{IOS} };
          ## NEED TO RENUMBER THE KIDS!!
          push @{ $self->{KIDS} },  @{ $adoptee->{KIDS} };
          push @{ $self->{PIPES} }, @{ $adoptee->{PIPES} };
          $self->{PTYS}->{$_} = $adoptee->{PTYS}->{$_} for keys %{ $adoptee->{PYTS} };
          push @{ $self->{TIMERS} }, @{ $adoptee->{TIMERS} };
          $adoptee->{STATE} = _finished;
      }
  }
  
  sub _clobber {
      my IPC::Run $self = shift;
      my ($file) = @_;
      _debug_desc_fd( "closing", $file ) if _debugging_details;
      my $doomed = $file->{FD};
      my $dir = $file->{TYPE} =~ /^</ ? 'WIN' : 'RIN';
      vec( $self->{$dir}, $doomed, 1 ) = 0;
  
      #   vec( $self->{EIN},  $doomed, 1 ) = 0;
      vec( $self->{PIN}, $doomed, 1 ) = 0;
      if ( $file->{TYPE} =~ /^(.)pty.$/ ) {
          if ( $1 eq '>' ) {
              ## Only close output ptys.  This is so that ptys as inputs are
              ## never autoclosed, which would risk losing data that was
              ## in the slave->parent queue.
              _debug_desc_fd "closing pty", $file if _debugging_details;
              close $self->{PTYS}->{ $file->{PTY_ID} }
                if defined $self->{PTYS}->{ $file->{PTY_ID} };
              $self->{PTYS}->{ $file->{PTY_ID} } = undef;
          }
      }
      elsif ( UNIVERSAL::isa( $file, 'IPC::Run::IO' ) ) {
          $file->close unless $file->{DONT_CLOSE};
      }
      else {
          _close($doomed);
      }
  
      @{ $self->{PIPES} } = grep
        defined $_->{FD} && ( $_->{TYPE} ne $file->{TYPE} || $_->{FD} ne $doomed ),
        @{ $self->{PIPES} };
  
      $file->{FD} = undef;
  }
  
  sub _select_loop {
      my IPC::Run $self = shift;
  
      my $io_occurred;
  
      my $not_forever = 0.01;
  
    SELECT:
      while ( $self->pumpable ) {
          if ( $io_occurred && $self->{break_on_io} ) {
              _debug "exiting _select(): io occurred and break_on_io set"
                if _debugging_details;
              last;
          }
  
          my $timeout = $self->{non_blocking} ? 0 : undef;
  
          if ( @{ $self->{TIMERS} } ) {
              my $now = time;
              my $time_left;
              for ( @{ $self->{TIMERS} } ) {
                  next unless $_->is_running;
                  $time_left = $_->check($now);
                  ## Return when a timer expires
                  return if defined $time_left && !$time_left;
                  $timeout = $time_left
                    if !defined $timeout || $time_left < $timeout;
              }
          }
  
          ##
          ## See if we can unpause any input channels
          ##
          my $paused = 0;
  
          for my $file ( @{ $self->{PIPES} } ) {
              next unless $file->{PAUSED} && $file->{TYPE} =~ /^</;
  
              _debug_desc_fd( "checking for more input", $file ) if _debugging_details;
              my $did;
              1 while $did = $file->_do_filters($self);
              if ( defined $file->{FD} && !defined($did) || $did ) {
                  _debug_desc_fd( "unpausing", $file ) if _debugging_details;
                  $file->{PAUSED} = 0;
                  vec( $self->{WIN}, $file->{FD}, 1 ) = 1;
  
                  #	    vec( $self->{EIN}, $file->{FD}, 1 ) = 1;
                  vec( $self->{PIN}, $file->{FD}, 1 ) = 0;
              }
              else {
                  ## This gets incremented occasionally when the IO channel
                  ## was actually closed.  That's a bug, but it seems mostly
                  ## harmless: it causes us to exit if break_on_io, or to set
                  ## the timeout to not be forever.  I need to fix it, though.
                  ++$paused;
              }
          }
  
          if (_debugging_details) {
              my $map = join(
                  '',
                  map {
                      my $out;
                      $out = 'r' if vec( $self->{RIN}, $_, 1 );
                      $out = $out ? 'b' : 'w' if vec( $self->{WIN}, $_, 1 );
                      $out = 'p' if !$out && vec( $self->{PIN}, $_, 1 );
                      $out = $out ? uc($out) : 'x' if vec( $self->{EIN}, $_, 1 );
                      $out = '-' unless $out;
                      $out;
                  } ( 0 .. 1024 )
              );
              $map =~ s/((?:[a-zA-Z-]|\([^\)]*\)){12,}?)-*$/$1/;
              _debug 'fds for select: ', $map if _debugging_details;
          }
  
          ## _do_filters may have closed our last fd, and we need to see if
          ## we have I/O, or are just waiting for children to exit.
          my $p = $self->pumpable;
          last unless $p;
          if ( $p != 0 && ( !defined $timeout || $timeout > 0.1 ) ) {
              ## No I/O will wake the select loop up, but we have children
              ## lingering, so we need to poll them with a short timeout.
              ## Otherwise, assume more input will be coming.
              $timeout = $not_forever;
              $not_forever *= 2;
              $not_forever = 0.5 if $not_forever >= 0.5;
          }
  
          ## Make sure we don't block forever in select() because inputs are
          ## paused.
          if ( !defined $timeout && !( @{ $self->{PIPES} } - $paused ) ) {
              ## Need to return if we're in pump and all input is paused, or
              ## we'll loop until all inputs are unpaused, which is darn near
              ## forever.  And a day.
              if ( $self->{break_on_io} ) {
                  _debug "exiting _select(): no I/O to do and timeout=forever"
                    if _debugging;
                  last;
              }
  
              ## Otherwise, assume more input will be coming.
              $timeout = $not_forever;
              $not_forever *= 2;
              $not_forever = 0.5 if $not_forever >= 0.5;
          }
  
          _debug 'timeout=', defined $timeout ? $timeout : 'forever'
            if _debugging_details;
  
          my $nfound;
          unless (Win32_MODE) {
              $nfound = select(
                  $self->{ROUT} = $self->{RIN},
                  $self->{WOUT} = $self->{WIN},
                  $self->{EOUT} = $self->{EIN},
                  $timeout
              );
          }
          else {
              my @in = map $self->{$_}, qw( RIN WIN EIN );
              ## Win32's select() on Win32 seems to die if passed vectors of
              ## all 0's.  Need to report this when I get back online.
              for (@in) {
                  $_ = undef unless index( ( unpack "b*", $_ ), 1 ) >= 0;
              }
  
              $nfound = select(
                  $self->{ROUT} = $in[0],
                  $self->{WOUT} = $in[1],
                  $self->{EOUT} = $in[2],
                  $timeout
              );
  
              for ( $self->{ROUT}, $self->{WOUT}, $self->{EOUT} ) {
                  $_ = "" unless defined $_;
              }
          }
          last if !$nfound && $self->{non_blocking};
  
          if ( $nfound < 0 ) {
              if ( $!{EINTR} ) {
  
                  # Caught a signal before any FD went ready.  Ensure that
                  # the bit fields reflect "no FDs ready".
                  $self->{ROUT} = $self->{WOUT} = $self->{EOUT} = '';
                  $nfound = 0;
              }
              else {
                  croak "$! in select";
              }
          }
          ## TODO: Analyze the EINTR failure mode and see if this patch
          ## is adequate and optimal.
          ## TODO: Add an EINTR test to the test suite.
  
          if (_debugging_details) {
              my $map = join(
                  '',
                  map {
                      my $out;
                      $out = 'r' if vec( $self->{ROUT}, $_, 1 );
                      $out = $out ? 'b'      : 'w' if vec( $self->{WOUT}, $_, 1 );
                      $out = $out ? uc($out) : 'x' if vec( $self->{EOUT}, $_, 1 );
                      $out = '-' unless $out;
                      $out;
                  } ( 0 .. 128 )
              );
              $map =~ s/((?:[a-zA-Z-]|\([^\)]*\)){12,}?)-*$/$1/;
              _debug "selected  ", $map;
          }
  
          ## Need to copy since _clobber alters @{$self->{PIPES}}.
          ## TODO: Rethink _clobber().  Rethink $file->{PAUSED}, too.
          my @pipes = @{ $self->{PIPES} };
          $io_occurred = $_->poll($self) ? 1 : $io_occurred for @pipes;
  
          #   FILE:
          #      for my $pipe ( @pipes ) {
          #         ## Pipes can be shared among kids.  If another kid closes the
          #         ## pipe, then it's {FD} will be undef.  Also, on Win32, pipes can
          #	 ## be optimized to be files, in which case the FD is left undef
          #	 ## so we don't try to select() on it.
          #         if ( $pipe->{TYPE} =~ /^>/
          #            && defined $pipe->{FD}
          #            && vec( $self->{ROUT}, $pipe->{FD}, 1 )
          #         ) {
          #            _debug_desc_fd( "filtering data from", $pipe ) if _debugging_details;
          #confess "phooey" unless UNIVERSAL::isa( $pipe, "IPC::Run::IO" );
          #            $io_occurred = 1 if $pipe->_do_filters( $self );
          #
          #            next FILE unless defined $pipe->{FD};
          #         }
          #
          #	 ## On Win32, pipes to the child can be optimized to be files
          #	 ## and FD left undefined so we won't select on it.
          #         if ( $pipe->{TYPE} =~ /^</
          #            && defined $pipe->{FD}
          #            && vec( $self->{WOUT}, $pipe->{FD}, 1 )
          #         ) {
          #            _debug_desc_fd( "filtering data to", $pipe ) if _debugging_details;
          #            $io_occurred = 1 if $pipe->_do_filters( $self );
          #
          #            next FILE unless defined $pipe->{FD};
          #         }
          #
          #         if ( defined $pipe->{FD} && vec( $self->{EOUT}, $pipe->{FD}, 1 ) ) {
          #            ## BSD seems to sometimes raise the exceptional condition flag
          #            ## when a pipe is closed before we read it's last data.  This
          #            ## causes spurious warnings and generally renders the exception
          #            ## mechanism useless for our purposes.  The exception
          #            ## flag semantics are too variable (they're device driver
          #            ## specific) for me to easily map to any automatic action like
          #            ## warning or croaking (try running v0.42 if you don't believe me
          #            ## :-).
          #            warn "Exception on descriptor $pipe->{FD}";
          #         }
          #      }
      }
  
      return;
  }
  
  sub _cleanup {
      my IPC::Run $self = shift;
      _debug "cleaning up" if _debugging_details;
  
      for ( values %{ $self->{PTYS} } ) {
          next unless ref $_;
          eval {
              _debug "closing slave fd ", fileno $_->slave if _debugging_data;
              close $_->slave;
          };
          carp $@ . " while closing ptys" if $@;
          eval {
              _debug "closing master fd ", fileno $_ if _debugging_data;
              close $_;
          };
          carp $@ . " closing ptys" if $@;
      }
  
      _debug "cleaning up pipes" if _debugging_details;
      ## _clobber modifies PIPES
      $self->_clobber( $self->{PIPES}->[0] ) while @{ $self->{PIPES} };
  
      for my $kid ( @{ $self->{KIDS} } ) {
          _debug "cleaning up kid ", $kid->{NUM} if _debugging_details;
          if ( !length $kid->{PID} ) {
              _debug 'never ran child ', $kid->{NUM}, ", can't reap"
                if _debugging;
              for my $op ( @{ $kid->{OPS} } ) {
                  _close( $op->{TFD} )
                    if defined $op->{TFD} && !defined $op->{TEMP_FILE_HANDLE};
              }
          }
          elsif ( !defined $kid->{RESULT} ) {
              _debug 'reaping child ', $kid->{NUM}, ' (pid ', $kid->{PID}, ')'
                if _debugging;
              my $pid = waitpid $kid->{PID}, 0;
              $kid->{RESULT} = $?;
              _debug 'reaped ', $pid, ', $?=', $kid->{RESULT}
                if _debugging;
          }
  
          #      if ( defined $kid->{DEBUG_FD} ) {
          #	 die;
          #         @{$kid->{OPS}} = grep
          #            ! defined $_->{KFD} || $_->{KFD} != $kid->{DEBUG_FD},
          #            @{$kid->{OPS}};
          #         $kid->{DEBUG_FD} = undef;
          #      }
  
          _debug "cleaning up filters" if _debugging_details;
          for my $op ( @{ $kid->{OPS} } ) {
              @{ $op->{FILTERS} } = grep {
                  my $filter = $_;
                  !grep $filter == $_, @{ $self->{TEMP_FILTERS} };
              } @{ $op->{FILTERS} };
          }
  
          for my $op ( @{ $kid->{OPS} } ) {
              $op->_cleanup($self) if UNIVERSAL::isa( $op, "IPC::Run::IO" );
          }
      }
      $self->{STATE} = _finished;
      @{ $self->{TEMP_FILTERS} } = ();
      _debug "done cleaning up" if _debugging_details;
  
      POSIX::close $self->{DEBUG_FD} if defined $self->{DEBUG_FD};
      $self->{DEBUG_FD} = undef;
  }
  
  =pod
  
  =item pump
  
     pump $h;
     $h->pump;
  
  Pump accepts a single parameter harness.  It blocks until it delivers some
  input or receives some output.  It returns TRUE if there is still input or
  output to be done, FALSE otherwise.
  
  pump() will automatically call start() if need be, so you may call harness()
  then proceed to pump() if that helps you structure your application.
  
  If pump() is called after all harnessed activities have completed, a "process
  ended prematurely" exception to be thrown.  This allows for simple scripting
  of external applications without having to add lots of error handling code at
  each step of the script:
  
     $h = harness \@smbclient, \$in, \$out, $err;
  
     $in = "cd /foo\n";
     $h->pump until $out =~ /^smb.*> \Z/m;
     die "error cding to /foo:\n$out" if $out =~ "ERR";
     $out = '';
  
     $in = "mget *\n";
     $h->pump until $out =~ /^smb.*> \Z/m;
     die "error retrieving files:\n$out" if $out =~ "ERR";
  
     $h->finish;
  
     warn $err if $err;
  
  =cut
  
  sub pump {
      die "pump() takes only a single harness as a parameter"
        unless @_ == 1 && UNIVERSAL::isa( $_[0], __PACKAGE__ );
  
      my IPC::Run $self = shift;
  
      local $cur_self = $self;
  
      _debug "** pumping"
        if _debugging;
  
      #   my $r = eval {
      $self->start if $self->{STATE} < _started;
      croak "process ended prematurely" unless $self->pumpable;
  
      $self->{auto_close_ins} = 0;
      $self->{break_on_io}    = 1;
      $self->_select_loop;
      return $self->pumpable;
  
      #   };
      #   if ( $@ ) {
      #      my $x = $@;
      #      _debug $x if _debugging && $x;
      #      eval { $self->_cleanup };
      #      warn $@ if $@;
      #      die $x;
      #   }
      #   return $r;
  }
  
  =pod
  
  =item pump_nb
  
     pump_nb $h;
     $h->pump_nb;
  
  "pump() non-blocking", pumps if anything's ready to be pumped, returns
  immediately otherwise.  This is useful if you're doing some long-running
  task in the foreground, but don't want to starve any child processes.
  
  =cut
  
  sub pump_nb {
      my IPC::Run $self = shift;
  
      $self->{non_blocking} = 1;
      my $r = eval { $self->pump };
      $self->{non_blocking} = 0;
      die $@ if $@;
      return $r;
  }
  
  =pod
  
  =item pumpable
  
  Returns TRUE if calling pump() won't throw an immediate "process ended
  prematurely" exception.  This means that there are open I/O channels or
  active processes. May yield the parent processes' time slice for 0.01
  second if all pipes are to the child and all are paused.  In this case
  we can't tell if the child is dead, so we yield the processor and
  then attempt to reap the child in a nonblocking way.
  
  =cut
  
  ## Undocumented feature (don't depend on it outside this module):
  ## returns -1 if we have I/O channels open, or >0 if no I/O channels
  ## open, but we have kids running.  This allows the select loop
  ## to poll for child exit.
  sub pumpable {
      my IPC::Run $self = shift;
  
      ## There's a catch-22 we can get in to if there is only one pipe left
      ## open to the child and it's paused (ie the SCALAR it's tied to
      ## is '').  It's paused, so we're not select()ing on it, so we don't
      ## check it to see if the child attached to it is alive and it stays
      ## in @{$self->{PIPES}} forever.  So, if all pipes are paused, see if
      ## we can reap the child.
      return -1 if grep !$_->{PAUSED}, @{ $self->{PIPES} };
  
      ## See if the child is dead.
      $self->reap_nb;
      return 0 unless $self->_running_kids;
  
      ## If we reap_nb and it's not dead yet, yield to it to see if it
      ## exits.
      ##
      ## A better solution would be to unpause all the pipes, but I tried that
      ## and it never errored on linux.  Sigh.
      select undef, undef, undef, 0.0001;
  
      ## try again
      $self->reap_nb;
      return 0 unless $self->_running_kids;
  
      return -1;    ## There are pipes waiting
  }
  
  sub _running_kids {
      my IPC::Run $self = shift;
      return grep
        defined $_->{PID} && !defined $_->{RESULT},
        @{ $self->{KIDS} };
  }
  
  =pod
  
  =item reap_nb
  
  Attempts to reap child processes, but does not block.
  
  Does not currently take any parameters, one day it will allow specific
  children to be reaped.
  
  Only call this from a signal handler if your C<perl> is recent enough
  to have safe signal handling (5.6.1 did not, IIRC, but it was being discussed
  on perl5-porters).  Calling this (or doing any significant work) in a signal
  handler on older C<perl>s is asking for seg faults.
  
  =cut
  
  my $still_runnings;
  
  sub reap_nb {
      my IPC::Run $self = shift;
  
      local $cur_self = $self;
  
      ## No more pipes, look to see if all the kids yet live, reaping those
      ## that haven't.  I'd use $SIG{CHLD}/$SIG{CLD}, but that's broken
      ## on older (SYSV) platforms and perhaps less portable than waitpid().
      ## This could be slow with a lot of kids, but that's rare and, well,
      ## a lot of kids is slow in the first place.
      ## Oh, and this keeps us from reaping other children the process
      ## may have spawned.
      for my $kid ( @{ $self->{KIDS} } ) {
          if (Win32_MODE) {
              next if !defined $kid->{PROCESS} || defined $kid->{RESULT};
              unless ( $kid->{PROCESS}->Wait(0) ) {
                  _debug "kid $kid->{NUM} ($kid->{PID}) still running"
                    if _debugging_details;
                  next;
              }
  
              _debug "kid $kid->{NUM} ($kid->{PID}) exited"
                if _debugging;
  
              $kid->{PROCESS}->GetExitCode( $kid->{RESULT} )
                or croak "$! while GetExitCode()ing for Win32 process";
  
              unless ( defined $kid->{RESULT} ) {
                  $kid->{RESULT} = "0 but true";
                  $? = $kid->{RESULT} = 0x0F;
              }
              else {
                  $? = $kid->{RESULT} << 8;
              }
          }
          else {
              next if !defined $kid->{PID} || defined $kid->{RESULT};
              my $pid = waitpid $kid->{PID}, POSIX::WNOHANG();
              unless ($pid) {
                  _debug "$kid->{NUM} ($kid->{PID}) still running"
                    if _debugging_details;
                  next;
              }
  
              if ( $pid < 0 ) {
                  _debug "No such process: $kid->{PID}\n" if _debugging;
                  $kid->{RESULT} = "unknown result, unknown PID";
              }
              else {
                  _debug "kid $kid->{NUM} ($kid->{PID}) exited"
                    if _debugging;
  
                  confess "waitpid returned the wrong PID: $pid instead of $kid->{PID}"
                    unless $pid == $kid->{PID};
                  _debug "$kid->{PID} returned $?\n" if _debugging;
                  $kid->{RESULT} = $?;
              }
          }
      }
  }
  
  =pod
  
  =item finish
  
  This must be called after the last start() or pump() call for a harness,
  or your system will accumulate defunct processes and you may "leak"
  file descriptors.
  
  finish() returns TRUE if all children returned 0 (and were not signaled and did
  not coredump, ie ! $?), and FALSE otherwise (this is like run(), and the
  opposite of system()).
  
  Once a harness has been finished, it may be run() or start()ed again,
  including by pump()s auto-start.
  
  If this throws an exception rather than a normal exit, the harness may
  be left in an unstable state, it's best to kill the harness to get rid
  of all the child processes, etc.
  
  Specifically, if a timeout expires in finish(), finish() will not
  kill all the children.  Call C<<$h->kill_kill>> in this case if you care.
  This differs from the behavior of L</run>.
  
  =cut
  
  sub finish {
      my IPC::Run $self = shift;
      my $options = @_ && ref $_[-1] eq 'HASH' ? pop : {};
  
      local $cur_self = $self;
  
      _debug "** finishing" if _debugging;
  
      $self->{non_blocking}   = 0;
      $self->{auto_close_ins} = 1;
      $self->{break_on_io}    = 0;
  
      # We don't alter $self->{clear_ins}, start() and run() control it.
  
      while ( $self->pumpable ) {
          $self->_select_loop($options);
      }
      $self->_cleanup;
  
      return !$self->full_result;
  }
  
  =pod
  
  =item result
  
     $h->result;
  
  Returns the first non-zero result code (ie $? >> 8).  See L</full_result> to 
  get the $? value for a child process.
  
  To get the result of a particular child, do:
  
     $h->result( 0 );  # first child's $? >> 8
     $h->result( 1 );  # second child
  
  or
  
     ($h->results)[0]
     ($h->results)[1]
  
  Returns undef if no child processes were spawned and no child number was
  specified.  Throws an exception if an out-of-range child number is passed.
  
  =cut
  
  sub _assert_finished {
      my IPC::Run $self = $_[0];
  
      croak "Harness not run" unless $self->{STATE} >= _finished;
      croak "Harness not finished running" unless $self->{STATE} == _finished;
  }
  
  sub _child_result {
      my IPC::Run $self = shift;
  
      my ($which) = @_;
      croak(
          "Only ",
          scalar( @{ $self->{KIDS} } ),
          " child processes, no process $which"
      ) unless $which >= 0 && $which <= $#{ $self->{KIDS} };
      return $self->{KIDS}->[$which]->{RESULT};
  }
  
  sub result {
      &_assert_finished;
      my IPC::Run $self = shift;
  
      if (@_) {
          my ($which) = @_;
          return $self->_child_result($which) >> 8;
      }
      else {
          return undef unless @{ $self->{KIDS} };
          for ( @{ $self->{KIDS} } ) {
              return $_->{RESULT} >> 8 if $_->{RESULT} >> 8;
          }
      }
  }
  
  =pod
  
  =item results
  
  Returns a list of child exit values.  See L</full_results> if you want to
  know if a signal killed the child.
  
  Throws an exception if the harness is not in a finished state.
   
  =cut
  
  sub results {
      &_assert_finished;
      my IPC::Run $self = shift;
  
      # we add 0 here to stop warnings associated with "unknown result, unknown PID"
      return map { ( 0 + $_->{RESULT} ) >> 8 } @{ $self->{KIDS} };
  }
  
  =pod
  
  =item full_result
  
     $h->full_result;
  
  Returns the first non-zero $?.  See L</result> to get the first $? >> 8 
  value for a child process.
  
  To get the result of a particular child, do:
  
     $h->full_result( 0 );  # first child's $?
     $h->full_result( 1 );  # second child
  
  or
  
     ($h->full_results)[0]
     ($h->full_results)[1]
  
  Returns undef if no child processes were spawned and no child number was
  specified.  Throws an exception if an out-of-range child number is passed.
  
  =cut
  
  sub full_result {
      &_assert_finished;
  
      my IPC::Run $self = shift;
  
      if (@_) {
          my ($which) = @_;
          return $self->_child_result($which);
      }
      else {
          return undef unless @{ $self->{KIDS} };
          for ( @{ $self->{KIDS} } ) {
              return $_->{RESULT} if $_->{RESULT};
          }
      }
  }
  
  =pod
  
  =item full_results
  
  Returns a list of child exit values as returned by C<wait>.  See L</results>
  if you don't care about coredumps or signals.
  
  Throws an exception if the harness is not in a finished state.
   
  =cut
  
  sub full_results {
      &_assert_finished;
      my IPC::Run $self = shift;
  
      croak "Harness not run" unless $self->{STATE} >= _finished;
      croak "Harness not finished running" unless $self->{STATE} == _finished;
  
      return map $_->{RESULT}, @{ $self->{KIDS} };
  }
  
  ##
  ## Filter Scaffolding
  ##
  use vars (
      '$filter_op',     ## The op running a filter chain right now
      '$filter_num',    ## Which filter is being run right now.
  );
  
  ##
  ## A few filters and filter constructors
  ##
  
  =pod
  
  =back
  
  =back
  
  =head1 FILTERS
  
  These filters are used to modify input our output between a child
  process and a scalar or subroutine endpoint.
  
  =over
  
  =item binary
  
     run \@cmd, ">", binary, \$out;
     run \@cmd, ">", binary, \$out;  ## Any TRUE value to enable
     run \@cmd, ">", binary 0, \$out;  ## Any FALSE value to disable
  
  This is a constructor for a "binmode" "filter" that tells IPC::Run to keep
  the carriage returns that would ordinarily be edited out for you (binmode
  is usually off).  This is not a real filter, but an option masquerading as
  a filter.
  
  It's not named "binmode" because you're likely to want to call Perl's binmode
  in programs that are piping binary data around.
  
  =cut
  
  sub binary(;$) {
      my $enable = @_ ? shift : 1;
      return bless sub { $enable }, "IPC::Run::binmode_pseudo_filter";
  }
  
  =pod
  
  =item new_chunker
  
  This breaks a stream of data in to chunks, based on an optional
  scalar or regular expression parameter.  The default is the Perl
  input record separator in $/, which is a newline be default.
  
     run \@cmd, '>', new_chunker, \&lines_handler;
     run \@cmd, '>', new_chunker( "\r\n" ), \&lines_handler;
  
  Because this uses $/ by default, you should always pass in a parameter
  if you are worried about other code (modules, etc) modifying $/.
  
  If this filter is last in a filter chain that dumps in to a scalar,
  the scalar must be set to '' before a new chunk will be written to it.
  
  As an example of how a filter like this can be written, here's a
  chunker that splits on newlines:
  
     sub line_splitter {
        my ( $in_ref, $out_ref ) = @_;
  
        return 0 if length $$out_ref;
  
        return input_avail && do {
           while (1) {
              if ( $$in_ref =~ s/\A(.*?\n)// ) {
                 $$out_ref .= $1;
                 return 1;
              }
              my $hmm = get_more_input;
              unless ( defined $hmm ) {
                 $$out_ref = $$in_ref;
                 $$in_ref = '';
                 return length $$out_ref ? 1 : 0;
              }
              return 0 if $hmm eq 0;
           }
        }
     };
  
  =cut
  
  sub new_chunker(;$) {
      my ($re) = @_;
      $re = $/ if _empty $re;
      $re = quotemeta($re) unless ref $re eq 'Regexp';
      $re = qr/\A(.*?$re)/s;
  
      return sub {
          my ( $in_ref, $out_ref ) = @_;
  
          return 0 if length $$out_ref;
  
          return input_avail && do {
              while (1) {
                  if ( $$in_ref =~ s/$re// ) {
                      $$out_ref .= $1;
                      return 1;
                  }
                  my $hmm = get_more_input;
                  unless ( defined $hmm ) {
                      $$out_ref = $$in_ref;
                      $$in_ref  = '';
                      return length $$out_ref ? 1 : 0;
                  }
                  return 0 if $hmm eq 0;
              }
            }
      };
  }
  
  =pod
  
  =item new_appender
  
  This appends a fixed string to each chunk of data read from the source
  scalar or sub.  This might be useful if you're writing commands to a
  child process that always must end in a fixed string, like "\n":
  
     run( \@cmd,
        '<', new_appender( "\n" ), \&commands,
     );
  
  Here's a typical filter sub that might be created by new_appender():
  
     sub newline_appender {
        my ( $in_ref, $out_ref ) = @_;
  
        return input_avail && do {
           $$out_ref = join( '', $$out_ref, $$in_ref, "\n" );
           $$in_ref = '';
           1;
        }
     };
  
  =cut
  
  sub new_appender($) {
      my ($suffix) = @_;
      croak "\$suffix undefined" unless defined $suffix;
  
      return sub {
          my ( $in_ref, $out_ref ) = @_;
  
          return input_avail && do {
              $$out_ref = join( '', $$out_ref, $$in_ref, $suffix );
              $$in_ref = '';
              1;
            }
      };
  }
  
  =item new_string_source
  
  TODO: Needs confirmation. Was previously undocumented. in this module.
  
  This is a filter which is exportable. Returns a sub which appends the data passed in to the output buffer and returns 1 if data was appended. 0 if it was an empty string and undef if no data was passed. 
  
  NOTE: Any additional variables passed to new_string_source will be passed to the sub every time it's called and appended to the output. 
  
  =cut
  
  sub new_string_source {
      my $ref;
      if ( @_ > 1 ) {
          $ref = [@_],
      }
      else {
          $ref = shift;
      }
  
      return ref $ref eq 'SCALAR'
        ? sub {
          my ( $in_ref, $out_ref ) = @_;
  
          return defined $$ref
            ? do {
              $$out_ref .= $$ref;
              my $r = length $$ref ? 1 : 0;
              $$ref = undef;
              $r;
            }
            : undef;
        }
        : sub {
          my ( $in_ref, $out_ref ) = @_;
  
          return @$ref
            ? do {
              my $s = shift @$ref;
              $$out_ref .= $s;
              length $s ? 1 : 0;
            }
            : undef;
        }
  }
  
  =item new_string_sink
  
  TODO: Needs confirmation. Was previously undocumented.
  
  This is a filter which is exportable. Returns a sub which pops the data out of the input stream and pushes it onto the string.
  
  =cut
  
  sub new_string_sink {
      my ($string_ref) = @_;
  
      return sub {
          my ( $in_ref, $out_ref ) = @_;
  
          return input_avail && do {
              $$string_ref .= $$in_ref;
              $$in_ref = '';
              1;
            }
      };
  }
  
  #=item timeout
  #
  #This function defines a time interval, starting from when start() is
  #called, or when timeout() is called.  If all processes have not finished
  #by the end of the timeout period, then a "process timed out" exception
  #is thrown.
  #
  #The time interval may be passed in seconds, or as an end time in
  #"HH:MM:SS" format (any non-digit other than '.' may be used as
  #spacing and punctuation).  This is probably best shown by example:
  #
  #   $h->timeout( $val );
  #
  #   $val                     Effect
  #   ======================== =====================================
  #   undef                    Timeout timer disabled
  #   ''                       Almost immediate timeout
  #   0                        Almost immediate timeout
  #   0.000001                 timeout > 0.0000001 seconds
  #   30                       timeout > 30 seconds
  #   30.0000001               timeout > 30 seconds
  #   10:30                    timeout > 10 minutes, 30 seconds
  #
  #Timeouts are currently evaluated with a 1 second resolution, though
  #this may change in the future.  This means that setting
  #timeout($h,1) will cause a pokey child to be aborted sometime after
  #one second has elapsed and typically before two seconds have elapsed.
  #
  #This sub does not check whether or not the timeout has expired already.
  #
  #Returns the number of seconds set as the timeout (this does not change
  #as time passes, unless you call timeout( val ) again).
  #
  #The timeout does not include the time needed to fork() or spawn()
  #the child processes, though some setup time for the child processes can
  #included.  It also does not include the length of time it takes for
  #the children to exit after they've closed all their pipes to the
  #parent process.
  #
  #=cut
  #
  #sub timeout {
  #   my IPC::Run $self = shift;
  #
  #   if ( @_ ) {
  #      ( $self->{TIMEOUT} ) = @_;
  #      $self->{TIMEOUT_END} = undef;
  #      if ( defined $self->{TIMEOUT} ) {
  #	 if ( $self->{TIMEOUT} =~ /[^\d.]/ ) {
  #	    my @f = split( /[^\d\.]+/i, $self->{TIMEOUT} );
  #	    unshift @f, 0 while @f < 3;
  #	    $self->{TIMEOUT} = (($f[0]*60)+$f[1])*60+$f[2];
  #	 }
  #	 elsif ( $self->{TIMEOUT} =~ /^(\d*)(?:\.(\d*))/ ) {
  #	    $self->{TIMEOUT} = $1 + 1;
  #	 }
  #	 $self->_calc_timeout_end if $self->{STATE} >= _started;
  #      }
  #   }
  #   return $self->{TIMEOUT};
  #}
  #
  #
  #sub _calc_timeout_end {
  #   my IPC::Run $self = shift;
  #
  #   $self->{TIMEOUT_END} = defined $self->{TIMEOUT}
  #      ? time + $self->{TIMEOUT}
  #      : undef;
  #
  #   ## We add a second because we might be at the very end of the current
  #   ## second, and we want to guarantee that we don't have a timeout even
  #   ## one second less then the timeout period.
  #   ++$self->{TIMEOUT_END} if $self->{TIMEOUT};
  #}
  
  =pod
  
  =item io
  
  Takes a filename or filehandle, a redirection operator, optional filters,
  and a source or destination (depends on the redirection operator).  Returns
  an IPC::Run::IO object suitable for harness()ing (including via start()
  or run()).
  
  This is shorthand for 
  
  
     require IPC::Run::IO;
  
        ... IPC::Run::IO->new(...) ...
  
  =cut
  
  sub io {
      require IPC::Run::IO;
      IPC::Run::IO->new(@_);
  }
  
  =pod
  
  =item timer
  
     $h = start( \@cmd, \$in, \$out, $t = timer( 5 ) );
  
     pump $h until $out =~ /expected stuff/ || $t->is_expired;
  
  Instantiates a non-fatal timer.  pump() returns once each time a timer
  expires.  Has no direct effect on run(), but you can pass a subroutine
  to fire when the timer expires. 
  
  See L</timeout> for building timers that throw exceptions on
  expiration.
  
  See L<IPC::Run::Timer/timer> for details.
  
  =cut
  
  # Doing the prototype suppresses 'only used once' on older perls.
  sub timer;
  *timer = \&IPC::Run::Timer::timer;
  
  =pod
  
  =item timeout
  
     $h = start( \@cmd, \$in, \$out, $t = timeout( 5 ) );
  
     pump $h until $out =~ /expected stuff/;
  
  Instantiates a timer that throws an exception when it expires.
  If you don't provide an exception, a default exception that matches
  /^IPC::Run: .*timed out/ is thrown by default.  You can pass in your own
  exception scalar or reference:
  
     $h = start(
        \@cmd, \$in, \$out,
        $t = timeout( 5, exception => 'slowpoke' ),
     );
  
  or set the name used in debugging message and in the default exception
  string:
  
     $h = start(
        \@cmd, \$in, \$out,
        timeout( 50, name => 'process timer' ),
        $stall_timer = timeout( 5, name => 'stall timer' ),
     );
  
     pump $h until $out =~ /started/;
  
     $in = 'command 1';
     $stall_timer->start;
     pump $h until $out =~ /command 1 finished/;
  
     $in = 'command 2';
     $stall_timer->start;
     pump $h until $out =~ /command 2 finished/;
  
     $in = 'very slow command 3';
     $stall_timer->start( 10 );
     pump $h until $out =~ /command 3 finished/;
  
     $stall_timer->start( 5 );
     $in = 'command 4';
     pump $h until $out =~ /command 4 finished/;
  
     $stall_timer->reset; # Prevent restarting or expirng
     finish $h;
  
  See L</timer> for building non-fatal timers.
  
  See L<IPC::Run::Timer/timer> for details.
  
  =cut
  
  # Doing the prototype suppresses 'only used once' on older perls.
  sub timeout;
  *timeout = \&IPC::Run::Timer::timeout;
  
  =pod
  
  =back
  
  =head1 FILTER IMPLEMENTATION FUNCTIONS
  
  These functions are for use from within filters.
  
  =over
  
  =item input_avail
  
  Returns TRUE if input is available.  If none is available, then 
  &get_more_input is called and its result is returned.
  
  This is usually used in preference to &get_more_input so that the
  calling filter removes all data from the $in_ref before more data
  gets read in to $in_ref.
  
  C<input_avail> is usually used as part of a return expression:
  
     return input_avail && do {
        ## process the input just gotten
        1;
     };
  
  This technique allows input_avail to return the undef or 0 that a
  filter normally returns when there's no input to process.  If a filter
  stores intermediate values, however, it will need to react to an
  undef:
  
     my $got = input_avail;
     if ( ! defined $got ) {
        ## No more input ever, flush internal buffers to $out_ref
     }
     return $got unless $got;
     ## Got some input, move as much as need be
     return 1 if $added_to_out_ref;
  
  =cut
  
  sub input_avail() {
      confess "Undefined FBUF ref for $filter_num+1"
        unless defined $filter_op->{FBUFS}->[ $filter_num + 1 ];
      length ${ $filter_op->{FBUFS}->[ $filter_num + 1 ] } || get_more_input;
  }
  
  =pod
  
  =item get_more_input
  
  This is used to fetch more input in to the input variable.  It returns
  undef if there will never be any more input, 0 if there is none now,
  but there might be in the future, and TRUE if more input was gotten.
  
  C<get_more_input> is usually used as part of a return expression,
  see L</input_avail> for more information.
  
  =cut
  
  ##
  ## Filter implementation interface
  ##
  sub get_more_input() {
      ++$filter_num;
      my $r = eval {
          confess "get_more_input() called and no more filters in chain"
            unless defined $filter_op->{FILTERS}->[$filter_num];
          $filter_op->{FILTERS}->[$filter_num]->(
              $filter_op->{FBUFS}->[ $filter_num + 1 ],
              $filter_op->{FBUFS}->[$filter_num],
          );    # if defined ${$filter_op->{FBUFS}->[$filter_num+1]};
      };
      --$filter_num;
      die $@ if $@;
      return $r;
  }
  
  1;
  
  =pod
  
  =back
  
  =head1 TODO
  
  These will be addressed as needed and as time allows.
  
  Stall timeout.
  
  Expose a list of child process objects.  When I do this,
  each child process is likely to be blessed into IPC::Run::Proc.
  
  $kid->abort(), $kid->kill(), $kid->signal( $num_or_name ).
  
  Write tests for /(full_)?results?/ subs.
  
  Currently, pump() and run() only work on systems where select() works on the
  filehandles returned by pipe().  This does *not* include ActiveState on Win32,
  although it does work on cygwin under Win32 (thought the tests whine a bit).
  I'd like to rectify that, suggestions and patches welcome.
  
  Likewise start() only fully works on fork()/exec() machines (well, just
  fork() if you only ever pass perl subs as subprocesses).  There's
  some scaffolding for calling Open3::spawn_with_handles(), but that's
  untested, and not that useful with limited select().
  
  Support for C<\@sub_cmd> as an argument to a command which
  gets replaced with /dev/fd or the name of a temporary file containing foo's
  output.  This is like <(sub_cmd ...) found in bash and csh (IIRC).
  
  Allow multiple harnesses to be combined as independent sets of processes
  in to one 'meta-harness'.
  
  Allow a harness to be passed in place of an \@cmd.  This would allow
  multiple harnesses to be aggregated.
  
  Ability to add external file descriptors w/ filter chains and endpoints.
  
  Ability to add timeouts and timing generators (i.e. repeating timeouts).
  
  High resolution timeouts.
  
  =head1 Win32 LIMITATIONS
  
  =over
  
  =item argument-passing rules are program-specific
  
  Win32 programs receive all arguments in a single "command line" string.
  IPC::Run assembles this string so programs using L<standard command line parsing
  rules|https://docs.microsoft.com/en-us/cpp/cpp/main-function-command-line-args#parsing-c-command-line-arguments>
  will see an C<argv> that matches the array reference specifying the command.
  Some programs use different rules to parse their command line.  Notable examples
  include F<cmd.exe>, F<cscript.exe>, and Cygwin programs called from non-Cygwin
  programs.  Use L<IPC::Run::Win32Process> to call these and other nonstandard
  programs.
  
  =item batch files
  
  Properly escaping a batch file argument depends on how the script will use that
  argument, because some uses experience multiple levels of caret (escape
  character) removal.  Avoid calling batch files with arguments, particularly when
  the argument values originate outside your program or contain non-alphanumeric
  characters.  Perl scripts and PowerShell scripts are sound alternatives.  If you
  do use batch file arguments, IPC::Run escapes them so the batch file can pass
  them, unquoted, to a program having standard command line parsing rules.  If the
  batch file enables delayed environment variable expansion, it must disable that
  feature before expanding its arguments.  For example, if F<foo.cmd> contains
  C<perl %*>, C<run ['foo.cmd', @list]> will create a Perl process in which
  C<@ARGV> matches C<@list>.  Prepending a C<setlocal enabledelayedexpansion> line
  would make the batch file malfunction, silently.  Another silent-malfunction
  example is C<run ['outer.bat', @list]> for F<outer.bat> containing C<foo.cmd
  %*>.
  
  =item Fails on Win9X
  
  If you want Win9X support, you'll have to debug it or fund me because I
  don't use that system any more.  The Win32 subsysem has been extended to
  use temporary files in simple run() invocations and these may actually
  work on Win9X too, but I don't have time to work on it.
  
  =item May deadlock on Win2K (but not WinNT4 or WinXPPro)
  
  Spawning more than one subprocess on Win2K causes a deadlock I haven't
  figured out yet, but simple uses of run() often work.  Passes all tests
  on WinXPPro and WinNT.
  
  =item no support yet for <pty< and >pty>
  
  These are likely to be implemented as "<" and ">" with binmode on, not
  sure.
  
  =item no support for file descriptors higher than 2 (stderr)
  
  Win32 only allows passing explicit fds 0, 1, and 2.  If you really, really need to pass file handles, us Win32API:: GetOsFHandle() or ::FdGetOsFHandle() to
  get the integer handle and pass it to the child process using the command
  line, environment, stdin, intermediary file, or other IPC mechanism.  Then
  use that handle in the child (Win32API.pm provides ways to reconstitute
  Perl file handles from Win32 file handles).
  
  =item no support for subroutine subprocesses (CODE refs)
  
  Can't fork(), so the subroutines would have no context, and closures certainly
  have no meaning
  
  Perhaps with Win32 fork() emulation, this can be supported in a limited
  fashion, but there are other very serious problems with that: all parent
  fds get dup()ed in to the thread emulating the forked process, and that
  keeps the parent from being able to close all of the appropriate fds.
  
  =item no support for init => sub {} routines.
  
  Win32 processes are created from scratch, there is no way to do an init
  routine that will affect the running child.  Some limited support might
  be implemented one day, do chdir() and %ENV changes can be made.
  
  =item signals
  
  Win32 does not fully support signals.  signal() is likely to cause errors
  unless sending a signal that Perl emulates, and C<kill_kill()> is immediately
  fatal (there is no grace period).
  
  =item helper processes
  
  IPC::Run uses helper processes, one per redirected file, to adapt between the
  anonymous pipe connected to the child and the TCP socket connected to the
  parent.  This is a waste of resources and will change in the future to either
  use threads (instead of helper processes) or a WaitForMultipleObjects call
  (instead of select).  Please contact me if you can help with the
  WaitForMultipleObjects() approach; I haven't figured out how to get at it
  without C code.
  
  =item shutdown pause
  
  There seems to be a pause of up to 1 second between when a child program exits
  and the corresponding sockets indicate that they are closed in the parent.
  Not sure why.
  
  =item binmode
  
  binmode is not supported yet.  The underpinnings are implemented, just ask
  if you need it.
  
  =item IPC::Run::IO
  
  IPC::Run::IO objects can be used on Unix to read or write arbitrary files.  On
  Win32, they will need to use the same helper processes to adapt from
  non-select()able filehandles to select()able ones (or perhaps
  WaitForMultipleObjects() will work with them, not sure).
  
  =item startup race conditions
  
  There seems to be an occasional race condition between child process startup
  and pipe closings.  It seems like if the child is not fully created by the time
  CreateProcess returns and we close the TCP socket being handed to it, the
  parent socket can also get closed.  This is seen with the Win32 pumper
  applications, not the "real" child process being spawned.
  
  I assume this is because the kernel hasn't gotten around to incrementing the
  reference count on the child's end (since the child was slow in starting), so
  the parent's closing of the child end causes the socket to be closed, thus
  closing the parent socket.
  
  Being a race condition, it's hard to reproduce, but I encountered it while
  testing this code on a drive share to a samba box.  In this case, it takes
  t/run.t a long time to spawn it's child processes (the parent hangs in the
  first select for several seconds until the child emits any debugging output).
  
  I have not seen it on local drives, and can't reproduce it at will,
  unfortunately.  The symptom is a "bad file descriptor in select()" error, and,
  by turning on debugging, it's possible to see that select() is being called on
  a no longer open file descriptor that was returned from the _socket() routine
  in Win32Helper.  There's a new confess() that checks for this ("PARENT_HANDLE
  no longer open"), but I haven't been able to reproduce it (typically).
  
  =back
  
  =head1 LIMITATIONS
  
  On Unix, requires a system that supports C<waitpid( $pid, WNOHANG )> so
  it can tell if a child process is still running.
  
  PTYs don't seem to be non-blocking on some versions of Solaris. Here's a
  test script contributed by Borislav Deianov <borislav@ensim.com> to see
  if you have the problem.  If it dies, you have the problem.
  
     #!/usr/bin/perl
  
     use IPC::Run qw(run);
     use Fcntl;
     use IO::Pty;
  
     sub makecmd {
         return ['perl', '-e', 
                 '<STDIN>, print "\n" x '.$_[0].'; while(<STDIN>){last if /end/}'];
     }
  
     #pipe R, W;
     #fcntl(W, F_SETFL, O_NONBLOCK);
     #while (syswrite(W, "\n", 1)) { $pipebuf++ };
     #print "pipe buffer size is $pipebuf\n";
     my $pipebuf=4096;
     my $in = "\n" x ($pipebuf * 2) . "end\n";
     my $out;
  
     $SIG{ALRM} = sub { die "Never completed!\n" };
  
     print "reading from scalar via pipe...";
     alarm( 2 );
     run(makecmd($pipebuf * 2), '<', \$in, '>', \$out);
     alarm( 0 );
     print "done\n";
  
     print "reading from code via pipe... ";
     alarm( 2 );
     run(makecmd($pipebuf * 3), '<', sub { $t = $in; undef $in; $t}, '>', \$out);
     alarm( 0 );
     print "done\n";
  
     $pty = IO::Pty->new();
     $pty->blocking(0);
     $slave = $pty->slave();
     while ($pty->syswrite("\n", 1)) { $ptybuf++ };
     print "pty buffer size is $ptybuf\n";
     $in = "\n" x ($ptybuf * 3) . "end\n";
  
     print "reading via pty... ";
     alarm( 2 );
     run(makecmd($ptybuf * 3), '<pty<', \$in, '>', \$out);
     alarm(0);
     print "done\n";
  
  No support for ';', '&&', '||', '{ ... }', etc: use perl's, since run()
  returns TRUE when the command exits with a 0 result code.
  
  Does not provide shell-like string interpolation.
  
  No support for C<cd>, C<setenv>, or C<export>: do these in an init() sub
  
     run(
        \cmd,
           ...
           init => sub {
              chdir $dir or die $!;
              $ENV{FOO}='BAR'
           }
     );
  
  Timeout calculation does not allow absolute times, or specification of
  days, months, etc.
  
  B<WARNING:> Function coprocesses (C<run \&foo, ...>) suffer from two
  limitations.  The first is that it is difficult to close all filehandles the
  child inherits from the parent, since there is no way to scan all open
  FILEHANDLEs in Perl and it both painful and a bit dangerous to close all open
  file descriptors with C<POSIX::close()>. Painful because we can't tell which
  fds are open at the POSIX level, either, so we'd have to scan all possible fds
  and close any that we don't want open (normally C<exec()> closes any
  non-inheritable but we don't C<exec()> for &sub processes.
  
  The second problem is that Perl's DESTROY subs and other on-exit cleanup gets
  run in the child process.  If objects are instantiated in the parent before the
  child is forked, the DESTROY will get run once in the parent and once in
  the child.  When coprocess subs exit, POSIX::_exit is called to work around this,
  but it means that objects that are still referred to at that time are not
  cleaned up.  So setting package vars or closure vars to point to objects that
  rely on DESTROY to affect things outside the process (files, etc), will
  lead to bugs.
  
  I goofed on the syntax: "<pipe" vs. "<pty<" and ">filename" are both
  oddities.
  
  =head1 TODO
  
  =over
  
  =item Allow one harness to "adopt" another:
  
     $new_h = harness \@cmd2;
     $h->adopt( $new_h );
  
  =item Close all filehandles not explicitly marked to stay open.
  
  The problem with this one is that there's no good way to scan all open
  FILEHANDLEs in Perl, yet you don't want child processes inheriting handles
  willy-nilly.
  
  =back
  
  =head1 INSPIRATION
  
  Well, select() and waitpid() badly needed wrapping, and open3() isn't
  open-minded enough for me.
  
  The shell-like API inspired by a message Russ Allbery sent to perl5-porters,
  which included:
  
     I've thought for some time that it would be
     nice to have a module that could handle full Bourne shell pipe syntax
     internally, with fork and exec, without ever invoking a shell.  Something
     that you could give things like:
  
     pipeopen (PIPE, [ qw/cat file/ ], '|', [ 'analyze', @args ], '>&3');
  
  Message ylln51p2b6.fsf@windlord.stanford.edu, on 2000/02/04.
  
  =head1 SUPPORT
  
  Bugs should always be submitted via the GitHub bug tracker
  
  L<https://github.com/toddr/IPC-Run/issues>
  
  =head1 AUTHORS
  
  Adam Kennedy <adamk@cpan.org>
  
  Barrie Slaymaker <barries@slaysys.com>
  
  =head1 COPYRIGHT
  
  Some parts copyright 2008 - 2009 Adam Kennedy.
  
  Copyright 1999 Barrie Slaymaker.
  
  You may distribute under the terms of either the GNU General Public
  License or the Artistic License, as specified in the README file.
  
  =cut
IPC_RUN

$fatpacked{"IPC/Run/Debug.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN_DEBUG';
  package IPC::Run::Debug;
  
  =pod
  
  =head1 NAME
  
  IPC::Run::Debug - debugging routines for IPC::Run
  
  =head1 SYNOPSIS
  
     ##
     ## Environment variable usage
     ##
     ## To force debugging off and shave a bit of CPU and memory
     ## by compile-time optimizing away all debugging code in IPC::Run
     ## (debug => ...) options to IPC::Run will be ignored.
     export IPCRUNDEBUG=none
  
     ## To force debugging on (levels are from 0..10)
     export IPCRUNDEBUG=basic
  
     ## Leave unset or set to "" to compile in debugging support and
     ## allow runtime control of it using the debug option.
  
  =head1 DESCRIPTION
  
  Controls IPC::Run debugging.  Debugging levels are now set by using words,
  but the numbers shown are still supported for backwards compatibility:
  
     0  none         disabled (special, see below)
     1  basic        what's running
     2  data         what's being sent/received
     3  details      what's going on in more detail
     4  gory         way too much detail for most uses
     10 all          use this when submitting bug reports
        noopts       optimizations forbidden due to inherited STDIN
  
  The C<none> level is special when the environment variable IPCRUNDEBUG
  is set to this the first time IPC::Run::Debug is loaded: it prevents
  the debugging code from being compiled in to the remaining IPC::Run modules,
  saving a bit of cpu.
  
  To do this in a script, here's a way that allows it to be overridden:
  
     BEGIN {
        unless ( defined $ENV{IPCRUNDEBUG} ) {
  	 eval 'local $ENV{IPCRUNDEBUG} = "none"; require IPC::Run::Debug"'
  	    or die $@;
        }
     }
  
  This should force IPC::Run to not be debuggable unless somebody sets
  the IPCRUNDEBUG flag; modify this formula to grep @ARGV if need be:
  
     BEGIN {
        unless ( grep /^--debug/, @ARGV ) {
  	 eval 'local $ENV{IPCRUNDEBUG} = "none"; require IPC::Run::Debug"'
  	 or die $@;
     }
  
  Both of those are untested.
  
  =cut
  
  ## We use @EXPORT for the end user's convenience: there's only one function
  ## exported, it's homonymous with the module, it's an unusual name, and
  ## it can be suppressed by "use IPC::Run ();".
  
  use strict;
  use warnings;
  use Exporter;
  use vars qw{$VERSION @ISA @EXPORT @EXPORT_OK %EXPORT_TAGS};
  
  BEGIN {
      $VERSION = '20220807.0';
      @ISA     = qw( Exporter );
      @EXPORT  = qw(
        _debug
        _debug_desc_fd
        _debugging
        _debugging_data
        _debugging_details
        _debugging_gory_details
        _debugging_not_optimized
        _set_child_debug_name
      );
  
      @EXPORT_OK = qw(
        _debug_init
        _debugging_level
        _map_fds
      );
      %EXPORT_TAGS = (
          default => \@EXPORT,
          all => [ @EXPORT, @EXPORT_OK ],
      );
  }
  
  my $disable_debugging = defined $ENV{IPCRUNDEBUG}
    && ( !$ENV{IPCRUNDEBUG}
      || lc $ENV{IPCRUNDEBUG} eq "none" );
  
  eval( $disable_debugging ? <<'STUBS' : <<'SUBS' ) or die $@;
  sub _map_fds()                 { "" }
  sub _debug                     {}
  sub _debug_desc_fd             {}
  sub _debug_init                {}
  sub _set_child_debug_name      {}
  sub _debugging()               { 0 }
  sub _debugging_level()         { 0 }
  sub _debugging_data()          { 0 }
  sub _debugging_details()       { 0 }
  sub _debugging_gory_details()  { 0 }
  sub _debugging_not_optimized() { 0 }
  
  1;
  STUBS
  
  use POSIX ();
  
  sub _map_fds {
     my $map = '';
     my $digit = 0;
     my $in_use;
     my $dummy;
     for my $fd (0..63) {
        ## I'd like a quicker way (less user, cpu & especially sys and kernel
        ## calls) to detect open file descriptors.  Let me know...
        ## Hmmm, could do a 0 length read and check for bad file descriptor...
        ## but that segfaults on Win32
        my $test_fd = POSIX::dup( $fd );
        $in_use = defined $test_fd;
        POSIX::close $test_fd if $in_use;
        $map .= $in_use ? $digit : '-';
        $digit = 0 if ++$digit > 9;
     }
     warn "No fds open???" unless $map =~ /\d/;
     $map =~ s/(.{1,12})-*$/$1/;
     return $map;
  }
  
  use vars qw( $parent_pid );
  
  $parent_pid = $$;
  
  ## TODO: move debugging to its own module and make it compile-time
  ## optimizable.
  
  ## Give kid process debugging nice names
  my $debug_name;
  
  sub _set_child_debug_name {
     $debug_name = shift;
  }
  
  ## There's a bit of hackery going on here.
  ##
  ## We want to have any code anywhere be able to emit
  ## debugging statements without knowing what harness the code is
  ## being called in/from, since we'd need to pass a harness around to
  ## everything.
  ##
  ## Thus, $cur_self was born.
  #
  my %debug_levels = (
     none    => 0,
     basic   => 1,
     data    => 2,
     details => 3,
     gore           => 4,
     gory_details   => 4,
     "gory details" => 4,
     gory           => 4,
     gorydetails    => 4,
     all     => 10,
     notopt  => 0,
  );
  
  my $warned;
  
  sub _debugging_level() {
     my $level = 0;
  
     $level = $IPC::Run::cur_self->{debug} || 0
        if $IPC::Run::cur_self
           && ( $IPC::Run::cur_self->{debug} || 0 ) >= $level;
  
     if ( defined $ENV{IPCRUNDEBUG} ) {
        my $v = $ENV{IPCRUNDEBUG};
        $v = $debug_levels{lc $v} if $v =~ /[a-zA-Z]/;
        unless ( defined $v ) {
  	 $warned ||= warn "Unknown debug level $ENV{IPCRUNDEBUG}, assuming 'basic' (1)\n";
  	 $v = 1;
        }
        $level = $v if $v > $level;
     }
     return $level;
  }
  
  sub _debugging_atleast($) {
     my $min_level = shift || 1;
  
     my $level = _debugging_level;
     
     return $level >= $min_level ? $level : 0;
  }
  
  sub _debugging()               { _debugging_atleast 1 }
  sub _debugging_data()          { _debugging_atleast 2 }
  sub _debugging_details()       { _debugging_atleast 3 }
  sub _debugging_gory_details()  { _debugging_atleast 4 }
  sub _debugging_not_optimized() { ( $ENV{IPCRUNDEBUG} || "" ) eq "notopt" }
  
  sub _debug_init {
     ## This routine is called only in spawned children to fake out the
     ## debug routines so they'll emit debugging info.
     $IPC::Run::cur_self = {};
     (  $parent_pid,
        $^T, 
        $IPC::Run::cur_self->{debug}, 
        $IPC::Run::cur_self->{DEBUG_FD}, 
        $debug_name 
     ) = @_;
  }
  
  
  sub _debug {
  #   return unless _debugging || _debugging_not_optimized;
  
     my $fd = defined &IPC::Run::_debug_fd
        ? IPC::Run::_debug_fd()
        : fileno STDERR;
  
     my $s;
     my $debug_id;
     $debug_id = join( 
        " ",
        join(
           "",
           defined $IPC::Run::cur_self && defined $IPC::Run::cur_self->{ID}
           ? "#$IPC::Run::cur_self->{ID}"
           : (),
           "($$)",
        ),
        defined $debug_name && length $debug_name ? $debug_name        : (),
     );
     my $prefix = join(
        "",
        "IPC::Run",
        sprintf( " %04d", time - $^T ),
        ( _debugging_details ? ( " ", _map_fds ) : () ),
        length $debug_id ? ( " [", $debug_id, "]" ) : (),
        ": ",
     );
  
     my $msg = join( '', map defined $_ ? $_ : "<undef>", @_ );
     chomp $msg;
     $msg =~ s{^}{$prefix}gm;
     $msg .= "\n";
     POSIX::write( $fd, $msg, length $msg );
  }
  
  
  my @fd_descs = ( 'stdin', 'stdout', 'stderr' );
  
  sub _debug_desc_fd {
     return unless _debugging;
     my $text = shift;
     my $op = pop;
     my $kid = $_[0];
  
  Carp::carp join " ", caller(0), $text, $op  if defined $op  && UNIVERSAL::isa( $op, "IO::Pty" );
  
     _debug(
        $text,
        ' ',
        ( defined $op->{FD}
           ? $op->{FD} < 3
              ? ( $fd_descs[$op->{FD}] )
              : ( 'fd ', $op->{FD} )
           : $op->{FD}
        ),
        ( defined $op->{KFD}
           ? (
              ' (kid',
              ( defined $kid ? ( ' ', $kid->{NUM}, ) : () ),
              "'s ",
              ( $op->{KFD} < 3
                 ? $fd_descs[$op->{KFD}]
                 : defined $kid
                    && defined $kid->{DEBUG_FD}
                    && $op->{KFD} == $kid->{DEBUG_FD}
                    ? ( 'debug (', $op->{KFD}, ')' )
                    : ( 'fd ', $op->{KFD} )
              ),
              ')',
           )
           : ()
        ),
     );
  }
  
  1;
  
  SUBS
  
  =pod
  
  =head1 AUTHOR
  
  Barrie Slaymaker <barries@slaysys.com>, with numerous suggestions by p5p.
  
  =cut
IPC_RUN_DEBUG

$fatpacked{"IPC/Run/IO.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN_IO';
  package IPC::Run::IO;
  
  =head1 NAME
  
  IPC::Run::IO -- I/O channels for IPC::Run.
  
  =head1 SYNOPSIS
  
  B<NOT IMPLEMENTED YET ON Win32! Win32 does not allow select() on
  normal file descriptors; IPC::RUN::IO needs to use IPC::Run::Win32Helper
  to do this.>
  
     use IPC::Run qw( io );
  
     ## The sense of '>' and '<' is opposite of perl's open(),
     ## but agrees with IPC::Run.
     $io = io( "filename", '>',  \$recv );
     $io = io( "filename", 'r',  \$recv );
  
     ## Append to $recv:
     $io = io( "filename", '>>', \$recv );
     $io = io( "filename", 'ra', \$recv );
  
     $io = io( "filename", '<',  \$send );
     $io = io( "filename", 'w',  \$send );
  
     $io = io( "filename", '<<', \$send );
     $io = io( "filename", 'wa', \$send );
  
     ## Handles / IO objects that the caller opens:
     $io = io( \*HANDLE,   '<',  \$send );
  
     $f = IO::Handle->new( ... ); # Any subclass of IO::Handle
     $io = io( $f, '<', \$send );
  
     require IPC::Run::IO;
     $io = IPC::Run::IO->new( ... );
  
     ## Then run(), harness(), or start():
     run $io, ...;
  
     ## You can, of course, use io() or IPC::Run::IO->new() as an
     ## argument to run(), harness, or start():
     run io( ... );
  
  =head1 DESCRIPTION
  
  This class and module allows filehandles and filenames to be harnessed for
  I/O when used IPC::Run, independent of anything else IPC::Run is doing
  (except that errors & exceptions can affect all things that IPC::Run is
  doing).
  
  =head1 SUBCLASSING
  
  INCOMPATIBLE CHANGE: due to the awkwardness introduced in ripping pseudohashes
  out of Perl, this class I<no longer> uses the fields pragma.
  
  =cut
  
  ## This class is also used internally by IPC::Run in a very intimate way,
  ## since this is a partial factoring of code from IPC::Run plus some code
  ## needed to do standalone channels.  This factoring process will continue
  ## at some point.  Don't know how far how fast.
  
  use strict;
  use warnings;
  use Carp;
  use Fcntl;
  use Symbol;
  
  use IPC::Run::Debug;
  use IPC::Run qw( Win32_MODE );
  
  use vars qw{$VERSION};
  
  BEGIN {
      $VERSION = '20220807.0';
      if (Win32_MODE) {
          eval "use IPC::Run::Win32Helper; require IPC::Run::Win32IO; 1"
            or ( $@ && die )
            or die "$!";
      }
  }
  
  sub _empty($);
  *_empty = \&IPC::Run::_empty;
  
  =head1 SUBROUTINES
  
  =over 4
  
  =item new
  
  I think it takes >> or << along with some other data.
  
  TODO: Needs more thorough documentation. Patches welcome.
  
  =cut
  
  sub new {
      my $class = shift;
      $class = ref $class || $class;
  
      my ( $external, $type, $internal ) = ( shift, shift, pop );
  
      croak "$class: '$_' is not a valid I/O operator"
        unless $type =~ /^(?:<<?|>>?)$/;
  
      my IPC::Run::IO $self = $class->_new_internal( $type, undef, undef, $internal, undef, @_ );
  
      if ( !ref $external ) {
          $self->{FILENAME} = $external;
      }
      elsif ( ref $external eq 'GLOB' || UNIVERSAL::isa( $external, 'IO::Handle' ) ) {
          $self->{HANDLE}     = $external;
          $self->{DONT_CLOSE} = 1;
      }
      else {
          croak "$class: cannot accept " . ref($external) . " to do I/O with";
      }
  
      return $self;
  }
  
  ## IPC::Run uses this ctor, since it preparses things and needs more
  ## smarts.
  sub _new_internal {
      my $class = shift;
      $class = ref $class || $class;
  
      $class = "IPC::Run::Win32IO"
        if Win32_MODE && $class eq "IPC::Run::IO";
  
      my IPC::Run::IO $self;
      $self = bless {}, $class;
  
      my ( $type, $kfd, $pty_id, $internal, $binmode, @filters ) = @_;
  
      # Older perls (<=5.00503, at least) don't do list assign to
      # psuedo-hashes well.
      $self->{TYPE}   = $type;
      $self->{KFD}    = $kfd;
      $self->{PTY_ID} = $pty_id;
      $self->binmode($binmode);
      $self->{FILTERS} = [@filters];
  
      ## Add an adapter to the end of the filter chain (which is usually just the
      ## read/writer sub pushed by IPC::Run) to the DEST or SOURCE, if need be.
      if ( $self->op =~ />/ ) {
          croak "'$_' missing a destination" if _empty $internal;
          $self->{DEST} = $internal;
          if ( UNIVERSAL::isa( $self->{DEST}, 'CODE' ) ) {
              ## Put a filter on the end of the filter chain to pass the
              ## output on to the CODE ref.  For SCALAR refs, the last
              ## filter in the chain writes directly to the scalar itself.  See
              ## _init_filters().  For CODE refs, however, we need to adapt from
              ## the SCALAR to calling the CODE.
              unshift(
                  @{ $self->{FILTERS} },
                  sub {
                      my ($in_ref) = @_;
  
                      return IPC::Run::input_avail() && do {
                          $self->{DEST}->($$in_ref);
                          $$in_ref = '';
                          1;
                        }
                  }
              );
          }
      }
      else {
          croak "'$_' missing a source" if _empty $internal;
          $self->{SOURCE} = $internal;
          if ( UNIVERSAL::isa( $internal, 'CODE' ) ) {
              push(
                  @{ $self->{FILTERS} },
                  sub {
                      my ( $in_ref, $out_ref ) = @_;
                      return 0 if length $$out_ref;
  
                      return undef
                        if $self->{SOURCE_EMPTY};
  
                      my $in = $internal->();
                      unless ( defined $in ) {
                          $self->{SOURCE_EMPTY} = 1;
                          return undef;
                      }
                      return 0 unless length $in;
                      $$out_ref = $in;
  
                      return 1;
                  }
              );
          }
          elsif ( UNIVERSAL::isa( $internal, 'SCALAR' ) ) {
              push(
                  @{ $self->{FILTERS} },
                  sub {
                      my ( $in_ref, $out_ref ) = @_;
                      return 0 if length $$out_ref;
  
                      ## pump() clears auto_close_ins, finish() sets it.
                      return $self->{HARNESS}->{auto_close_ins} ? undef : 0
                        if IPC::Run::_empty ${ $self->{SOURCE} }
                        || $self->{SOURCE_EMPTY};
  
                      $$out_ref = $$internal;
                      eval { $$internal = '' }
                        if $self->{HARNESS}->{clear_ins};
  
                      $self->{SOURCE_EMPTY} = $self->{HARNESS}->{auto_close_ins};
  
                      return 1;
                  }
              );
          }
      }
  
      return $self;
  }
  
  =item filename
  
  Gets/sets the filename.  Returns the value after the name change, if
  any.
  
  =cut
  
  sub filename {
      my IPC::Run::IO $self = shift;
      $self->{FILENAME} = shift if @_;
      return $self->{FILENAME};
  }
  
  =item init
  
  Does initialization required before this can be run.  This includes open()ing
  the file, if necessary, and clearing the destination scalar if necessary.
  
  =cut
  
  sub init {
      my IPC::Run::IO $self = shift;
  
      $self->{SOURCE_EMPTY} = 0;
      ${ $self->{DEST} } = ''
        if $self->mode =~ /r/ && ref $self->{DEST} eq 'SCALAR';
  
      $self->open if defined $self->filename;
      $self->{FD} = $self->fileno;
  
      if ( !$self->{FILTERS} ) {
          $self->{FBUFS} = undef;
      }
      else {
          @{ $self->{FBUFS} } = map {
              my $s = "";
              \$s;
          } ( @{ $self->{FILTERS} }, '' );
  
          $self->{FBUFS}->[0] = $self->{DEST}
            if $self->{DEST} && ref $self->{DEST} eq 'SCALAR';
          push @{ $self->{FBUFS} }, $self->{SOURCE};
      }
  
      return undef;
  }
  
  =item open
  
  If a filename was passed in, opens it.  Determines if the handle is open
  via fileno().  Throws an exception on error.
  
  =cut
  
  my %open_flags = (
      '>'  => O_RDONLY,
      '>>' => O_RDONLY,
      '<'  => O_WRONLY | O_CREAT | O_TRUNC,
      '<<' => O_WRONLY | O_CREAT | O_APPEND,
  );
  
  sub open {
      my IPC::Run::IO $self = shift;
  
      croak "IPC::Run::IO: Can't open() a file with no name"
        unless defined $self->{FILENAME};
      $self->{HANDLE} = gensym unless $self->{HANDLE};
  
      _debug "opening '", $self->filename, "' mode '", $self->mode, "'"
        if _debugging_data;
      sysopen(
          $self->{HANDLE},
          $self->filename,
          $open_flags{ $self->op },
      ) or croak "IPC::Run::IO: $! opening '$self->{FILENAME}', mode '" . $self->mode . "'";
  
      return undef;
  }
  
  =item open_pipe
  
  If this is a redirection IO object, this opens the pipe in a platform
  independent manner.
  
  =cut
  
  sub _do_open {
      my $self = shift;
      my ( $child_debug_fd, $parent_handle ) = @_;
  
      if ( $self->dir eq "<" ) {
          ( $self->{TFD}, $self->{FD} ) = IPC::Run::_pipe_nb;
          if ($parent_handle) {
              CORE::open $parent_handle, ">&=$self->{FD}"
                or croak "$! duping write end of pipe for caller";
          }
      }
      else {
          ( $self->{FD}, $self->{TFD} ) = IPC::Run::_pipe;
          if ($parent_handle) {
              CORE::open $parent_handle, "<&=$self->{FD}"
                or croak "$! duping read end of pipe for caller";
          }
      }
  }
  
  sub open_pipe {
      my IPC::Run::IO $self = shift;
  
      ## Hmmm, Maybe allow named pipes one day.  But until then...
      croak "IPC::Run::IO: Can't pipe() when a file name has been set"
        if defined $self->{FILENAME};
  
      $self->_do_open(@_);
  
      ## return ( child_fd, parent_fd )
      return $self->dir eq "<"
        ? ( $self->{TFD}, $self->{FD} )
        : ( $self->{FD}, $self->{TFD} );
  }
  
  sub _cleanup {    ## Called from Run.pm's _cleanup
      my $self = shift;
      undef $self->{FAKE_PIPE};
  }
  
  =item close
  
  Closes the handle.  Throws an exception on failure.
  
  
  =cut
  
  sub close {
      my IPC::Run::IO $self = shift;
  
      if ( defined $self->{HANDLE} ) {
          close $self->{HANDLE}
            or croak(
              "IPC::Run::IO: $! closing "
                . (
                  defined $self->{FILENAME}
                  ? "'$self->{FILENAME}'"
                  : "handle"
                )
            );
      }
      else {
          IPC::Run::_close( $self->{FD} );
      }
  
      $self->{FD} = undef;
  
      return undef;
  }
  
  =item fileno
  
  Returns the fileno of the handle.  Throws an exception on failure.
  
  
  =cut
  
  sub fileno {
      my IPC::Run::IO $self = shift;
  
      my $fd = fileno $self->{HANDLE};
      croak(
          "IPC::Run::IO: $! "
            . (
              defined $self->{FILENAME}
              ? "'$self->{FILENAME}'"
              : "handle"
            )
      ) unless defined $fd;
  
      return $fd;
  }
  
  =item mode
  
  Returns the operator in terms of 'r', 'w', and 'a'.  There is a state
  'ra', unlike Perl's open(), which indicates that data read from the
  handle or file will be appended to the output if the output is a scalar.
  This is only meaningful if the output is a scalar, it has no effect if
  the output is a subroutine.
  
  The redirection operators can be a little confusing, so here's a reference
  table:
  
     >      r      Read from handle in to process
     <      w      Write from process out to handle
     >>     ra     Read from handle in to process, appending it to existing
                   data if the destination is a scalar.
     <<     wa     Write from process out to handle, appending to existing
                   data if IPC::Run::IO opened a named file.
  
  =cut
  
  sub mode {
      my IPC::Run::IO $self = shift;
  
      croak "IPC::Run::IO: unexpected arguments for mode(): @_" if @_;
  
      ## TODO: Optimize this
      return ( $self->{TYPE} =~ /</ ? 'w' : 'r' ) . ( $self->{TYPE} =~ /<<|>>/ ? 'a' : '' );
  }
  
  =item op
  
  Returns the operation: '<', '>', '<<', '>>'.  See L</mode> if you want
  to spell these 'r', 'w', etc.
  
  =cut
  
  sub op {
      my IPC::Run::IO $self = shift;
  
      croak "IPC::Run::IO: unexpected arguments for op(): @_" if @_;
  
      return $self->{TYPE};
  }
  
  =item binmode
  
  Sets/gets whether this pipe is in binmode or not.  No effect off of Win32
  OSs, of course, and on Win32, no effect after the harness is start()ed.
  
  =cut
  
  sub binmode {
      my IPC::Run::IO $self = shift;
  
      $self->{BINMODE} = shift if @_;
  
      return $self->{BINMODE};
  }
  
  =item dir
  
  Returns the first character of $self->op.  This is either "<" or ">".
  
  =cut
  
  sub dir {
      my IPC::Run::IO $self = shift;
  
      croak "IPC::Run::IO: unexpected arguments for dir(): @_" if @_;
  
      return substr $self->{TYPE}, 0, 1;
  }
  
  ##
  ## Filter Scaffolding
  ##
  #my $filter_op ;        ## The op running a filter chain right now
  #my $filter_num;        ## Which filter is being run right now.
  
  use vars (
      '$filter_op',    ## The op running a filter chain right now
      '$filter_num'    ## Which filter is being run right now.
  );
  
  sub _init_filters {
      my IPC::Run::IO $self = shift;
  
      confess "\$self not an IPC::Run::IO" unless UNIVERSAL::isa( $self, "IPC::Run::IO" );
      $self->{FBUFS} = [];
  
      $self->{FBUFS}->[0] = $self->{DEST}
        if $self->{DEST} && ref $self->{DEST} eq 'SCALAR';
  
      return unless $self->{FILTERS} && @{ $self->{FILTERS} };
  
      push @{ $self->{FBUFS} }, map {
          my $s = "";
          \$s;
      } ( @{ $self->{FILTERS} }, '' );
  
      push @{ $self->{FBUFS} }, $self->{SOURCE};
  }
  
  =item poll
  
  TODO: Needs confirmation that this is correct. Was previously undocumented.
  
  I believe this is polling the IO for new input and then returns undef if there will never be any more input, 0 if there is none now, but there might be in the future, and TRUE if more input was gotten.
  
  =cut
  
  sub poll {
      my IPC::Run::IO $self = shift;
      my ($harness) = @_;
  
      if ( defined $self->{FD} ) {
          my $d = $self->dir;
          if ( $d eq "<" ) {
              if ( vec $harness->{WOUT}, $self->{FD}, 1 ) {
                  _debug_desc_fd( "filtering data to", $self )
                    if _debugging_details;
                  return $self->_do_filters($harness);
              }
          }
          elsif ( $d eq ">" ) {
              if ( vec $harness->{ROUT}, $self->{FD}, 1 ) {
                  _debug_desc_fd( "filtering data from", $self )
                    if _debugging_details;
                  return $self->_do_filters($harness);
              }
          }
      }
      return 0;
  }
  
  sub _do_filters {
      my IPC::Run::IO $self = shift;
  
      ( $self->{HARNESS} ) = @_;
  
      my ( $saved_op, $saved_num ) = ( $IPC::Run::filter_op, $IPC::Run::filter_num );
      $IPC::Run::filter_op  = $self;
      $IPC::Run::filter_num = -1;
      my $redos = 0;
      my $r;
      {
          $@ = '';
          $r = eval { IPC::Run::get_more_input(); };
  
          # Detect Resource temporarily unavailable and re-try 200 times (2 seconds),  assuming select behaves (which it doesn't always? need ref)
          if ( ( $@ || '' ) =~ $IPC::Run::_EAGAIN && $redos++ < 200 ) {
              select( undef, undef, undef, 0.01 );
              redo;
          }
      }
      ( $IPC::Run::filter_op, $IPC::Run::filter_num ) = ( $saved_op, $saved_num );
      $self->{HARNESS} = undef;
      die "ack ", $@ if $@;
      return $r;
  }
  
  =back
  
  =head1 AUTHOR
  
  Barrie Slaymaker <barries@slaysys.com>
  
  =head1 TODO
  
  Implement bidirectionality.
  
  =cut
  
  1;
IPC_RUN_IO

$fatpacked{"IPC/Run/Timer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN_TIMER';
  package IPC::Run::Timer;
  
  =pod
  
  =head1 NAME
  
  IPC::Run::Timer -- Timer channels for IPC::Run.
  
  =head1 SYNOPSIS
  
     use IPC::Run qw( run  timer timeout );
     ## or IPC::Run::Timer ( timer timeout );
     ## or IPC::Run::Timer ( :all );
  
     ## A non-fatal timer:
     $t = timer( 5 ); # or...
     $t = IO::Run::Timer->new( 5 );
     run $t, ...;
  
     ## A timeout (which is a timer that dies on expiry):
     $t = timeout( 5 ); # or...
     $t = IO::Run::Timer->new( 5, exception => "harness timed out" );
  
  =head1 DESCRIPTION
  
  This class and module allows timers and timeouts to be created for use
  by IPC::Run.  A timer simply expires when it's time is up.  A timeout
  is a timer that throws an exception when it expires.
  
  Timeouts are usually a bit simpler to use  than timers: they throw an
  exception on expiration so you don't need to check them:
  
     ## Give @cmd 10 seconds to get started, then 5 seconds to respond
     my $t = timeout( 10 );
     $h = start(
        \@cmd, \$in, \$out,
        $t,
     );
     pump $h until $out =~ /prompt/;
  
     $in = "some stimulus";
     $out = '';
     $t->time( 5 )
     pump $h until $out =~ /expected response/;
  
  You do need to check timers:
  
     ## Give @cmd 10 seconds to get started, then 5 seconds to respond
     my $t = timer( 10 );
     $h = start(
        \@cmd, \$in, \$out,
        $t,
     );
     pump $h until $t->is_expired || $out =~ /prompt/;
  
     $in = "some stimulus";
     $out = '';
     $t->time( 5 )
     pump $h until $out =~ /expected response/ || $t->is_expired;
  
  Timers and timeouts that are reset get started by start() and
  pump().  Timers change state only in pump().  Since run() and
  finish() both call pump(), they act like pump() with respect to
  timers.
  
  Timers and timeouts have three states: reset, running, and expired.
  Setting the timeout value resets the timer, as does calling
  the reset() method.  The start() method starts (or restarts) a
  timer with the most recently set time value, no matter what state
  it's in.
  
  =head2 Time values
  
  All time values are in seconds.  Times may be any kind of perl number,
  e.g. as integer or floating point seconds, optionally preceded by
  punctuation-separated days, hours, and minutes.
  
  Examples:
  
     1           1 second
     1.1         1.1 seconds
     60          60 seconds
     1:0         1 minute
     1:1         1 minute, 1 second
     1:90        2 minutes, 30 seconds
     1:2:3:4.5   1 day, 2 hours, 3 minutes, 4.5 seconds
     'inf'       the infinity perl special number (the timer never finishes)
  
  Absolute date/time strings are *not* accepted: year, month and
  day-of-month parsing is not available (patches welcome :-).
  
  =head2 Interval fudging
  
  When calculating an end time from a start time and an interval, IPC::Run::Timer
  instances add a little fudge factor.  This is to ensure that no time will
  expire before the interval is up.
  
  First a little background.  Time is sampled in discrete increments.  We'll
  call the
  exact moment that the reported time increments from one interval to the
  next a tick, and the interval between ticks as the time period.  Here's
  a diagram of three ticks and the periods between them:
  
  
      -0-0-0-0-0-0-0-0-0-0-1-1-1-1-1-1-1-1-1-1-2-...
      ^                   ^                   ^
      |<--- period 0 ---->|<--- period 1 ---->|
      |                   |                   |
    tick 0              tick 1              tick 2
  
  To see why the fudge factor is necessary, consider what would happen
  when a timer with an interval of 1 second is started right at the end of
  period 0:
  
  
      -0-0-0-0-0-0-0-0-0-0-1-1-1-1-1-1-1-1-1-1-2-...
      ^                ^  ^                   ^
      |                |  |                   |
      |                |  |                   |
    tick 0             |tick 1              tick 2
                       |
                   start $t
  
  Assuming that check() is called many times per period, then the timer
  is likely to expire just after tick 1, since the time reported will have
  lept from the value '0' to the value '1':
  
      -0-0-0-0-0-0-0-0-0-0-1-1-1-1-1-1-1-1-1-1-2-...
      ^                ^  ^   ^               ^
      |                |  |   |               |
      |                |  |   |               |
    tick 0             |tick 1|             tick 2
                       |      |
                   start $t   |
  		            |
  			check $t
  
  Adding a fudge of '1' in this example means that the timer is guaranteed
  not to expire before tick 2.
  
  The fudge is not added to an interval of '0'.
  
  This means that intervals guarantee a minimum interval.  Given that
  the process running perl may be suspended for some period of time, or that
  it gets busy doing something time-consuming, there are no other guarantees on
  how long it will take a timer to expire.
  
  =head1 SUBCLASSING
  
  INCOMPATIBLE CHANGE: Due to the awkwardness introduced by ripping
  pseudohashes out of Perl, this class I<no longer> uses the fields
  pragma.
  
  =head1 FUNCTIONS & METHODS
  
  =over
  
  =cut
  
  use strict;
  use warnings;
  use Carp;
  use Fcntl;
  use Symbol;
  use Exporter;
  use Scalar::Util ();
  use vars qw( $VERSION @ISA @EXPORT_OK %EXPORT_TAGS );
  
  BEGIN {
      $VERSION   = '20220807.0';
      @ISA       = qw( Exporter );
      @EXPORT_OK = qw(
        check
        end_time
        exception
        expire
        interval
        is_expired
        is_reset
        is_running
        name
        reset
        start
        timeout
        timer
      );
  
      %EXPORT_TAGS = ( 'all' => \@EXPORT_OK );
  }
  
  require IPC::Run;
  use IPC::Run::Debug;
  
  ##
  ## Some helpers
  ##
  my $resolution = 1;
  
  sub _parse_time {
      for ( $_[0] ) {
          my $val;
          if ( not defined $_ ) {
              $val = $_;
          }
          else {
              my @f = split( /:/, $_, -1 );
              if ( scalar @f > 4 ) {
                  croak "IPC::Run: expected <= 4 elements in time string '$_'";
              }
              for (@f) {
                  if ( not Scalar::Util::looks_like_number($_) ) {
                      croak "IPC::Run: non-numeric element '$_' in time string '$_'";
                  }
              }
              my ( $s, $m, $h, $d ) = reverse @f;
              $val = ( ( ( $d || 0 ) * 24 + ( $h || 0 ) ) * 60 + ( $m || 0 ) ) * 60 + ( $s || 0 );
          }
          return $val;
      }
  }
  
  sub _calc_end_time {
      my IPC::Run::Timer $self = shift;
      my $interval = $self->interval;
      $interval += $resolution if $interval;
      $self->end_time( $self->start_time + $interval );
  }
  
  =item timer
  
  A constructor function (not method) of IPC::Run::Timer instances:
  
     $t = timer( 5 );
     $t = timer( 5, name => 'stall timer', debug => 1 );
  
     $t = timer;
     $t->interval( 5 );
  
     run ..., $t;
     run ..., $t = timer( 5 );
  
  This convenience function is a shortened spelling of
  
     IPC::Run::Timer->new( ... );
     
  .  It returns a timer in the reset state with a given interval.
  
  If an exception is provided, it will be thrown when the timer notices that
  it has expired (in check()).  The name is for debugging usage, if you plan on
  having multiple timers around.  If no name is provided, a name like "timer #1"
  will be provided.
  
  =cut
  
  sub timer {
      return IPC::Run::Timer->new(@_);
  }
  
  =item timeout
  
  A constructor function (not method) of IPC::Run::Timer instances:
  
     $t = timeout( 5 );
     $t = timeout( 5, exception => "kablooey" );
     $t = timeout( 5, name => "stall", exception => "kablooey" );
  
     $t = timeout;
     $t->interval( 5 );
  
     run ..., $t;
     run ..., $t = timeout( 5 );
  
  A This convenience function is a shortened spelling of 
  
     IPC::Run::Timer->new( exception => "IPC::Run: timeout ...", ... );
     
  .  It returns a timer in the reset state that will throw an
  exception when it expires.
  
  Takes the same parameters as L</timer>, any exception passed in overrides
  the default exception.
  
  =cut
  
  sub timeout {
      my $t = IPC::Run::Timer->new(@_);
      $t->exception( "IPC::Run: timeout on " . $t->name )
        unless defined $t->exception;
      return $t;
  }
  
  =item new
  
     IPC::Run::Timer->new()  ;
     IPC::Run::Timer->new( 5 )  ;
     IPC::Run::Timer->new( 5, exception => 'kablooey' )  ;
  
  Constructor.  See L</timer> for details.
  
  =cut
  
  my $timer_counter;
  
  sub new {
      my $class = shift;
      $class = ref $class || $class;
  
      my IPC::Run::Timer $self = bless {}, $class;
  
      $self->{STATE} = 0;
      $self->{DEBUG} = 0;
      $self->{NAME}  = "timer #" . ++$timer_counter;
  
      while (@_) {
          my $arg = shift;
          if ( $arg eq 'exception' ) {
              $self->exception(shift);
          }
          elsif ( $arg eq 'name' ) {
              $self->name(shift);
          }
          elsif ( $arg eq 'debug' ) {
              $self->debug(shift);
          }
          else {
              $self->interval($arg);
          }
      }
  
      _debug $self->name . ' constructed'
        if $self->{DEBUG} || _debugging_details;
  
      return $self;
  }
  
  =item check
  
     check $t;
     check $t, $now;
     $t->check;
  
  Checks to see if a timer has expired since the last check.  Has no effect
  on non-running timers.  This will throw an exception if one is defined.
  
  IPC::Run::pump() calls this routine for any timers in the harness.
  
  You may pass in a version of now, which is useful in case you have
  it lying around or you want to check several timers with a consistent
  concept of the current time.
  
  Returns the time left before end_time or 0 if end_time is no longer
  in the future or the timer is not running
  (unless, of course, check() expire()s the timer and this
  results in an exception being thrown).
  
  Returns undef if the timer is not running on entry, 0 if check() expires it,
  and the time left if it's left running.
  
  =cut
  
  sub check {
      my IPC::Run::Timer $self = shift;
      return undef if !$self->is_running;
      return 0     if $self->is_expired;
  
      my ($now) = @_;
      $now = _parse_time($now);
      $now = time unless defined $now;
  
      _debug( "checking ", $self->name, " (end time ", $self->end_time, ") at ", $now ) if $self->{DEBUG} || _debugging_details;
  
      my $left = $self->end_time - $now;
      return $left if $left > 0;
  
      $self->expire;
      return 0;
  }
  
  =item debug
  
  Sets/gets the current setting of the debugging flag for this timer.  This
  has no effect if debugging is not enabled for the current harness.
  
  =cut
  
  sub debug {
      my IPC::Run::Timer $self = shift;
      $self->{DEBUG} = shift if @_;
      return $self->{DEBUG};
  }
  
  =item end_time
  
     $et = $t->end_time;
     $et = end_time $t;
  
     $t->end_time( time + 10 );
  
  Returns the time when this timer will or did expire.  Even if this time is
  in the past, the timer may not be expired, since check() may not have been
  called yet.
  
  Note that this end_time is not start_time($t) + interval($t), since some
  small extra amount of time is added to make sure that the timer does not
  expire before interval() elapses.  If this were not so, then 
  
  Changing end_time() while a timer is running will set the expiration time.
  Changing it while it is expired has no affect, since reset()ing a timer always
  clears the end_time().
  
  =cut
  
  sub end_time {
      my IPC::Run::Timer $self = shift;
      if (@_) {
          $self->{END_TIME} = shift;
          _debug $self->name, ' end_time set to ', $self->{END_TIME}
            if $self->{DEBUG} > 2 || _debugging_details;
      }
      return $self->{END_TIME};
  }
  
  =item exception
  
     $x = $t->exception;
     $t->exception( $x );
     $t->exception( undef );
  
  Sets/gets the exception to throw, if any.  'undef' means that no
  exception will be thrown.  Exception does not need to be a scalar: you 
  may ask that references be thrown.
  
  =cut
  
  sub exception {
      my IPC::Run::Timer $self = shift;
      if (@_) {
          $self->{EXCEPTION} = shift;
          _debug $self->name, ' exception set to ', $self->{EXCEPTION}
            if $self->{DEBUG} || _debugging_details;
      }
      return $self->{EXCEPTION};
  }
  
  =item interval
  
     $i = interval $t;
     $i = $t->interval;
     $t->interval( $i );
  
  Sets the interval.  Sets the end time based on the start_time() and the
  interval (and a little fudge) if the timer is running.
  
  =cut
  
  sub interval {
      my IPC::Run::Timer $self = shift;
      if (@_) {
          $self->{INTERVAL} = _parse_time(shift);
          _debug $self->name, ' interval set to ', $self->{INTERVAL}
            if $self->{DEBUG} > 2 || _debugging_details;
  
          $self->_calc_end_time if $self->state;
      }
      return $self->{INTERVAL};
  }
  
  =item expire
  
     expire $t;
     $t->expire;
  
  Sets the state to expired (undef).
  Will throw an exception if one
  is defined and the timer was not already expired.  You can expire a
  reset timer without starting it.
  
  =cut
  
  sub expire {
      my IPC::Run::Timer $self = shift;
      if ( defined $self->state ) {
          _debug $self->name . ' expired'
            if $self->{DEBUG} || _debugging;
  
          $self->state(undef);
          croak $self->exception if $self->exception;
      }
      return undef;
  }
  
  =item is_running
  
  =cut
  
  sub is_running {
      my IPC::Run::Timer $self = shift;
      return $self->state ? 1 : 0;
  }
  
  =item is_reset
  
  =cut
  
  sub is_reset {
      my IPC::Run::Timer $self = shift;
      return defined $self->state && $self->state == 0;
  }
  
  =item is_expired
  
  =cut
  
  sub is_expired {
      my IPC::Run::Timer $self = shift;
      return !defined $self->state;
  }
  
  =item name
  
  Sets/gets this timer's name.  The name is only used for debugging
  purposes so you can tell which freakin' timer is doing what.
  
  =cut
  
  sub name {
      my IPC::Run::Timer $self = shift;
  
      $self->{NAME} = shift if @_;
      return
          defined $self->{NAME}      ? $self->{NAME}
        : defined $self->{EXCEPTION} ? 'timeout'
        :                              'timer';
  }
  
  =item reset
  
     reset $t;
     $t->reset;
  
  Resets the timer to the non-running, non-expired state and clears
  the end_time().
  
  =cut
  
  sub reset {
      my IPC::Run::Timer $self = shift;
      $self->state(0);
      $self->end_time(undef);
      _debug $self->name . ' reset'
        if $self->{DEBUG} || _debugging;
  
      return undef;
  }
  
  =item start
  
     start $t;
     $t->start;
     start $t, $interval;
     start $t, $interval, $now;
  
  Starts or restarts a timer.  This always sets the start_time.  It sets the
  end_time based on the interval if the timer is running or if no end time
  has been set.
  
  You may pass an optional interval or current time value.
  
  Not passing a defined interval causes the previous interval setting to be
  re-used unless the timer is reset and an end_time has been set
  (an exception is thrown if no interval has been set).  
  
  Not passing a defined current time value causes the current time to be used.
  
  Passing a current time value is useful if you happen to have a time value
  lying around or if you want to make sure that several timers are started
  with the same concept of start time.  You might even need to lie to an
  IPC::Run::Timer, occasionally.
  
  =cut
  
  sub start {
      my IPC::Run::Timer $self = shift;
  
      my ( $interval, $now ) = map { _parse_time($_) } @_;
      $now = _parse_time($now);
      $now = time unless defined $now;
  
      $self->interval($interval) if defined $interval;
  
      ## start()ing a running or expired timer clears the end_time, so that the
      ## interval is used.  So does specifying an interval.
      $self->end_time(undef) if !$self->is_reset || $interval;
  
      croak "IPC::Run: no timer interval or end_time defined for " . $self->name
        unless defined $self->interval || defined $self->end_time;
  
      $self->state(1);
      $self->start_time($now);
      ## The "+ 1" is in case the START_TIME was sampled at the end of a
      ## tick (which are one second long in this module).
      $self->_calc_end_time
        unless defined $self->end_time;
  
      _debug(
          $self->name, " started at ", $self->start_time,
          ", with interval ", $self->interval, ", end_time ", $self->end_time
      ) if $self->{DEBUG} || _debugging;
      return undef;
  }
  
  =item start_time
  
  Sets/gets the start time, in seconds since the epoch.  Setting this manually
  is a bad idea, it's better to call L</start>() at the correct time.
  
  =cut
  
  sub start_time {
      my IPC::Run::Timer $self = shift;
      if (@_) {
          $self->{START_TIME} = _parse_time(shift);
          _debug $self->name, ' start_time set to ', $self->{START_TIME}
            if $self->{DEBUG} > 2 || _debugging;
      }
  
      return $self->{START_TIME};
  }
  
  =item state
  
     $s = state $t;
     $t->state( $s );
  
  Get/Set the current state.  Only use this if you really need to transfer the
  state to/from some variable.
  Use L</expire>, L</start>, L</reset>, L</is_expired>, L</is_running>,
  L</is_reset>.
  
  Note:  Setting the state to 'undef' to expire a timer will not throw an
  exception.
  
  =back
  
  =cut
  
  sub state {
      my IPC::Run::Timer $self = shift;
      if (@_) {
          $self->{STATE} = shift;
          _debug $self->name, ' state set to ', $self->{STATE}
            if $self->{DEBUG} > 2 || _debugging;
      }
      return $self->{STATE};
  }
  
  1;
  
  =pod
  
  =head1 TODO
  
  use Time::HiRes; if it's present.
  
  Add detection and parsing of [[[HH:]MM:]SS formatted times and intervals.
  
  =head1 AUTHOR
  
  Barrie Slaymaker <barries@slaysys.com>
  
  =cut
IPC_RUN_TIMER

$fatpacked{"IPC/Run/Win32Helper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN_WIN32HELPER';
  package IPC::Run::Win32Helper;
  
  =pod
  
  =head1 NAME
  
  IPC::Run::Win32Helper - helper routines for IPC::Run on Win32 platforms.
  
  =head1 SYNOPSIS
  
      use IPC::Run::Win32Helper;   # Exports all by default
  
  =head1 DESCRIPTION
  
  IPC::Run needs to use sockets to redirect subprocess I/O so that the select() loop
  will work on Win32. This seems to only work on WinNT and Win2K at this time, not
  sure if it will ever work on Win95 or Win98. If you have experience in this area, please
  contact me at barries@slaysys.com, thanks!.
  
  =cut
  
  use strict;
  use warnings;
  use Carp;
  use IO::Handle;
  use vars qw{ $VERSION @ISA @EXPORT };
  
  BEGIN {
      $VERSION = '20220807.0';
      @ISA     = qw( Exporter );
      @EXPORT  = qw(
        win32_spawn
        win32_parse_cmd_line
        _dont_inherit
        _inherit
      );
  }
  
  require POSIX;
  
  use File::Spec ();
  use Text::ParseWords;
  use Win32 ();
  use Win32::Process;
  use Win32::ShellQuote ();
  use IPC::Run::Debug;
  use Win32API::File qw(
    FdGetOsFHandle
    SetHandleInformation
    HANDLE_FLAG_INHERIT
    INVALID_HANDLE_VALUE
  );
  
  ## Takes an fd or a GLOB ref, never never never a Win32 handle.
  sub _dont_inherit {
      for (@_) {
          next unless defined $_;
          my $fd = $_;
          $fd = fileno $fd if ref $fd;
          _debug "disabling inheritance of ", $fd if _debugging_details;
          my $osfh = FdGetOsFHandle $fd;
          croak $^E if !defined $osfh || $osfh == INVALID_HANDLE_VALUE;
  
          SetHandleInformation( $osfh, HANDLE_FLAG_INHERIT, 0 );
      }
  }
  
  sub _inherit {    #### REMOVE
      for (@_) {    #### REMOVE
          next unless defined $_;    #### REMOVE
          my $fd = $_;               #### REMOVE
          $fd = fileno $fd if ref $fd;    #### REMOVE
          _debug "enabling inheritance of ", $fd if _debugging_details;    #### REMOVE
          my $osfh = FdGetOsFHandle $fd;                                   #### REMOVE
          croak $^E if !defined $osfh || $osfh == INVALID_HANDLE_VALUE;    #### REMOVE
          #### REMOVE
          SetHandleInformation( $osfh, HANDLE_FLAG_INHERIT, 1 );           #### REMOVE
      }    #### REMOVE
  }    #### REMOVE
  #### REMOVE
  #sub _inherit {
  #   for ( @_ ) {
  #      next unless defined $_;
  #      my $osfh = GetOsFHandle $_;
  #      croak $^E if ! defined $osfh || $osfh == INVALID_HANDLE_VALUE;
  #      SetHandleInformation( $osfh, HANDLE_FLAG_INHERIT, HANDLE_FLAG_INHERIT );
  #   }
  #}
  
  =pod
  
  =head1 FUNCTIONS
  
  =over
  
  =item optimize()
  
  Most common incantations of C<run()> (I<not> C<harness()>, C<start()>,
  or C<finish()>) now use temporary files to redirect input and output
  instead of pumper processes.
  
  Temporary files are used when sending to child processes if input is
  taken from a scalar with no filter subroutines.  This is the only time
  we can assume that the parent is not interacting with the child's
  redirected input as it runs.
  
  Temporary files are used when receiving from children when output is
  to a scalar or subroutine with or without filters, but only if
  the child in question closes its inputs or takes input from 
  unfiltered SCALARs or named files.  Normally, a child inherits its STDIN
  from its parent; to close it, use "0<&-" or the C<< noinherit => 1 >> option.
  If data is sent to the child from CODE refs, filehandles or from
  scalars through filters than the child's outputs will not be optimized
  because C<optimize()> assumes the parent is interacting with the child.
  It is ok if the output is filtered or handled by a subroutine, however.
  
  This assumes that all named files are real files (as opposed to named
  pipes) and won't change; and that a process is not communicating with
  the child indirectly (through means not visible to IPC::Run).
  These can be an invalid assumptions, but are the 99% case.
  Write me if you need an option to enable or disable optimizations; I
  suspect it will work like the C<binary()> modifier.
  
  To detect cases that you might want to optimize by closing inputs, try
  setting the C<IPCRUNDEBUG> environment variable to the special C<notopt>
  value:
  
     C:> set IPCRUNDEBUG=notopt
     C:> my_app_that_uses_IPC_Run.pl
  
  =item optimizer() rationalizations
  
  Only for that limited case can we be sure that it's ok to batch all the
  input in to a temporary file.  If STDIN is from a SCALAR or from a named
  file or filehandle (again, only in C<run()>), then outputs to CODE refs
  are also assumed to be safe enough to batch through a temp file,
  otherwise only outputs to SCALAR refs are batched.  This can cause a bit
  of grief if the parent process benefits from or relies on a bit of
  "early returns" coming in before the child program exits.  As long as
  the output is redirected to a SCALAR ref, this will not be visible.
  When output is redirected to a subroutine or (deprecated) filters, the
  subroutine will not get any data until after the child process exits,
  and it is likely to get bigger chunks of data at once.
  
  The reason for the optimization is that, without it, "pumper" processes
  are used to overcome the inconsistencies of the Win32 API.  We need to
  use anonymous pipes to connect to the child processes' stdin, stdout,
  and stderr, yet select() does not work on these.  select() only works on
  sockets on Win32.  So for each redirected child handle, there is
  normally a "pumper" process that connects to the parent using a
  socket--so the parent can select() on that fd--and to the child on an
  anonymous pipe--so the child can read/write a pipe.
  
  Using a socket to connect directly to the child (as at least one MSDN
  article suggests) seems to cause the trailing output from most children
  to be lost.  I think this is because child processes rarely close their
  stdout and stderr explicitly, and the winsock dll does not seem to flush
  output when a process that uses it exits without explicitly closing
  them.
  
  Because of these pumpers and the inherent slowness of Win32
  CreateProcess(), child processes with redirects are quite slow to
  launch; so this routine looks for the very common case of
  reading/writing to/from scalar references in a run() routine and
  converts such reads and writes in to temporary file reads and writes.
  
  Such files are marked as FILE_ATTRIBUTE_TEMPORARY to increase speed and
  as FILE_FLAG_DELETE_ON_CLOSE so it will be cleaned up when the child
  process exits (for input files).  The user's default permissions are
  used for both the temporary files and the directory that contains them,
  hope your Win32 permissions are secure enough for you.  Files are
  created with the Win32API::File defaults of
  FILE_SHARE_READ|FILE_SHARE_WRITE.
  
  Setting the debug level to "details" or "gory" will give detailed
  information about the optimization process; setting it to "basic" or
  higher will tell whether or not a given call is optimized.  Setting
  it to "notopt" will highlight those calls that aren't optimized.
  
  =cut
  
  sub optimize {
      my ($h) = @_;
  
      my @kids = @{ $h->{KIDS} };
  
      my $saw_pipe;
  
      my ( $ok_to_optimize_outputs, $veto_output_optimization );
  
      for my $kid (@kids) {
          ( $ok_to_optimize_outputs, $veto_output_optimization ) = ()
            unless $saw_pipe;
  
          _debug "Win32 optimizer: (kid $kid->{NUM}) STDIN piped, carrying over ok of non-SCALAR output optimization"
            if _debugging_details && $ok_to_optimize_outputs;
          _debug "Win32 optimizer: (kid $kid->{NUM}) STDIN piped, carrying over veto of non-SCALAR output optimization"
            if _debugging_details && $veto_output_optimization;
  
          if ( $h->{noinherit} && !$ok_to_optimize_outputs ) {
              _debug "Win32 optimizer: (kid $kid->{NUM}) STDIN not inherited from parent oking non-SCALAR output optimization"
                if _debugging_details && $ok_to_optimize_outputs;
              $ok_to_optimize_outputs = 1;
          }
  
          for ( @{ $kid->{OPS} } ) {
              if ( substr( $_->{TYPE}, 0, 1 ) eq "<" ) {
                  if ( $_->{TYPE} eq "<" ) {
                      if ( @{ $_->{FILTERS} } > 1 ) {
                          ## Can't assume that the filters are idempotent.
                      }
                      elsif (ref $_->{SOURCE} eq "SCALAR"
                          || ref $_->{SOURCE} eq "GLOB"
                          || UNIVERSAL::isa( $_, "IO::Handle" ) ) {
                          if ( $_->{KFD} == 0 ) {
                              _debug
                                "Win32 optimizer: (kid $kid->{NUM}) 0$_->{TYPE}",
                                ref $_->{SOURCE},
                                ", ok to optimize outputs"
                                if _debugging_details;
                              $ok_to_optimize_outputs = 1;
                          }
                          $_->{SEND_THROUGH_TEMP_FILE} = 1;
                          next;
                      }
                      elsif ( !ref $_->{SOURCE} && defined $_->{SOURCE} ) {
                          if ( $_->{KFD} == 0 ) {
                              _debug
                                "Win32 optimizer: (kid $kid->{NUM}) 0<$_->{SOURCE}, ok to optimize outputs",
                                if _debugging_details;
                              $ok_to_optimize_outputs = 1;
                          }
                          next;
                      }
                  }
                  _debug
                    "Win32 optimizer: (kid $kid->{NUM}) ",
                    $_->{KFD},
                    $_->{TYPE},
                    defined $_->{SOURCE}
                    ? ref $_->{SOURCE}
                        ? ref $_->{SOURCE}
                        : $_->{SOURCE}
                    : defined $_->{FILENAME} ? $_->{FILENAME}
                    : "",
                    @{ $_->{FILTERS} } > 1 ? " with filters" : (),
                    ", VETOING output opt."
                    if _debugging_details || _debugging_not_optimized;
                  $veto_output_optimization = 1;
              }
              elsif ( $_->{TYPE} eq "close" && $_->{KFD} == 0 ) {
                  $ok_to_optimize_outputs = 1;
                  _debug "Win32 optimizer: (kid $kid->{NUM}) saw 0<&-, ok to optimize outputs"
                    if _debugging_details;
              }
              elsif ( $_->{TYPE} eq "dup" && $_->{KFD2} == 0 ) {
                  $veto_output_optimization = 1;
                  _debug "Win32 optimizer: (kid $kid->{NUM}) saw 0<&$_->{KFD2}, VETOING output opt."
                    if _debugging_details || _debugging_not_optimized;
              }
              elsif ( $_->{TYPE} eq "|" ) {
                  $saw_pipe = 1;
              }
          }
  
          if ( !$ok_to_optimize_outputs && !$veto_output_optimization ) {
              _debug "Win32 optimizer: (kid $kid->{NUM}) child STDIN not redirected, VETOING non-SCALAR output opt."
                if _debugging_details || _debugging_not_optimized;
              $veto_output_optimization = 1;
          }
  
          if ( $ok_to_optimize_outputs && $veto_output_optimization ) {
              $ok_to_optimize_outputs = 0;
              _debug "Win32 optimizer: (kid $kid->{NUM}) non-SCALAR output optimizations VETOed"
                if _debugging_details || _debugging_not_optimized;
          }
  
          ## SOURCE/DEST ARRAY means it's a filter.
          ## TODO: think about checking to see if the final input/output of
          ## a filter chain (an ARRAY SOURCE or DEST) is a scalar...but
          ## we may be deprecating filters.
  
          for ( @{ $kid->{OPS} } ) {
              if ( $_->{TYPE} eq ">" ) {
                  if (
                      ref $_->{DEST} eq "SCALAR"
                      || (
                          (
                                 @{ $_->{FILTERS} } > 1
                              || ref $_->{DEST} eq "CODE"
                              || ref $_->{DEST} eq "ARRAY"    ## Filters?
                          )
                          && ( $ok_to_optimize_outputs && !$veto_output_optimization )
                      )
                    ) {
                      $_->{RECV_THROUGH_TEMP_FILE} = 1;
                      next;
                  }
                  _debug
                    "Win32 optimizer: NOT optimizing (kid $kid->{NUM}) ",
                    $_->{KFD},
                    $_->{TYPE},
                    defined $_->{DEST}
                    ? ref $_->{DEST}
                        ? ref $_->{DEST}
                        : $_->{SOURCE}
                    : defined $_->{FILENAME} ? $_->{FILENAME}
                    : "",
                    @{ $_->{FILTERS} } ? " with filters" : (),
                    if _debugging_details;
              }
          }
      }
  
  }
  
  =pod
  
  =item win32_parse_cmd_line
  
     @words = win32_parse_cmd_line( q{foo bar 'baz baz' "bat bat"} );
  
  returns 4 words. This parses like the bourne shell (see
  the bit about shellwords() in L<Text::ParseWords>), assuming we're
  trying to be a little cross-platform here.  The only difference is
  that "\" is *not* treated as an escape except when it precedes 
  punctuation, since it's used all over the place in DOS path specs.
  
  TODO: strip caret escapes?
  
  TODO: use
  https://docs.microsoft.com/en-us/cpp/cpp/main-function-command-line-args#parsing-c-command-line-arguments
  
  TODO: globbing? probably not (it's unDOSish).
  
  TODO: shebang emulation? Probably, but perhaps that should be part
  of Run.pm so all spawned processes get the benefit.
  
  LIMITATIONS: shellwords dies silently on malformed input like 
  
     a\"
  
  =cut
  
  sub win32_parse_cmd_line {
      my $line = shift;
      $line =~ s{(\\[\w\s])}{\\$1}g;
      return shellwords $line;
  }
  
  =pod
  
  =item win32_spawn
  
  Spawns a child process, possibly with STDIN, STDOUT, and STDERR (file descriptors 0, 1, and 2, respectively) redirected.
  
  B<LIMITATIONS>.
  
  Cannot redirect higher file descriptors due to lack of support for this in the
  Win32 environment.
  
  This can be worked around by marking a handle as inheritable in the
  parent (or leaving it marked; this is the default in perl), obtaining it's
  Win32 handle with C<Win32API::GetOSFHandle(FH)> or
  C<Win32API::FdGetOsFHandle($fd)> and passing it to the child using the command
  line, the environment, or any other IPC mechanism (it's a plain old integer).
  The child can then use C<OsFHandleOpen()> or C<OsFHandleOpenFd()> and possibly
  C<<open FOO ">&BAR">> or C<<open FOO ">&$fd>> as need be.  Ach, the pain!
  
  Remember to check the Win32 handle against INVALID_HANDLE_VALUE.
  
  =cut
  
  sub _save {
      my ( $saved, $saved_as, $fd ) = @_;
  
      ## We can only save aside the original fds once.
      return if exists $saved->{$fd};
  
      my $saved_fd = IPC::Run::_dup($fd);
      _dont_inherit $saved_fd;
  
      $saved->{$fd}          = $saved_fd;
      $saved_as->{$saved_fd} = $fd;
  
      _dont_inherit $saved->{$fd};
  }
  
  sub _dup2_gently {
      my ( $saved, $saved_as, $fd1, $fd2 ) = @_;
      _save $saved, $saved_as, $fd2;
  
      if ( exists $saved_as->{$fd2} ) {
          ## The target fd is colliding with a saved-as fd, gotta bump
          ## the saved-as fd to another fd.
          my $orig_fd  = delete $saved_as->{$fd2};
          my $saved_fd = IPC::Run::_dup($fd2);
          _dont_inherit $saved_fd;
  
          $saved->{$orig_fd}     = $saved_fd;
          $saved_as->{$saved_fd} = $orig_fd;
      }
      _debug "moving $fd1 to kid's $fd2" if _debugging_details;
      IPC::Run::_dup2_rudely( $fd1, $fd2 );
  }
  
  sub win32_spawn {
      my ( $cmd, $ops ) = @_;
  
      my ( $app, $cmd_line );
      my $need_pct = 0;
      if ( UNIVERSAL::isa( $cmd, 'IPC::Run::Win32Process' ) ) {
          $app      = $cmd->{lpApplicationName};
          $cmd_line = $cmd->{lpCommandLine};
      }
      elsif ( $cmd->[0] !~ /\.(bat|cmd) *$/i ) {
          $app      = $cmd->[0];
          $cmd_line = Win32::ShellQuote::quote_native(@$cmd);
      }
      else {
          # Batch file, so follow the batch-specific guidance of
          # https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa
          # There's no one true way to locate cmd.exe.  In the unlikely event that
          # %COMSPEC% is missing, fall back on a Windows API.  We could search
          # %PATH% like _wsystem() does.  That would be prone to security bugs,
          # and one fallback is enough.
          $app = (
              $ENV{COMSPEC}
                || File::Spec->catfile(
                  Win32::GetFolderPath(Win32::CSIDL_SYSTEM),
                  'cmd.exe'
                )
          );
  
          # Win32 rejects attempts to create files with names containing certain
          # characters.  Ignore most, but reject the subset that might otherwise
          # cause us to execute the wrong file instead of failing cleanly.
          if ( $cmd->[0] =~ /["\r\n\0]/ ) {
              croak "invalid batch file name";
          }
  
          # Make cmd.exe see the batch file name as quoted.  Suppose we instead
          # used caret escapes, as we do for arguments.  cmd.exe could then "break
          # the command token at the first occurrence of <space> , ; or ="
          # (https://stackoverflow.com/a/4095133).
          my @parts = qq{"$cmd->[0]"};
  
          # cmd.exe will strip escapes once when parsing our $cmd_line and again
          # where the batch file injects the argument via %*, %1, etc.  Compensate
          # by adding one extra cmd_escape layer.
          if ( @$cmd > 1 ) {
              my @q = Win32::ShellQuote::quote_cmd( @{$cmd}[ 1 .. $#{$cmd} ] );
              push @parts, map { Win32::ShellQuote::cmd_escape($_) } @q;
          }
  
          # One can't stop cmd.exe from expanding %var%, so inject each literal %
          # via an environment variable.  Delete that variable before the real
          # child can see it.  See
          # https://www.dostips.com/forum/viewtopic.php?f=3&t=10131 for more on
          # this technique and the limitations of alternatives.
          $cmd_line = join ' ', @parts;
          if ( $cmd_line =~ s/%/%ipcrunpct%/g ) {
              $cmd_line = qq{/c "set "ipcrunpct=" & $cmd_line"};
              $need_pct = 1;
          }
          else {
              $cmd_line = qq{/c "$cmd_line"};
          }
      }
      _debug "app: ", $app
        if _debugging;
      _debug "cmd line: ", $cmd_line
        if _debugging;
  
      ## NOTE: The debug pipe write handle is passed to pump processes as STDOUT.
      ## and is not to the "real" child process, since they would not know
      ## what to do with it...unlike Unix, we have no code executing in the
      ## child before the "real" child is exec()ed.
  
      my %saved;       ## Map of parent's orig fd -> saved fd
      my %saved_as;    ## Map of parent's saved fd -> orig fd, used to
      ## detect collisions between a KFD and the fd a
      ## parent's fd happened to be saved to.
  
      for my $op (@$ops) {
          _dont_inherit $op->{FD} if defined $op->{FD};
  
          if ( defined $op->{KFD} && $op->{KFD} > 2 ) {
              ## TODO: Detect this in harness()
              ## TODO: enable temporary redirections if ever necessary, not
              ## sure why they would be...
              ## 4>&1 1>/dev/null 1>&4 4>&-
              croak "Can't redirect fd #", $op->{KFD}, " on Win32";
          }
  
          ## This is very similar logic to IPC::Run::_do_kid_and_exit().
          if ( defined $op->{TFD} ) {
              unless ( $op->{TFD} == $op->{KFD} ) {
                  _dup2_gently \%saved, \%saved_as, $op->{TFD}, $op->{KFD};
                  _dont_inherit $op->{TFD};
              }
          }
          elsif ( $op->{TYPE} eq "dup" ) {
              _dup2_gently \%saved, \%saved_as, $op->{KFD1}, $op->{KFD2}
                unless $op->{KFD1} == $op->{KFD2};
          }
          elsif ( $op->{TYPE} eq "close" ) {
              _save \%saved, \%saved_as, $op->{KFD};
              IPC::Run::_close( $op->{KFD} );
          }
          elsif ( $op->{TYPE} eq "init" ) {
              ## TODO: detect this in harness()
              croak "init subs not allowed on Win32";
          }
      }
  
      local $ENV{ipcrunpct} = '%' if $need_pct;
      my $process;
      Win32::Process::Create(
          $process,
          $app,
          $cmd_line,
          1,    ## Inherit handles
          0,    ## Inherit parent priortiy class. Was NORMAL_PRIORITY_CLASS
          ".",
        )
        or do {
          my $err = Win32::FormatMessage( Win32::GetLastError() );
          $err =~ s/\r?\n$//s;
          croak "$err: Win32::Process::Create()";
        };
  
      for my $orig_fd ( keys %saved ) {
          IPC::Run::_dup2_rudely( $saved{$orig_fd}, $orig_fd );
          IPC::Run::_close( $saved{$orig_fd} );
      }
  
      return ( $process->GetProcessID(), $process );
  }
  
  1;
  
  =pod
  
  =back
  
  =head1 AUTHOR
  
  Barries Slaymaker <barries@slaysys.com>.  Funded by Perforce Software, Inc.
  
  =head1 COPYRIGHT
  
  Copyright 2001, Barrie Slaymaker, All Rights Reserved.
  
  You may use this under the terms of either the GPL 2.0 or the Artistic License.
  
  =cut
IPC_RUN_WIN32HELPER

$fatpacked{"IPC/Run/Win32IO.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN_WIN32IO';
  package IPC::Run::Win32IO;
  
  =pod
  
  =head1 NAME
  
  IPC::Run::Win32IO - helper routines for IPC::Run on Win32 platforms.
  
  =head1 SYNOPSIS
  
      use IPC::Run::Win32IO;   # Exports all by default
  
  =head1 DESCRIPTION
  
  IPC::Run needs to use sockets to redirect subprocess I/O so that the select()
  loop will work on Win32. This seems to only work on WinNT and Win2K at this
  time, not sure if it will ever work on Win95 or Win98. If you have experience
  in this area, please contact me at barries@slaysys.com, thanks!.
  
  =head1 DESCRIPTION
  
  A specialized IO class used on Win32.
  
  =cut
  
  use strict;
  use warnings;
  use Carp;
  use IO::Handle;
  use Socket;
  require POSIX;
  
  use vars qw{$VERSION};
  
  BEGIN {
      $VERSION = '20220807.0';
  }
  
  use Socket qw( IPPROTO_TCP TCP_NODELAY );
  use Symbol;
  use Text::ParseWords;
  use Win32::Process;
  use IPC::Run::Debug qw( :default _debugging_level );
  use IPC::Run::Win32Helper qw( _inherit _dont_inherit );
  use Fcntl qw( O_TEXT O_RDONLY );
  
  use base qw( IPC::Run::IO );
  my @cleanup_fields;
  
  BEGIN {
      ## These fields will be set to undef in _cleanup to close
      ## the handles.
      @cleanup_fields = (
          'SEND_THROUGH_TEMP_FILE',    ## Set by WinHelper::optimize()
          'RECV_THROUGH_TEMP_FILE',    ## Set by WinHelper::optimize()
          'TEMP_FILE_NAME',            ## The name of the temp file, needed for
          ## error reporting / debugging only.
  
          'PARENT_HANDLE',             ## The handle of the socket for the parent
          'PUMP_SOCKET_HANDLE',        ## The socket handle for the pump
          'PUMP_PIPE_HANDLE',          ## The anon pipe handle for the pump
          'CHILD_HANDLE',              ## The anon pipe handle for the child
  
          'TEMP_FILE_HANDLE',          ## The Win32 filehandle for the temp file
      );
  }
  
  ## REMOVE OSFHandleOpen
  use Win32API::File qw(
    GetOsFHandle
    OsFHandleOpenFd
    OsFHandleOpen
    FdGetOsFHandle
    SetHandleInformation
    SetFilePointer
    HANDLE_FLAG_INHERIT
    INVALID_HANDLE_VALUE
  
    createFile
    WriteFile
    ReadFile
    CloseHandle
  
    FILE_ATTRIBUTE_TEMPORARY
    FILE_FLAG_DELETE_ON_CLOSE
    FILE_FLAG_WRITE_THROUGH
  
    FILE_BEGIN
  );
  
  #   FILE_ATTRIBUTE_HIDDEN
  #   FILE_ATTRIBUTE_SYSTEM
  
  BEGIN {
      ## Force AUTOLOADED constants to be, well, constant by getting them
      ## to AUTOLOAD before compilation continues.  Sigh.
      () = (
          SOL_SOCKET,
          SO_REUSEADDR,
          IPPROTO_TCP,
          TCP_NODELAY,
          HANDLE_FLAG_INHERIT,
          INVALID_HANDLE_VALUE,
      );
  }
  
  use constant temp_file_flags => ( FILE_ATTRIBUTE_TEMPORARY() | FILE_FLAG_DELETE_ON_CLOSE() | FILE_FLAG_WRITE_THROUGH() );
  
  #   FILE_ATTRIBUTE_HIDDEN()    |
  #   FILE_ATTRIBUTE_SYSTEM()    |
  my $tmp_file_counter;
  my $tmp_dir;
  
  sub _cleanup {
      my IPC::Run::Win32IO $self = shift;
      my ($harness) = @_;
  
      $self->_recv_through_temp_file($harness)
        if $self->{RECV_THROUGH_TEMP_FILE};
  
      CloseHandle( $self->{TEMP_FILE_HANDLE} )
        if defined $self->{TEMP_FILE_HANDLE};
  
      close( $self->{CHILD_HANDLE} )
        if defined $self->{CHILD_HANDLE};
  
      $self->{$_} = undef for @cleanup_fields;
  }
  
  sub _create_temp_file {
      my IPC::Run::Win32IO $self = shift;
  
      ## Create a hidden temp file that Win32 will delete when we close
      ## it.
      unless ( defined $tmp_dir ) {
          $tmp_dir = File::Spec->catdir( File::Spec->tmpdir, "IPC-Run.tmp" );
  
          ## Trust in the user's umask.
          ## This could possibly be a security hole, perhaps
          ## we should offer an option.  Hmmmm, really, people coding
          ## security conscious apps should audit this code and
          ## tell me how to make it better.  Nice cop-out :).
          unless ( -d $tmp_dir ) {
              mkdir $tmp_dir or croak "$!: $tmp_dir";
          }
      }
  
      $self->{TEMP_FILE_NAME} = File::Spec->catfile(
          ## File name is designed for easy sorting and not conflicting
          ## with other processes.  This should allow us to use "t"runcate
          ## access in CreateFile in case something left some droppings
          ## around (which should never happen because we specify
          ## FLAG_DELETE_ON_CLOSE.
          ## heh, belt and suspenders are better than bug reports; God forbid
          ## that NT should ever crash before a temp file gets deleted!
          $tmp_dir, sprintf "Win32io-%06d-%08d", $$, $tmp_file_counter++
      );
  
      $self->{TEMP_FILE_HANDLE} = createFile(
          $self->{TEMP_FILE_NAME},
          "trw",    ## new, truncate, read, write
          {
              Flags => temp_file_flags,
          },
      ) or croak "Can't create temporary file, $self->{TEMP_FILE_NAME}: $^E";
  
      $self->{TFD} = OsFHandleOpenFd $self->{TEMP_FILE_HANDLE}, 0;
      $self->{FD} = undef;
  
      _debug
        "Win32 Optimizer: temp file (",
        $self->{KFD},
        $self->{TYPE},
        $self->{TFD},
        ", fh ",
        $self->{TEMP_FILE_HANDLE},
        "): ",
        $self->{TEMP_FILE_NAME}
        if _debugging_details;
  }
  
  sub _reset_temp_file_pointer {
      my $self = shift;
      SetFilePointer( $self->{TEMP_FILE_HANDLE}, 0, 0, FILE_BEGIN )
        or confess "$^E seeking on (fd $self->{TFD}) $self->{TEMP_FILE_NAME} for kid's fd $self->{KFD}";
  }
  
  sub _send_through_temp_file {
      my IPC::Run::Win32IO $self = shift;
  
      _debug "Win32 optimizer: optimizing " . " $self->{KFD} $self->{TYPE} temp file instead of ",
        ref $self->{SOURCE} || $self->{SOURCE}
        if _debugging_details;
  
      $self->_create_temp_file;
  
      if ( defined ${ $self->{SOURCE} } ) {
          my $bytes_written = 0;
          my $data_ref;
          if ( $self->binmode ) {
              $data_ref = $self->{SOURCE};
          }
          else {
              my $data = ${ $self->{SOURCE} };    # Ugh, a copy.
              $data =~ s/(?<!\r)\n/\r\n/g;
              $data_ref = \$data;
          }
  
          WriteFile(
              $self->{TEMP_FILE_HANDLE},
              $$data_ref,
              0,                                  ## Write entire buffer
              $bytes_written,
              [],                                 ## Not overlapped.
          ) or croak "$^E writing $self->{TEMP_FILE_NAME} for kid to read on fd $self->{KFD}";
          _debug "Win32 optimizer: wrote $bytes_written to temp file $self->{TEMP_FILE_NAME}"
            if _debugging_data;
  
          $self->_reset_temp_file_pointer;
  
      }
  
      _debug "Win32 optimizer: kid to read $self->{KFD} from temp file on $self->{TFD}"
        if _debugging_details;
  }
  
  sub _init_recv_through_temp_file {
      my IPC::Run::Win32IO $self = shift;
  
      $self->_create_temp_file;
  }
  
  ## TODO: Use the Win32 API in the select loop to see if the file has grown
  ## and read it incrementally if it has.
  sub _recv_through_temp_file {
      my IPC::Run::Win32IO $self = shift;
  
      ## This next line kicks in if the run() never got to initting things
      ## and needs to clean up.
      return undef unless defined $self->{TEMP_FILE_HANDLE};
  
      push @{ $self->{FILTERS} }, sub {
          my ( undef, $out_ref ) = @_;
  
          return undef unless defined $self->{TEMP_FILE_HANDLE};
  
          my $r;
          my $s;
          ReadFile(
              $self->{TEMP_FILE_HANDLE},
              $s,
              999_999,    ## Hmmm, should read the size.
              $r,
              []
          ) or croak "$^E reading from $self->{TEMP_FILE_NAME}";
  
          _debug "ReadFile( $self->{TFD} ) = $r chars '$s'" if _debugging_data;
  
          return undef unless $r;
  
          $s =~ s/\r\n/\n/g unless $self->binmode;
  
          my $pos = pos $$out_ref;
          $$out_ref .= $s;
          pos($out_ref) = $pos;
          return 1;
      };
  
      my ($harness) = @_;
  
      $self->_reset_temp_file_pointer;
  
      1 while $self->_do_filters($harness);
  
      pop @{ $self->{FILTERS} };
  
      IPC::Run::_close( $self->{TFD} );
  }
  
  =head1 SUBROUTINES
  
  =over
  
  =item poll
  
  Windows version of IPC::Run::IP::poll.
  
  =back
  
  =cut
  
  sub poll {
      my IPC::Run::Win32IO $self = shift;
  
      return if $self->{SEND_THROUGH_TEMP_FILE} || $self->{RECV_THROUGH_TEMP_FILE};
  
      return $self->SUPER::poll(@_);
  }
  
  ## When threaded Perls get good enough, we should use threads here.
  ## The problem with threaded perls is that they dup() all sorts of
  ## filehandles and fds and don't allow sufficient control over
  ## closing off the ones we don't want.
  
  sub _spawn_pumper {
      my ( $stdin, $stdout, $debug_fd, $binmode, $child_label, @opts ) = @_;
      my ( $stdin_fd, $stdout_fd ) = ( fileno $stdin, fileno $stdout );
  
      _debug "pumper stdin = ",  $stdin_fd  if _debugging_details;
      _debug "pumper stdout = ", $stdout_fd if _debugging_details;
      _inherit $stdin_fd, $stdout_fd, $debug_fd;
      my @I_options = map qq{"-I$_"}, @INC;
  
      my $cmd_line = join(
          " ",
          qq{"$^X"},
          @I_options,
          qw(-MIPC::Run::Win32Pump -e 1 ),
  ## I'm using this clunky way of passing filehandles to the child process
  ## in order to avoid some kind of premature closure of filehandles
  ## problem I was having with VCP's test suite when passing them
  ## via CreateProcess.  All of the ## REMOVE code is stuff I'd like
  ## to be rid of and the ## ADD code is what I'd like to use.
          FdGetOsFHandle($stdin_fd),     ## REMOVE
          FdGetOsFHandle($stdout_fd),    ## REMOVE
          FdGetOsFHandle($debug_fd),     ## REMOVE
          $binmode ? 1 : 0,
          $$, $^T, _debugging_level, qq{"$child_label"},
          @opts
      );
  
      #   open SAVEIN,  "<&STDIN"  or croak "$! saving STDIN";       #### ADD
      #   open SAVEOUT, ">&STDOUT" or croak "$! saving STDOUT";       #### ADD
      #   open SAVEERR, ">&STDERR" or croak "$! saving STDERR";       #### ADD
      #   _dont_inherit \*SAVEIN;       #### ADD
      #   _dont_inherit \*SAVEOUT;       #### ADD
      #   _dont_inherit \*SAVEERR;       #### ADD
      #   open STDIN,  "<&$stdin_fd"  or croak "$! dup2()ing $stdin_fd (pumper's STDIN)";       #### ADD
      #   open STDOUT, ">&$stdout_fd" or croak "$! dup2()ing $stdout_fd (pumper's STDOUT)";       #### ADD
      #   open STDERR, ">&$debug_fd" or croak "$! dup2()ing $debug_fd (pumper's STDERR/debug_fd)";       #### ADD
  
      _debug "pump cmd line: ", $cmd_line if _debugging_details;
  
      my $process;
      Win32::Process::Create(
          $process,
          $^X,
          $cmd_line,
          1,    ## Inherit handles
          NORMAL_PRIORITY_CLASS,
          ".",
      ) or croak "$!: Win32::Process::Create()";
  
      #   open STDIN,  "<&SAVEIN"  or croak "$! restoring STDIN";       #### ADD
      #   open STDOUT, ">&SAVEOUT" or croak "$! restoring STDOUT";       #### ADD
      #   open STDERR, ">&SAVEERR" or croak "$! restoring STDERR";       #### ADD
      #   close SAVEIN             or croak "$! closing SAVEIN";       #### ADD
      #   close SAVEOUT            or croak "$! closing SAVEOUT";       #### ADD
      #   close SAVEERR            or croak "$! closing SAVEERR";       #### ADD
  
      # In case of a sleep right here, need the IPC::Run::_close() treatment.
      IPC::Run::_close fileno($stdin);
      close $stdin;
      IPC::Run::_close fileno($stdout);
      close $stdout;
  
      # Don't close $debug_fd, we need it, as do other pumpers.
  
      # Pause a moment to allow the child to get up and running and emit
      # debug messages.  This does not always work.
      #   select undef, undef, undef, 1 if _debugging_details;
  
      _debug "_spawn_pumper pid = ", $process->GetProcessID
        if _debugging_data;
  }
  
  my $loopback  = inet_aton "127.0.0.1";
  my $tcp_proto = getprotobyname('tcp');
  croak "$!: getprotobyname('tcp')" unless defined $tcp_proto;
  
  sub _socket {
      my ($server) = @_;
      $server ||= gensym;
      my $client = gensym;
  
      my $listener = gensym;
      socket $listener, PF_INET, SOCK_STREAM, $tcp_proto
        or croak "$!: socket()";
      setsockopt $listener, SOL_SOCKET, SO_REUSEADDR, pack( "l", 0 )
        or croak "$!: setsockopt()";
  
      unless ( bind $listener, sockaddr_in( 0, $loopback ) ) {
          croak "Error binding: $!";
      }
  
      my ($port) = sockaddr_in( getsockname($listener) );
  
      _debug "win32 port = $port" if _debugging_details;
  
      listen $listener, my $queue_size = 1
        or croak "$!: listen()";
  
      {
          socket $client, PF_INET, SOCK_STREAM, $tcp_proto
            or croak "$!: socket()";
  
          my $paddr = sockaddr_in( $port, $loopback );
  
          connect $client, $paddr
            or croak "$!: connect()";
  
          croak "$!: accept" unless defined $paddr;
  
          ## The windows "default" is SO_DONTLINGER, which should make
          ## sure all socket data goes through.  I have my doubts based
          ## on experimentation, but nothing prompts me to set SO_LINGER
          ## at this time...
          setsockopt $client, IPPROTO_TCP, TCP_NODELAY, pack( "l", 0 )
            or croak "$!: setsockopt()";
      }
  
      {
          _debug "accept()ing on port $port" if _debugging_details;
          my $paddr = accept( $server, $listener );
          croak "$!: accept()" unless defined $paddr;
      }
  
      _debug "win32 _socket = ( ", fileno $server, ", ", fileno $client, " ) on port $port"
        if _debugging_details;
      return ( $server, $client );
  }
  
  sub _open_socket_pipe {
      my IPC::Run::Win32IO $self = shift;
      my ( $debug_fd, $parent_handle ) = @_;
  
      my $is_send_to_child = $self->dir eq "<";
  
      $self->{CHILD_HANDLE}     = gensym;
      $self->{PUMP_PIPE_HANDLE} = gensym;
  
      (
          $self->{PARENT_HANDLE},
          $self->{PUMP_SOCKET_HANDLE}
      ) = _socket $parent_handle;
  
      ## These binmodes seem to have no effect on Win2K, but just to be safe
      ## I do them.
      binmode $self->{PARENT_HANDLE}      or die $!;
      binmode $self->{PUMP_SOCKET_HANDLE} or die $!;
  
      _debug "PUMP_SOCKET_HANDLE = ", fileno $self->{PUMP_SOCKET_HANDLE}
        if _debugging_details;
  ##my $buf;
  ##$buf = "write on child end of " . fileno( $self->{WRITE_HANDLE} ) . "\n\n\n\n\n";
  ##POSIX::write(fileno $self->{WRITE_HANDLE}, $buf, length $buf) or warn "$! in syswrite";
  ##$buf = "write on parent end of " . fileno( $self->{CHILD_HANDLE} ) . "\r\n";
  ##POSIX::write(fileno $self->{CHILD_HANDLE},$buf, length $buf) or warn "$! in syswrite";
  ##   $self->{CHILD_HANDLE}->autoflush( 1 );
  ##   $self->{WRITE_HANDLE}->autoflush( 1 );
  
      ## Now fork off a data pump and arrange to return the correct fds.
      if ($is_send_to_child) {
          pipe $self->{CHILD_HANDLE}, $self->{PUMP_PIPE_HANDLE}
            or croak "$! opening child pipe";
          _debug "CHILD_HANDLE = ", fileno $self->{CHILD_HANDLE}
            if _debugging_details;
          _debug "PUMP_PIPE_HANDLE = ", fileno $self->{PUMP_PIPE_HANDLE}
            if _debugging_details;
      }
      else {
          pipe $self->{PUMP_PIPE_HANDLE}, $self->{CHILD_HANDLE}
            or croak "$! opening child pipe";
          _debug "CHILD_HANDLE = ", fileno $self->{CHILD_HANDLE}
            if _debugging_details;
          _debug "PUMP_PIPE_HANDLE = ", fileno $self->{PUMP_PIPE_HANDLE}
            if _debugging_details;
      }
  
      ## These binmodes seem to have no effect on Win2K, but just to be safe
      ## I do them.
      binmode $self->{CHILD_HANDLE};
      binmode $self->{PUMP_PIPE_HANDLE};
  
      ## No child should ever see this.
      _dont_inherit $self->{PARENT_HANDLE};
  
      ## We clear the inherit flag so these file descriptors are not inherited.
      ## It'll be dup()ed on to STDIN/STDOUT/STDERR before CreateProcess is
      ## called and *that* fd will be inheritable.
      _dont_inherit $self->{PUMP_SOCKET_HANDLE};
      _dont_inherit $self->{PUMP_PIPE_HANDLE};
      _dont_inherit $self->{CHILD_HANDLE};
  
      ## Need to return $self so the HANDLEs don't get freed.
      ## Return $self, $parent_fd, $child_fd
      my ( $parent_fd, $child_fd ) = (
          fileno $self->{PARENT_HANDLE},
          fileno $self->{CHILD_HANDLE}
      );
  
      ## Both PUMP_..._HANDLEs will be closed, no need to worry about
      ## inheritance.
      _debug "binmode on" if _debugging_data && $self->binmode;
      _spawn_pumper(
          $is_send_to_child
          ? ( $self->{PUMP_SOCKET_HANDLE}, $self->{PUMP_PIPE_HANDLE} )
          : ( $self->{PUMP_PIPE_HANDLE}, $self->{PUMP_SOCKET_HANDLE} ),
          $debug_fd,
          $self->binmode,
          $child_fd . $self->dir . "pump" . $self->dir . $parent_fd,
      );
  
      {
          my $foo;
          confess "PARENT_HANDLE no longer open"
            unless POSIX::read( $parent_fd, $foo, 0 );
      }
  
      _debug "win32_fake_pipe = ( $parent_fd, $child_fd )"
        if _debugging_details;
  
      $self->{FD}  = $parent_fd;
      $self->{TFD} = $child_fd;
  }
  
  sub _do_open {
      my IPC::Run::Win32IO $self = shift;
  
      if ( $self->{SEND_THROUGH_TEMP_FILE} ) {
          return $self->_send_through_temp_file(@_);
      }
      elsif ( $self->{RECV_THROUGH_TEMP_FILE} ) {
          return $self->_init_recv_through_temp_file(@_);
      }
      else {
          return $self->_open_socket_pipe(@_);
      }
  }
  
  1;
  
  =pod
  
  =head1 AUTHOR
  
  Barries Slaymaker <barries@slaysys.com>.  Funded by Perforce Software, Inc.
  
  =head1 COPYRIGHT
  
  Copyright 2001, Barrie Slaymaker, All Rights Reserved.
  
  You may use this under the terms of either the GPL 2.0 or the Artistic License.
  
  =cut
IPC_RUN_WIN32IO

$fatpacked{"IPC/Run/Win32Process.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN_WIN32PROCESS';
  package IPC::Run::Win32Process;
  
  =pod
  
  =head1 NAME
  
  IPC::Run::Win32Process -- deliver nonstandard command lines via IPC::Run.
  
  =head1 SYNOPSIS
  
     use File::Spec ();
     use IPC::Run qw(run);
     use IPC::Run::Win32Process ();
     use Win32 ();
  
     $find_exe = File::Spec->catfile(Win32::GetFolderPath(Win32::CSIDL_SYSTEM),
                                     'find.exe');
     run(IPC::Run::Win32Process->new($ENV{COMSPEC}, q{cmd.exe /c echo ""}),
         '|', IPC::Run::Win32Process->new($find_exe, q{find_exe """"""}),
         '>', \$out);
  
  =head1 DESCRIPTION
  
  This class facilitates executing Windows programs that don't use L<standard
  command line parsing
  rules|https://docs.microsoft.com/en-us/cpp/cpp/main-function-command-line-args#parsing-c-command-line-arguments>.
  Notable programs having nonstandard rules include F<cmd.exe>, F<cscript.exe>,
  and Cygwin programs called from non-Cygwin programs.  IPC::Run will use the two
  strings, verbatim, as the lpApplicationName and lpCommandLine arguments of
  CreateProcessA().  This furnishes unfiltered control over the child process
  command line.
  
  =head1 FUNCTIONS & METHODS
  
  =over
  
  =cut
  
  use strict;
  use warnings;
  use Carp;
  
  use overload '""' => sub {
      my ($self) = @_;
      return join(
          '',
          'IPC::Run::Win32Process(',
          $self->{lpApplicationName},
          ', ',
          $self->{lpCommandLine},
          ')'
      );
  };
  
  use vars qw{$VERSION};
  
  BEGIN {
      $VERSION = '20220807.0';
  }
  
  =item new
  
     IPC::Run::Win32Process->new( $lpApplicationName, $lpCommandLine );
     IPC::Run::Win32Process->new( $ENV{COMSPEC}, q{cmd.exe /c echo ""} );
  
  Constructor.
  
  =back
  
  =cut
  
  sub new {
      my ( $class, $lpApplicationName, $lpCommandLine ) = @_;
      $class = ref $class || $class;
  
      croak "missing lpApplicationName" if !defined $lpApplicationName;
      croak "missing lpCommandLine"     if !defined $lpCommandLine;
  
      my IPC::Run::Win32Process $self = bless {}, $class;
      $self->{lpApplicationName} = $lpApplicationName;
      $self->{lpCommandLine}     = $lpCommandLine;
  
      return $self;
  }
  
  1;
IPC_RUN_WIN32PROCESS

$fatpacked{"IPC/Run/Win32Pump.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN_WIN32PUMP';
  package IPC::Run::Win32Pump;
  
  =pod
  
  =head1 NAME
  
  IPC::Run::Win32Pump - helper processes to shovel data to/from parent, child
  
  =head1 SYNOPSIS
  
  Internal use only; see IPC::Run::Win32IO and best of luck to you.
  
  =head1 DESCRIPTION
  
  See L<IPC::Run::Win32Helper|IPC::Run::Win32Helper> for details.  This
  module is used in subprocesses that are spawned to shovel data to/from
  parent processes from/to their child processes.  Where possible, pumps
  are optimized away.
  
  NOTE: This is not a real module: it's a script in module form, designed
  to be run like
  
     $^X -MIPC::Run::Win32Pumper -e 1 ...
  
  It parses a bunch of command line parameters from IPC::Run::Win32IO.
  
  =cut
  
  use strict;
  use warnings;
  use vars qw{$VERSION};
  
  BEGIN {
      $VERSION = '20220807.0';
  }
  
  use Win32API::File qw(
    OsFHandleOpen
  );
  
  my ( $stdin_fh, $stdout_fh, $debug_fh, $binmode, $parent_pid, $parent_start_time, $debug, $child_label );
  
  BEGIN {
      ( $stdin_fh, $stdout_fh, $debug_fh, $binmode, $parent_pid, $parent_start_time, $debug, $child_label ) = @ARGV;
      ## Rather than letting IPC::Run::Debug export all-0 constants
      ## when not debugging, we do it manually in order to not even
      ## load IPC::Run::Debug.
      if ($debug) {
          eval "use IPC::Run::Debug qw( :default _debug_init ); 1;"
            or die $@;
      }
      else {
          eval <<STUBS_END or die $@;
  	 sub _debug {}
  	 sub _debug_init {}
  	 sub _debugging() { 0 }
  	 sub _debugging_data() { 0 }
  	 sub _debugging_details() { 0 }
  	 sub _debugging_gory_details() { 0 }
  	 1;
  STUBS_END
      }
  }
  
  ## For some reason these get created with binmode on.  AAargh, gotta       #### REMOVE
  ## do it by hand below.       #### REMOVE
  if ($debug) {    #### REMOVE
      close STDERR;    #### REMOVE
      OsFHandleOpen( \*STDERR, $debug_fh, "w" )    #### REMOVE
        or print "$! opening STDERR as Win32 handle $debug_fh in pumper $$";    #### REMOVE
  }               #### REMOVE
  close STDIN;    #### REMOVE
  OsFHandleOpen( \*STDIN, $stdin_fh, "r" )    #### REMOVE
    or die "$! opening STDIN as Win32 handle $stdin_fh in pumper $$";    #### REMOVE
  close STDOUT;                                                          #### REMOVE
  OsFHandleOpen( \*STDOUT, $stdout_fh, "w" )                             #### REMOVE
    or die "$! opening STDOUT as Win32 handle $stdout_fh in pumper $$";  #### REMOVE
  
  binmode STDIN;
  binmode STDOUT;
  $| = 1;
  select STDERR;
  $| = 1;
  select STDOUT;
  
  $child_label ||= "pump";
  _debug_init(
      $parent_pid,
      $parent_start_time,
      $debug,
      fileno STDERR,
      $child_label,
  );
  
  _debug "Entered" if _debugging_details;
  
  # No need to close all fds; win32 doesn't seem to pass any on to us.
  $| = 1;
  my $buf;
  my $total_count = 0;
  while (1) {
      my $count = sysread STDIN, $buf, 10_000;
      last unless $count;
      if (_debugging_gory_details) {
          my $msg = "'$buf'";
          substr( $msg, 100, -1 ) = '...' if length $msg > 100;
          $msg =~ s/\n/\\n/g;
          $msg =~ s/\r/\\r/g;
          $msg =~ s/\t/\\t/g;
          $msg =~ s/([\000-\037\177-\277])/sprintf "\0x%02x", ord $1/eg;
          _debug sprintf( "%5d chars revc: ", $count ), $msg;
      }
      $total_count += $count;
      $buf =~ s/\r//g unless $binmode;
      if (_debugging_gory_details) {
          my $msg = "'$buf'";
          substr( $msg, 100, -1 ) = '...' if length $msg > 100;
          $msg =~ s/\n/\\n/g;
          $msg =~ s/\r/\\r/g;
          $msg =~ s/\t/\\t/g;
          $msg =~ s/([\000-\037\177-\277])/sprintf "\0x%02x", ord $1/eg;
          _debug sprintf( "%5d chars sent: ", $count ), $msg;
      }
      print $buf;
  }
  
  _debug "Exiting, transferred $total_count chars" if _debugging_details;
  
  ## Perform a graceful socket shutdown.  Windows defaults to SO_DONTLINGER,
  ## which should cause a "graceful shutdown in the background" on sockets.
  ## but that's only true if the process closes the socket manually, it
  ## seems; if the process exits and lets the OS clean up, the OS is not
  ## so kind.  STDOUT is not always a socket, of course, but it won't hurt
  ## to close a pipe and may even help.  With a closed source OS, who
  ## can tell?
  ##
  ## In any case, this close() is one of the main reasons we have helper
  ## processes; if the OS closed socket fds gracefully when an app exits,
  ## we'd just redirect the client directly to what is now the pump end
  ## of the socket.  As it is, however, we need to let the client play with
  ## pipes, which don't have the abort-on-app-exit behavior, and then
  ## adapt to the sockets in the helper processes to allow the parent to
  ## select.
  ##
  ## Possible alternatives / improvements:
  ##
  ## 1) use helper threads instead of processes.  I don't trust perl's threads
  ## as of 5.005 or 5.6 enough (which may be myopic of me).
  ##
  ## 2) figure out if/how to get at WaitForMultipleObjects() with pipe
  ## handles.  May be able to take the Win32 handle and pass it to
  ## Win32::Event::wait_any, dunno.
  ##
  ## 3) Use Inline::C or a hand-tooled XS module to do helper threads.
  ## This would be faster than #1, but would require a ppm distro.
  ##
  close STDOUT;
  close STDERR;
  
  1;
  
  =pod
  
  =head1 AUTHOR
  
  Barries Slaymaker <barries@slaysys.com>.  Funded by Perforce Software, Inc.
  
  =head1 COPYRIGHT
  
  Copyright 2001, Barrie Slaymaker, All Rights Reserved.
  
  You may use this under the terms of either the GPL 2.0 ir the Artistic License.
  
  =cut
IPC_RUN_WIN32PUMP

$fatpacked{"Pod/Usage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'POD_USAGE';
  #############################################################################
  # Pod/Usage.pm -- print usage messages for the running script.
  #
  # Copyright (c) 1996-2000 by Bradford Appleton. All rights reserved.
  # Copyright (c) 2001-2016 by Marek Rouchal.
  # This file is part of "Pod-Usage". Pod-Usage is free software;
  # you can redistribute it and/or modify it under the same terms
  # as Perl itself.
  #############################################################################
  
  package Pod::Usage;
  
  use strict;
  require  5.006;    ## requires this Perl version or later
  
  use Carp;
  use Config;
  use Exporter;
  use File::Spec;
  
  our $VERSION = '2.03';
  
  our @EXPORT = qw(&pod2usage);
  our @ISA;
  BEGIN {
      $Pod::Usage::Formatter ||= 'Pod::Text';
      eval "require $Pod::Usage::Formatter";
      die $@ if $@;
      @ISA = ( $Pod::Usage::Formatter );
  }
  
  our $MAX_HEADING_LEVEL = 3;
  
  ##---------------------------------------------------------------------------
  
  ##---------------------------------
  ## Function definitions begin here
  ##---------------------------------
  
  sub pod2usage {
      local($_) = shift;
      my %opts;
      ## Collect arguments
      if (@_ > 0) {
          ## Too many arguments - assume that this is a hash and
          ## the user forgot to pass a reference to it.
          %opts = ($_, @_);
      }
      elsif (!defined $_) {
        $_ = '';
      }
      elsif (ref $_) {
          ## User passed a ref to a hash
          %opts = %{$_}  if (ref($_) eq 'HASH');
      }
      elsif (/^[-+]?\d+$/) {
          ## User passed in the exit value to use
          $opts{'-exitval'} =  $_;
      }
      else {
          ## User passed in a message to print before issuing usage.
          $_  and  $opts{'-message'} = $_;
      }
  
      ## Need this for backward compatibility since we formerly used
      ## options that were all uppercase words rather than ones that
      ## looked like Unix command-line options.
      ## to be uppercase keywords)
      %opts = map {
          my ($key, $val) = ($_, $opts{$_});
          $key =~ s/^(?=\w)/-/;
          $key =~ /^-msg/i   and  $key = '-message';
          $key =~ /^-exit/i  and  $key = '-exitval';
          lc($key) => $val;
      } (keys %opts);
  
      ## Now determine default -exitval and -verbose values to use
      if ((! defined $opts{'-exitval'}) && (! defined $opts{'-verbose'})) {
          $opts{'-exitval'} = 2;
          $opts{'-verbose'} = 0;
      }
      elsif (! defined $opts{'-exitval'}) {
          $opts{'-exitval'} = ($opts{'-verbose'} > 0) ? 1 : 2;
      }
      elsif (! defined $opts{'-verbose'}) {
          $opts{'-verbose'} = (lc($opts{'-exitval'}) eq 'noexit' ||
                               $opts{'-exitval'} < 2);
      }
  
      ## Default the output file
      $opts{'-output'} = (lc($opts{'-exitval'}) eq 'noexit' ||
                          $opts{'-exitval'} < 2) ? \*STDOUT : \*STDERR
              unless (defined $opts{'-output'});
      ## Default the input file
      $opts{'-input'} = $0  unless (defined $opts{'-input'});
  
      ## Look up input file in path if it doesn't exist.
      unless ((ref $opts{'-input'}) || (-e $opts{'-input'})) {
          my $basename = $opts{'-input'};
          my $pathsep = ($^O =~ /^(?:dos|os2|MSWin32)$/i) ? ';'
                              : (($^O eq 'MacOS' || $^O eq 'VMS') ? ',' :  ':');
          my $pathspec = $opts{'-pathlist'} || $ENV{PATH} || $ENV{PERL5LIB};
  
          my @paths = (ref $pathspec) ? @$pathspec : split($pathsep, $pathspec);
          for my $dirname (@paths) {
              $_ = length($dirname) ? File::Spec->catfile($dirname, $basename) : $basename;
              last if (-e $_) && ($opts{'-input'} = $_);
          }
      }
  
      ## Now create a pod reader and constrain it to the desired sections.
      my $parser = Pod::Usage->new(USAGE_OPTIONS => \%opts);
      if ($opts{'-verbose'} == 0) {
          $parser->select('(?:SYNOPSIS|USAGE)\s*');
      }
      elsif ($opts{'-verbose'} == 1) {
          my $opt_re = '(?i)' .
                       '(?:OPTIONS|ARGUMENTS)' .
                       '(?:\s*(?:AND|\/)\s*(?:OPTIONS|ARGUMENTS))?';
          $parser->select( '(?:SYNOPSIS|USAGE)\s*', $opt_re, "DESCRIPTION/$opt_re" );
      }
      elsif ($opts{'-verbose'} >= 2 && $opts{'-verbose'} != 99) {
          $parser->select('.*');
      }
      elsif ($opts{'-verbose'} == 99) {
          my $sections = $opts{'-sections'};
          $parser->select( (ref $sections) ? @$sections : $sections );
          $opts{'-verbose'} = 1;
      }
  
      ## Check for perldoc
      my $progpath = $opts{'-perldoc'} ? $opts{'-perldoc'} :
          File::Spec->catfile($Config{scriptdirexp} || $Config{scriptdir},
              'perldoc');
  
      my $version = sprintf("%vd",$^V);
      if ($Config{versiononly} and $Config{startperl} =~ /\Q$version\E$/ ) {
        $progpath .= $version;
      }
      $opts{'-noperldoc'} = 1 unless -e $progpath;
  
      ## Now translate the pod document and then exit with the desired status
      if (      !$opts{'-noperldoc'}
           and  $opts{'-verbose'} >= 2
           and  !ref($opts{'-input'})
           and  $opts{'-output'} == \*STDOUT )
      {
         ## spit out the entire PODs. Might as well invoke perldoc
         print { $opts{'-output'} } ($opts{'-message'}, "\n") if($opts{'-message'});
         if(defined $opts{-input} && $opts{-input} =~ /^\s*(\S.*?)\s*$/) {
           # the perldocs back to 5.005 should all have -F
  	 # without -F there are warnings in -T scripts
  	 my $f = $1;
           my @perldoc_cmd = ($progpath);
  	 if ($opts{'-perldocopt'}) {
             $opts{'-perldocopt'} =~ s/^\s+|\s+$//g;
  	   push @perldoc_cmd, split(/\s+/, $opts{'-perldocopt'});
  	 }
  	 push @perldoc_cmd, ('-F', $f);
           unshift @perldoc_cmd, $opts{'-perlcmd'} if $opts{'-perlcmd'};
           system(@perldoc_cmd);
           # RT16091: fall back to more if perldoc failed
           if($?) {
             # RT131844: prefer PAGER env
             my $pager = $ENV{PAGER} || $Config{pager};
             if(defined($pager) && length($pager)) {
               my $cmd = $pager . ' ' . ($^O =~ /win/i ? qq("$f") : quotemeta($f));
               system($cmd);
             } else {
               # the most humble fallback; should work (at least) on *nix and Win
               system('more', $f);
             }
           }
         } else {
           croak "Unspecified input file or insecure argument.\n";
         }
      }
      else {
         $parser->parse_from_file($opts{'-input'}, $opts{'-output'});
      }
  
      exit($opts{'-exitval'})  unless (lc($opts{'-exitval'}) eq 'noexit');
  }
  
  ##---------------------------------------------------------------------------
  
  ##-------------------------------
  ## Method definitions begin here
  ##-------------------------------
  
  sub new {
      my $this = shift;
      my $class = ref($this) || $this;
      my %params = @_;
      my $self = {%params};
      bless $self, $class;
      if ($self->can('initialize')) {
          $self->initialize();
      } else {
          # pass through options to Pod::Text
          my %opts;
         	for (qw(alt code indent loose margin quotes sentence stderr utf8 width)) {
              my $val = $params{USAGE_OPTIONS}{"-$_"};
              $opts{$_} = $val if defined $val;
          }
          $self = $self->SUPER::new(%opts);
          %$self = (%$self, %params);
      }
      return $self;
  }
  
  # This subroutine was copied in whole-cloth from Pod::Select 1.60 in order to
  # allow the ejection of Pod::Select from the core without breaking Pod::Usage.
  # -- rjbs, 2013-03-18
  sub _compile_section_spec {
      my ($section_spec) = @_;
      my (@regexs, $negated);
  
      ## Compile the spec into a list of regexs
      local $_ = $section_spec;
      s{\\\\}{\001}g;  ## handle escaped backward slashes
      s{\\/}{\002}g;   ## handle escaped forward slashes
  
      ## Parse the regexs for the heading titles
      @regexs = split(/\//, $_, $MAX_HEADING_LEVEL);
  
      ## Set default regex for ommitted levels
      for (my $i = 0; $i < $MAX_HEADING_LEVEL; ++$i) {
          $regexs[$i]  = '.*'  unless ((defined $regexs[$i])
                                       && (length $regexs[$i]));
      }
      ## Modify the regexs as needed and validate their syntax
      my $bad_regexs = 0;
      for (@regexs) {
          $_ .= '.+'  if ($_ eq '!');
          s{\001}{\\\\}g;       ## restore escaped backward slashes
          s{\002}{\\/}g;        ## restore escaped forward slashes
          $negated = s/^\!//;   ## check for negation
          eval "m{$_}";         ## check regex syntax
          if ($@) {
              ++$bad_regexs;
              carp qq{Bad regular expression /$_/ in "$section_spec": $@\n};
          }
          else {
              ## Add the forward and rear anchors (and put the negator back)
              $_ = '^' . $_  unless (/^\^/);
              $_ = $_ . '$'  unless (/\$$/);
              $_ = '!' . $_  if ($negated);
          }
      }
      return  (! $bad_regexs) ? [ @regexs ] : undef;
  }
  
  sub select {
      my ($self, @sections) = @_;
      if ($ISA[0]->can('select')) {
          $self->SUPER::select(@sections);
      } else {
          # we're using Pod::Simple - need to mimic the behavior of Pod::Select
          my $add = ($sections[0] eq '+') ? shift(@sections) : '';
          ## Reset the set of sections to use
          unless (@sections) {
            delete $self->{USAGE_SELECT} unless ($add);
            return;
          }
          $self->{USAGE_SELECT} = []
            unless ($add && $self->{USAGE_SELECT});
          my $sref = $self->{USAGE_SELECT};
          ## Compile each spec
          for my $spec (@sections) {
            my $cs = _compile_section_spec($spec);
            if ( defined $cs ) {
              ## Store them in our sections array
              push(@$sref, $cs);
            } else {
              carp qq{Ignoring section spec "$spec"!\n};
            }
          }
      }
  }
  
  # Override Pod::Text->seq_i to return just "arg", not "*arg*".
  sub seq_i { return $_[1] }
  # Override Pod::Text->cmd_i to return just "arg", not "*arg*".
  # newer version based on Pod::Simple
  sub cmd_i {
   my $self = shift;
   # RT121489: highlighting should be there with Termcap
   return $self->SUPER::cmd_i(@_) if $self->isa('Pod::Text::Termcap');
   return $_[1];
  }
  
  # This overrides the Pod::Text method to do something very akin to what
  # Pod::Select did as well as the work done below by preprocess_paragraph.
  # Note that the below is very, very specific to Pod::Text and Pod::Simple.
  sub _handle_element_end {
      my ($self, $element) = @_;
      if ($element eq 'head1') {
          $self->{USAGE_HEADINGS} = [ $$self{PENDING}[-1][1] ];
          if ($self->{USAGE_OPTIONS}->{-verbose} < 2) {
              $$self{PENDING}[-1][1] =~ s/^\s*SYNOPSIS\s*$/USAGE/;
          }
      } elsif ($element =~ /^head(\d+)$/ && $1) { # avoid 0
          my $idx = $1 - 1;
          $self->{USAGE_HEADINGS} = [] unless($self->{USAGE_HEADINGS});
          $self->{USAGE_HEADINGS}->[$idx] = $$self{PENDING}[-1][1];
          # we have to get rid of the lower headings
          splice(@{$self->{USAGE_HEADINGS}},$idx+1);
      }
      if ($element =~ /^head\d+$/) {
          $$self{USAGE_SKIPPING} = 1;
          if (!$$self{USAGE_SELECT} || !@{ $$self{USAGE_SELECT} }) {
              $$self{USAGE_SKIPPING} = 0;
          } else {
              my @headings = @{$$self{USAGE_HEADINGS}};
              for my $section_spec ( @{$$self{USAGE_SELECT}} ) {
                  my $match = 1;
                  for (my $i = 0; $i < $MAX_HEADING_LEVEL; ++$i) {
                      $headings[$i] = '' unless defined $headings[$i];
                      my $regex   = $section_spec->[$i];
                      my $negated = ($regex =~ s/^\!//);
                      $match  &= ($negated ? ($headings[$i] !~ /${regex}/)
                                           : ($headings[$i] =~ /${regex}/));
                      last unless ($match);
                  } # end heading levels
                  if ($match) {
                    $$self{USAGE_SKIPPING} = 0;
                    last;
                  }
              } # end sections
          }
  
          # Try to do some lowercasing instead of all-caps in headings, and use
          # a colon to end all headings.
          if($self->{USAGE_OPTIONS}->{-verbose} < 2) {
              local $_ = $$self{PENDING}[-1][1];
              s{([A-Z])([A-Z]+)}{((length($2) > 2) ? $1 : lc($1)) . lc($2)}ge;
              s/\s*$/:/  unless (/:\s*$/);
              $_ .= "\n";
              $$self{PENDING}[-1][1] = $_;
          }
      }
      if ($$self{USAGE_SKIPPING} && $element !~ m/^over-|^[BCFILSZ]$/) {
          pop @{ $$self{PENDING} };
      } else {
          $self->SUPER::_handle_element_end($element);
      }
  }
  
  # required for Pod::Simple API
  sub start_document {
      my $self = shift;
      $self->SUPER::start_document();
      my $msg = $self->{USAGE_OPTIONS}->{-message}  or  return 1;
      my $out_fh = $self->output_fh();
      print $out_fh "$msg\n";
  }
  
  # required for old Pod::Parser API
  sub begin_pod {
      my $self = shift;
      $self->SUPER::begin_pod();  ## Have to call superclass
      my $msg = $self->{USAGE_OPTIONS}->{-message}  or  return 1;
      my $out_fh = $self->output_handle();
      print $out_fh "$msg\n";
  }
  
  sub preprocess_paragraph {
      my $self = shift;
      local $_ = shift;
      my $line = shift;
      ## See if this is a heading and we aren't printing the entire manpage.
      if (($self->{USAGE_OPTIONS}->{-verbose} < 2) && /^=head/) {
          ## Change the title of the SYNOPSIS section to USAGE
          s/^=head1\s+SYNOPSIS\s*$/=head1 USAGE/;
          ## Try to do some lowercasing instead of all-caps in headings
          s{([A-Z])([A-Z]+)}{((length($2) > 2) ? $1 : lc($1)) . lc($2)}ge;
          ## Use a colon to end all headings
          s/\s*$/:/  unless (/:\s*$/);
          $_ .= "\n";
      }
      return  $self->SUPER::preprocess_paragraph($_);
  }
  
  1; # keep require happy
  
  __END__
  
  =for stopwords pod2usage verboseness downcased MSWin32 Marek Rouchal Christiansen ATOOMIC rjbs McDougall
  
  =head1 NAME
  
  Pod::Usage - extracts POD documentation and shows usage information
  
  =head1 SYNOPSIS
  
    use Pod::Usage;
  
    my $message_text  = "This text precedes the usage message.";
    my $exit_status   = 2;          ## The exit status to use
    my $verbose_level = 0;          ## The verbose level to use
    my $filehandle    = \*STDERR;   ## The filehandle to write to
  
    pod2usage($message_text);
  
    pod2usage($exit_status);
  
    pod2usage( { -message => $message_text ,
                 -exitval => $exit_status  ,
                 -verbose => $verbose_level,
                 -output  => $filehandle } );
  
    pod2usage(   -msg     => $message_text ,
                 -exitval => $exit_status  ,
                 -verbose => $verbose_level,
                 -output  => $filehandle );
  
    pod2usage(   -verbose => 2,
                 -noperldoc => 1  );
  
    pod2usage(   -verbose => 2,
                 -perlcmd => $path_to_perl,
                 -perldoc => $path_to_perldoc,
                 -perldocopt => $perldoc_options );
  
  =head1 ARGUMENTS
  
  B<pod2usage> should be given either a single argument, or a list of
  arguments corresponding to an associative array (a "hash"). When a single
  argument is given, it should correspond to exactly one of the following:
  
  =over 4
  
  =item *
  
  A string containing the text of a message to print I<before> printing
  the usage message
  
  =item *
  
  A numeric value corresponding to the desired exit status
  
  =item *
  
  A reference to a hash
  
  =back
  
  If more than one argument is given then the entire argument list is
  assumed to be a hash.  If a hash is supplied (either as a reference or
  as a list) it should contain one or more elements with the following
  keys:
  
  =over 4
  
  =item C<-message> I<string>
  
  =item C<-msg> I<string>
  
  The text of a message to print immediately prior to printing the
  program's usage message.
  
  =item C<-exitval> I<value>
  
  The desired exit status to pass to the B<exit()> function.
  This should be an integer, or else the string C<NOEXIT> to
  indicate that control should simply be returned without
  terminating the invoking process.
  
  =item C<-verbose> I<value>
  
  The desired level of "verboseness" to use when printing the usage message.
  If the value is 0, then only the "SYNOPSIS" and/or "USAGE" sections of the
  pod documentation are printed. If the value is 1, then the "SYNOPSIS" and/or
  "USAGE" sections, along with any section entitled "OPTIONS", "ARGUMENTS", or
  "OPTIONS AND ARGUMENTS" is printed. If the corresponding value is 2 or more
  then the entire manpage is printed, using L<perldoc> if available; otherwise
  L<Pod::Text> is used for the formatting. For better readability, the
  all-capital headings are downcased, e.g. C<SYNOPSIS> =E<gt> C<Synopsis>.
  
  The special verbosity level 99 requires to also specify the -sections
  parameter; then these sections are extracted and printed.
  
  =item C<-sections> I<spec>
  
  There are two ways to specify the selection. Either a string (scalar)
  representing a selection regexp for sections to be printed when -verbose
  is set to 99, e.g.
  
    "NAME|SYNOPSIS|DESCRIPTION|VERSION"
  
  With the above regexp all content following (and including) any of the
  given C<=head1> headings will be shown. It is possible to restrict the
  output to particular subsections only, e.g.:
  
    "DESCRIPTION/Algorithm"
  
  This will output only the C<=head2 Algorithm> heading and content within
  the C<=head1 DESCRIPTION> section. The regexp binding is stronger than the
  section separator, such that e.g.:
  
    "DESCRIPTION|OPTIONS|ENVIRONMENT/Caveats"
  
  will print any C<=head2 Caveats> section (only) within any of the three
  C<=head1> sections.
  
  Alternatively, an array reference of section specifications can be used:
  
    pod2usage(-verbose => 99, -sections => [
      qw(DESCRIPTION DESCRIPTION/Introduction) ] );
  
  This will print only the content of C<=head1 DESCRIPTION> and the
  C<=head2 Introduction> sections, but no other C<=head2>, and no other
  C<=head1> either.
  
  =item C<-output> I<handle>
  
  A reference to a filehandle, or the pathname of a file to which the
  usage message should be written. The default is C<\*STDERR> unless the
  exit value is less than 2 (in which case the default is C<\*STDOUT>).
  
  =item C<-input> I<handle>
  
  A reference to a filehandle, or the pathname of a file from which the
  invoking script's pod documentation should be read.  It defaults to the
  file indicated by C<$0> (C<$PROGRAM_NAME> for users of F<English.pm>).
  
  If you are calling B<pod2usage()> from a module and want to display
  that module's POD, you can use this:
  
    use Pod::Find qw(pod_where);
    pod2usage( -input => pod_where({-inc => 1}, __PACKAGE__) );
  
  =item C<-pathlist> I<string>
  
  A list of directory paths. If the input file does not exist, then it
  will be searched for in the given directory list (in the order the
  directories appear in the list). It defaults to the list of directories
  implied by C<$ENV{PATH}>. The list may be specified either by a reference
  to an array, or by a string of directory paths which use the same path
  separator as C<$ENV{PATH}> on your system (e.g., C<:> for Unix, C<;> for
  MSWin32 and DOS).
  
  =item C<-noperldoc>
  
  By default, Pod::Usage will call L<perldoc> when -verbose >= 2 is specified.
  This does not work well e.g. if the script was packed with L<PAR>. This option
  suppresses the external call to L<perldoc> and uses the simple text formatter
  (L<Pod::Text>) to output the POD.
  
  =item C<-perlcmd>
  
  By default, Pod::Usage will call L<perldoc> when -verbose >= 2 is
  specified. In case of special or unusual Perl installations,
  this option may be used to supply the path to a L<perl> executable
  which should run L<perldoc>.
  
  =item C<-perldoc> I<path-to-perldoc>
  
  By default, Pod::Usage will call L<perldoc> when -verbose >= 2 is
  specified. In case L<perldoc> is not installed where the L<perl> interpreter
  thinks it is (see L<Config>), the -perldoc option may be used to supply
  the correct path to L<perldoc>.
  
  =item C<-perldocopt> I<string>
  
  By default, Pod::Usage will call L<perldoc> when -verbose >= 2 is specified.
  This option may be used to supply options to L<perldoc>. The
  string may contain several, space-separated options.
  
  =back
  
  =head2 Formatting base class
  
  The default text formatter is L<Pod::Text>. The base class for Pod::Usage can
  be defined by pre-setting C<$Pod::Usage::Formatter> I<before>
  loading Pod::Usage, e.g.:
  
      BEGIN { $Pod::Usage::Formatter = 'Pod::Text::Termcap'; }
      use Pod::Usage qw(pod2usage);
  
  Pod::Usage uses L<Pod::Simple>'s _handle_element_end() method to implement
  the section selection, and in case of verbosity < 2 it down-cases the
  all-caps headings to first capital letter and rest lowercase, and adds
  a colon/newline at the end of the headings, for better readability. Same for
  verbosity = 99.
  
  =head2 Pass-through options
  
  The following options are passed through to the underlying text formatter.
  See the manual pages of these modules for more information.
  
    alt code indent loose margin quotes sentence stderr utf8 width
  
  =head1 DESCRIPTION
  
  B<pod2usage> will print a usage message for the invoking script (using
  its embedded pod documentation) and then exit the script with the
  desired exit status. The usage message printed may have any one of three
  levels of "verboseness": If the verbose level is 0, then only a synopsis
  is printed. If the verbose level is 1, then the synopsis is printed
  along with a description (if present) of the command line options and
  arguments. If the verbose level is 2, then the entire manual page is
  printed.
  
  Unless they are explicitly specified, the default values for the exit
  status, verbose level, and output stream to use are determined as
  follows:
  
  =over 4
  
  =item *
  
  If neither the exit status nor the verbose level is specified, then the
  default is to use an exit status of 2 with a verbose level of 0.
  
  =item *
  
  If an exit status I<is> specified but the verbose level is I<not>, then the
  verbose level will default to 1 if the exit status is less than 2 and
  will default to 0 otherwise.
  
  =item *
  
  If an exit status is I<not> specified but verbose level I<is> given, then
  the exit status will default to 2 if the verbose level is 0 and will
  default to 1 otherwise.
  
  =item *
  
  If the exit status used is less than 2, then output is printed on
  C<STDOUT>.  Otherwise output is printed on C<STDERR>.
  
  =back
  
  Although the above may seem a bit confusing at first, it generally does
  "the right thing" in most situations.  This determination of the default
  values to use is based upon the following typical Unix conventions:
  
  =over 4
  
  =item *
  
  An exit status of 0 implies "success". For example, B<diff(1)> exits
  with a status of 0 if the two files have the same contents.
  
  =item *
  
  An exit status of 1 implies possibly abnormal, but non-defective, program
  termination.  For example, B<grep(1)> exits with a status of 1 if
  it did I<not> find a matching line for the given regular expression.
  
  =item *
  
  An exit status of 2 or more implies a fatal error. For example, B<ls(1)>
  exits with a status of 2 if you specify an illegal (unknown) option on
  the command line.
  
  =item *
  
  Usage messages issued as a result of bad command-line syntax should go
  to C<STDERR>.  However, usage messages issued due to an explicit request
  to print usage (like specifying B<-help> on the command line) should go
  to C<STDOUT>, just in case the user wants to pipe the output to a pager
  (such as B<more(1)>).
  
  =item *
  
  If program usage has been explicitly requested by the user, it is often
  desirable to exit with a status of 1 (as opposed to 0) after issuing
  the user-requested usage message.  It is also desirable to give a
  more verbose description of program usage in this case.
  
  =back
  
  B<pod2usage> does not force the above conventions upon you, but it will
  use them by default if you don't expressly tell it to do otherwise.  The
  ability of B<pod2usage()> to accept a single number or a string makes it
  convenient to use as an innocent looking error message handling function:
  
      use strict;
      use Pod::Usage;
      use Getopt::Long;
  
      ## Parse options
      my %opt;
      GetOptions(\%opt, "help|?", "man", "flag1")  ||  pod2usage(2);
      pod2usage(1)  if ($opt{help});
      pod2usage(-exitval => 0, -verbose => 2)  if ($opt{man});
  
      ## Check for too many filenames
      pod2usage("$0: Too many files given.\n")  if (@ARGV > 1);
  
  Some user's however may feel that the above "economy of expression" is
  not particularly readable nor consistent and may instead choose to do
  something more like the following:
  
      use strict;
      use Pod::Usage qw(pod2usage);
      use Getopt::Long qw(GetOptions);
  
      ## Parse options
      my %opt;
      GetOptions(\%opt, "help|?", "man", "flag1")  ||
        pod2usage(-verbose => 0);
  
      pod2usage(-verbose => 1)  if ($opt{help});
      pod2usage(-verbose => 2)  if ($opt{man});
  
      ## Check for too many filenames
      pod2usage(-verbose => 2, -message => "$0: Too many files given.\n")
        if (@ARGV > 1);
  
  
  As with all things in Perl, I<there's more than one way to do it>, and
  B<pod2usage()> adheres to this philosophy.  If you are interested in
  seeing a number of different ways to invoke B<pod2usage> (although by no
  means exhaustive), please refer to L<"EXAMPLES">.
  
  =head2 Scripts
  
  The Pod::Usage distribution comes with a script pod2usage which offers
  a command line interface to the functionality of Pod::Usage. See
  L<pod2usage>.
  
  
  =head1 EXAMPLES
  
  Each of the following invocations of C<pod2usage()> will print just the
  "SYNOPSIS" section to C<STDERR> and will exit with a status of 2:
  
      pod2usage();
  
      pod2usage(2);
  
      pod2usage(-verbose => 0);
  
      pod2usage(-exitval => 2);
  
      pod2usage({-exitval => 2, -output => \*STDERR});
  
      pod2usage({-verbose => 0, -output  => \*STDERR});
  
      pod2usage(-exitval => 2, -verbose => 0);
  
      pod2usage(-exitval => 2, -verbose => 0, -output => \*STDERR);
  
  Each of the following invocations of C<pod2usage()> will print a message
  of "Syntax error." (followed by a newline) to C<STDERR>, immediately
  followed by just the "SYNOPSIS" section (also printed to C<STDERR>) and
  will exit with a status of 2:
  
      pod2usage("Syntax error.");
  
      pod2usage(-message => "Syntax error.", -verbose => 0);
  
      pod2usage(-msg  => "Syntax error.", -exitval => 2);
  
      pod2usage({-msg => "Syntax error.", -exitval => 2, -output => \*STDERR});
  
      pod2usage({-msg => "Syntax error.", -verbose => 0, -output => \*STDERR});
  
      pod2usage(-msg  => "Syntax error.", -exitval => 2, -verbose => 0);
  
      pod2usage(-message => "Syntax error.",
                -exitval => 2,
                -verbose => 0,
                -output  => \*STDERR);
  
  Each of the following invocations of C<pod2usage()> will print the
  "SYNOPSIS" section and any "OPTIONS" and/or "ARGUMENTS" sections to
  C<STDOUT> and will exit with a status of 1:
  
      pod2usage(1);
  
      pod2usage(-verbose => 1);
  
      pod2usage(-exitval => 1);
  
      pod2usage({-exitval => 1, -output => \*STDOUT});
  
      pod2usage({-verbose => 1, -output => \*STDOUT});
  
      pod2usage(-exitval => 1, -verbose => 1);
  
      pod2usage(-exitval => 1, -verbose => 1, -output => \*STDOUT});
  
  Each of the following invocations of C<pod2usage()> will print the
  entire manual page to C<STDOUT> and will exit with a status of 1:
  
      pod2usage(-verbose  => 2);
  
      pod2usage({-verbose => 2, -output => \*STDOUT});
  
      pod2usage(-exitval  => 1, -verbose => 2);
  
      pod2usage({-exitval => 1, -verbose => 2, -output => \*STDOUT});
  
  =head2 Recommended Use
  
  Most scripts should print some type of usage message to C<STDERR> when a
  command line syntax error is detected. They should also provide an
  option (usually C<-H> or C<-help>) to print a (possibly more verbose)
  usage message to C<STDOUT>. Some scripts may even wish to go so far as to
  provide a means of printing their complete documentation to C<STDOUT>
  (perhaps by allowing a C<-man> option). The following complete example
  uses B<Pod::Usage> in combination with B<Getopt::Long> to do all of these
  things:
  
      use strict;
      use Getopt::Long qw(GetOptions);
      use Pod::Usage qw(pod2usage);
  
      my $man = 0;
      my $help = 0;
      ## Parse options and print usage if there is a syntax error,
      ## or if usage was explicitly requested.
      GetOptions('help|?' => \$help, man => \$man) or pod2usage(2);
      pod2usage(1) if $help;
      pod2usage(-verbose => 2) if $man;
  
      ## If no arguments were given, then allow STDIN to be used only
      ## if it's not connected to a terminal (otherwise print usage)
      pod2usage("$0: No files given.")  if ((@ARGV == 0) && (-t STDIN));
  
      __END__
  
      =head1 NAME
  
      sample - Using GetOpt::Long and Pod::Usage
  
      =head1 SYNOPSIS
  
      sample [options] [file ...]
  
       Options:
         -help            brief help message
         -man             full documentation
  
      =head1 OPTIONS
  
      =over 4
  
      =item B<-help>
  
      Print a brief help message and exits.
  
      =item B<-man>
  
      Prints the manual page and exits.
  
      =back
  
      =head1 DESCRIPTION
  
      B<This program> will read the given input file(s) and do something
      useful with the contents thereof.
  
      =cut
  
  =head1 CAVEATS
  
  By default, B<pod2usage()> will use C<$0> as the path to the pod input
  file.  Unfortunately, not all systems on which Perl runs will set C<$0>
  properly (although if C<$0> is not found, B<pod2usage()> will search
  C<$ENV{PATH}> or else the list specified by the C<-pathlist> option).
  If this is the case for your system, you may need to explicitly specify
  the path to the pod docs for the invoking script using something
  similar to the following:
  
      pod2usage(-exitval => 2, -input => "/path/to/your/pod/docs");
  
  In the pathological case that a script is called via a relative path
  I<and> the script itself changes the current working directory
  (see L<perlfunc/chdir>) I<before> calling pod2usage, Pod::Usage will
  fail even on robust platforms. Don't do that. Or use L<FindBin> to locate
  the script:
  
      use FindBin;
      pod2usage(-input => $FindBin::Bin . "/" . $FindBin::Script);
  
  =head1 SUPPORT
  
  This module is managed in a GitHub repository,
  L<https://github.com/Dual-Life/Pod-Usage> Feel free to fork and contribute, or
  to clone and send patches!
  
  Please use L<https://github.com/Dual-Life/Pod-Usage/issues/new> to file a bug
  report.  The previous ticketing system,
  L<https://rt.cpan.org/Dist/Display.html?Queue=Pod-Usage>, is deprecated for
  this package.
  
  More general questions or discussion about POD should be sent to the
  C<pod-people@perl.org> mail list. Send an empty email to
  C<pod-people-subscribe@perl.org> to subscribe.
  
  =head1 AUTHOR
  
  Marek Rouchal E<lt>marekr@cpan.orgE<gt>
  
  Nicolas R E<lt>nicolas@atoomic.orgE<gt>
  
  Brad Appleton E<lt>bradapp@enteract.comE<gt>
  
  Based on code for B<Pod::Text::pod2text()> written by
  Tom Christiansen E<lt>tchrist@mox.perl.comE<gt>
  
  =head1 LICENSE
  
  Pod::Usage (the distribution) is licensed under the same terms as Perl.
  
  =head1 ACKNOWLEDGMENTS
  
  Nicolas R (ATOOMIC) for setting up the Github repo and modernizing this
  package.
  
  rjbs for refactoring Pod::Usage to not use Pod::Parser any more.
  
  Steven McDougall E<lt>swmcd@world.std.comE<gt> for his help and patience with
  re-writing this manpage.
  
  =head1 SEE ALSO
  
  B<Pod::Usage> is now a standalone distribution, depending on
  L<Pod::Text> which in turn depends on L<Pod::Simple>.
  
  L<Pod::Perldoc>, L<Getopt::Long>, L<Pod::Find>, L<FindBin>,
  L<Pod::Text>, L<Pod::Text::Termcap>, L<Pod::Simple>
  
  =cut
  
POD_USAGE

$fatpacked{"strictures.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STRICTURES';
  package strictures;
  
  use strict;
  use warnings FATAL => 'all';
  
  BEGIN {
    *_PERL_LT_5_8_4 = ("$]" < 5.008004) ? sub(){1} : sub(){0};
    # goto &UNIVERSAL::VERSION usually works on 5.8, but fails on some ARM
    # machines.  Seems to always work on 5.10 though.
    *_CAN_GOTO_VERSION = ("$]" >= 5.010000) ? sub(){1} : sub(){0};
  }
  
  our $VERSION = '2.000006';
  $VERSION =~ tr/_//d;
  
  our @WARNING_CATEGORIES = grep { exists $warnings::Offsets{$_} } qw(
    closure
    chmod
    deprecated
    exiting
    experimental
      experimental::alpha_assertions
      experimental::autoderef
      experimental::bitwise
      experimental::const_attr
      experimental::declared_refs
      experimental::lexical_subs
      experimental::lexical_topic
      experimental::postderef
      experimental::private_use
      experimental::re_strict
      experimental::refaliasing
      experimental::regex_sets
      experimental::script_run
      experimental::signatures
      experimental::smartmatch
      experimental::win32_perlio
    glob
    imprecision
    io
      closed
      exec
      layer
      newline
      pipe
      syscalls
      unopened
    locale
    misc
    missing
    numeric
    once
    overflow
    pack
    portable
    recursion
    redefine
    redundant
    regexp
    severe
      debugging
      inplace
      internal
      malloc
    shadow
    signal
    substr
    syntax
      ambiguous
      bareword
      digit
      illegalproto
      parenthesis
      precedence
      printf
      prototype
      qw
      reserved
      semicolon
    taint
    threads
    uninitialized
    umask
    unpack
    untie
    utf8
      non_unicode
      nonchar
      surrogate
    void
    void_unusual
    y2k
  );
  
  sub VERSION {
    {
      no warnings;
      local $@;
      if (defined $_[1] && eval { &UNIVERSAL::VERSION; 1}) {
        $^H |= 0x20000
          unless _PERL_LT_5_8_4;
        $^H{strictures_enable} = int $_[1];
      }
    }
    _CAN_GOTO_VERSION ? goto &UNIVERSAL::VERSION : &UNIVERSAL::VERSION;
  }
  
  our %extra_load_states;
  
  our $Smells_Like_VCS;
  
  sub import {
    my $class = shift;
    my %opts = @_ == 1 ? %{$_[0]} : @_;
    if (!exists $opts{version}) {
      $opts{version}
        = exists $^H{strictures_enable} ? delete $^H{strictures_enable}
        : int $VERSION;
    }
    $opts{file} = (caller)[1];
    $class->_enable(\%opts);
  }
  
  sub _enable {
    my ($class, $opts) = @_;
    my $version = $opts->{version};
    $version = 'undef'
      if !defined $version;
    my $method = "_enable_$version";
    if (!$class->can($method)) {
      require Carp;
      Carp::croak("Major version specified as $version - not supported!");
    }
    $class->$method($opts);
  }
  
  sub _enable_1 {
    my ($class, $opts) = @_;
    strict->import;
    warnings->import(FATAL => 'all');
  
    if (_want_extra($opts->{file})) {
      _load_extras(qw(indirect multidimensional bareword::filehandles));
      indirect->unimport(':fatal')
        if $extra_load_states{indirect};
      multidimensional->unimport
        if $extra_load_states{multidimensional};
      bareword::filehandles->unimport
        if $extra_load_states{'bareword::filehandles'};
    }
  }
  
  our @V2_NONFATAL = grep { exists $warnings::Offsets{$_} } (
    'exec',         # not safe to catch
    'recursion',    # will be caught by other mechanisms
    'internal',     # not safe to catch
    'malloc',       # not safe to catch
    'newline',      # stat on nonexistent file with a newline in it
    'experimental', # no reason for these to be fatal
    'deprecated',   # unfortunately can't make these fatal
    'portable',     # everything worked fine here, just may not elsewhere
  );
  our @V2_DISABLE = grep { exists $warnings::Offsets{$_} } (
    'once'          # triggers inconsistently, can't be fatalized
  );
  
  sub _enable_2 {
    my ($class, $opts) = @_;
    strict->import;
    warnings->import;
    warnings->import(FATAL => @WARNING_CATEGORIES);
    warnings->unimport(FATAL => @V2_NONFATAL);
    warnings->import(@V2_NONFATAL);
    warnings->unimport(@V2_DISABLE);
  
    if (_want_extra($opts->{file})) {
      _load_extras(qw(indirect multidimensional bareword::filehandles));
      indirect->unimport(':fatal')
        if $extra_load_states{indirect};
      multidimensional->unimport
        if $extra_load_states{multidimensional};
      bareword::filehandles->unimport
        if $extra_load_states{'bareword::filehandles'};
    }
  }
  
  sub _want_extra_env {
    if (exists $ENV{PERL_STRICTURES_EXTRA}) {
      if (_PERL_LT_5_8_4 and $ENV{PERL_STRICTURES_EXTRA}) {
        die 'PERL_STRICTURES_EXTRA checks are not available on perls older'
          . "than 5.8.4: please unset \$ENV{PERL_STRICTURES_EXTRA}\n";
      }
      return $ENV{PERL_STRICTURES_EXTRA} ? 1 : 0;
    }
    return undef;
  }
  
  sub _want_extra {
    my $file = shift;
    my $want_env = _want_extra_env();
    return $want_env
      if defined $want_env;
    return (
      !_PERL_LT_5_8_4
      and $file =~ /^(?:t|xt|lib|blib)[\\\/]/
      and defined $Smells_Like_VCS ? $Smells_Like_VCS
        : ( $Smells_Like_VCS = !!(
          -e '.git' || -e '.svn' || -e '.hg' || -e '.bzr'
          || (-e '../../dist.ini'
            && (-e '../../.git' || -e '../../.svn' || -e '../../.hg' || -e '../../.bzr' ))
        ))
    );
  }
  
  sub _load_extras {
    my @extras = @_;
    my @failed;
    foreach my $mod (@extras) {
      next
        if exists $extra_load_states{$mod};
  
      $extra_load_states{$mod} = eval "require $mod; 1;" or do {
        push @failed, $mod;
  
        #work around 5.8 require bug
        (my $file = $mod) =~ s|::|/|g;
        delete $INC{"${file}.pm"};
      };
    }
  
    if (@failed) {
      my $failed = join ' ', @failed;
      my $extras = join ' ', @extras;
      print STDERR <<EOE;
  strictures.pm extra testing active but couldn't load all modules. Missing were:
  
    $failed
  
  Extra testing is auto-enabled in checkouts only, so if you're the author
  of a strictures-using module you need to run:
  
    cpan $extras
  
  but these modules are not required by your users.
  EOE
    }
  }
  
  1;
  
  __END__
  =head1 NAME
  
  strictures - Turn on strict and make most warnings fatal
  
  =head1 SYNOPSIS
  
    use strictures 2;
  
  is equivalent to
  
    use strict;
    use warnings FATAL => 'all';
    use warnings NONFATAL => qw(
      exec
      recursion
      internal
      malloc
      newline
      experimental
      deprecated
      portable
    );
    no warnings 'once';
  
  except when called from a file which matches:
  
    (caller)[1] =~ /^(?:t|xt|lib|blib)[\\\/]/
  
  and when either C<.git>, C<.svn>, C<.hg>, or C<.bzr> is present in the current
  directory (with the intention of only forcing extra tests on the author side)
  -- or when C<.git>, C<.svn>, C<.hg>, or C<.bzr> is present two directories up
  along with C<dist.ini> (which would indicate we are in a C<dzil test> operation,
  via L<Dist::Zilla>) -- or when the C<PERL_STRICTURES_EXTRA> environment variable
  is set, in which case it also does the equivalent of
  
    no indirect 'fatal';
    no multidimensional;
    no bareword::filehandles;
  
  Note that C<PERL_STRICTURES_EXTRA> may at some point add even more tests, with
  only a minor version increase, but any changes to the effect of C<use
  strictures> in normal mode will involve a major version bump.
  
  If any of the extra testing modules are not present, L<strictures> will
  complain loudly, once, via C<warn()>, and then shut up. But you really
  should consider installing them, they're all great anti-footgun tools.
  
  =head1 DESCRIPTION
  
  I've been writing the equivalent of this module at the top of my code for
  about a year now. I figured it was time to make it shorter.
  
  Things like the importer in C<use Moose> don't help me because they turn
  warnings on but don't make them fatal -- which from my point of view is
  useless because I want an exception to tell me my code isn't warnings-clean.
  
  Any time I see a warning from my code, that indicates a mistake.
  
  Any time my code encounters a mistake, I want a crash -- not spew to STDERR
  and then unknown (and probably undesired) subsequent behaviour.
  
  I also want to ensure that obvious coding mistakes, like indirect object
  syntax (and not so obvious mistakes that cause things to accidentally compile
  as such) get caught, but not at the cost of an XS dependency and not at the
  cost of blowing things up on another machine.
  
  Therefore, L<strictures> turns on additional checking, but only when it thinks
  it's running in a test file in a VCS checkout -- although if this causes
  undesired behaviour this can be overridden by setting the
  C<PERL_STRICTURES_EXTRA> environment variable.
  
  If additional useful author side checks come to mind, I'll add them to the
  C<PERL_STRICTURES_EXTRA> code path only -- this will result in a minor version
  increase (e.g. 1.000000 to 1.001000 (1.1.0) or similar). Any fixes only to the
  mechanism of this code will result in a sub-version increase (e.g. 1.000000 to
  1.000001 (1.0.1)).
  
  =head1 CATEGORY SELECTIONS
  
  strictures does not enable fatal warnings for all categories.
  
  =over 4
  
  =item exec
  
  Includes a warning that can cause your program to continue running
  unintentionally after an internal fork.  Not safe to fatalize.
  
  =item recursion
  
  Infinite recursion will end up overflowing the stack eventually anyway.
  
  =item internal
  
  Triggers deep within perl, in places that are not safe to trap.
  
  =item malloc
  
  Triggers deep within perl, in places that are not safe to trap.
  
  =item newline
  
  Includes a warning for using stat on a valid but suspect filename, ending in a
  newline.
  
  =item experimental
  
  Experimental features are used intentionally.
  
  =item deprecated
  
  Deprecations will inherently be added to in the future in unexpected ways,
  so making them fatal won't be reliable.
  
  =item portable
  
  Doesn't indicate an actual problem with the program, only that it may not
  behave properly if run on a different machine.
  
  =item once
  
  Can't be fatalized.  Also triggers very inconsistently, so we just disable it.
  
  =back
  
  =head1 VERSIONS
  
  Depending on the version of strictures requested, different warnings will be
  enabled.  If no specific version is requested, the current version's behavior
  will be used.  Versions can be requested using perl's standard mechanism:
  
    use strictures 2;
  
  Or, by passing in a C<version> option:
  
    use strictures version => 2;
  
  =head2 VERSION 2
  
  Equivalent to:
  
    use strict;
    use warnings FATAL => 'all';
    use warnings NONFATAL => qw(
      exec
      recursion
      internal
      malloc
      newline
      experimental
      deprecated
      portable
    );
    no warnings 'once';
  
    # and if in dev mode:
    no indirect 'fatal';
    no multidimensional;
    no bareword::filehandles;
  
  Additionally, any warnings created by modules using L<warnings::register> or
  C<warnings::register_categories()> will not be fatalized.
  
  =head2 VERSION 1
  
  Equivalent to:
  
    use strict;
    use warnings FATAL => 'all';
    # and if in dev mode:
    no indirect 'fatal';
    no multidimensional;
    no bareword::filehandles;
  
  =head1 METHODS
  
  =head2 import
  
  This method does the setup work described above in L</DESCRIPTION>.  Optionally
  accepts a C<version> option to request a specific version's behavior.
  
  =head2 VERSION
  
  This method traps the C<< strictures->VERSION(1) >> call produced by a use line
  with a version number on it and does the version check.
  
  =head1 EXTRA TESTING RATIONALE
  
  Every so often, somebody complains that they're deploying via C<git pull>
  and that they don't want L<strictures> to enable itself in this case -- and that
  setting C<PERL_STRICTURES_EXTRA> to 0 isn't acceptable (additional ways to
  disable extra testing would be welcome but the discussion never seems to get
  that far).
  
  In order to allow us to skip a couple of stages and get straight to a
  productive conversation, here's my current rationale for turning the
  extra testing on via a heuristic:
  
  The extra testing is all stuff that only ever blows up at compile time;
  this is intentional. So the oft-raised concern that it's different code being
  tested is only sort of the case -- none of the modules involved affect the
  final optree to my knowledge, so the author gets some additional compile
  time crashes which he/she then fixes, and the rest of the testing is
  completely valid for all environments.
  
  The point of the extra testing -- especially C<no indirect> -- is to catch
  mistakes that newbie users won't even realise are mistakes without
  help. For example,
  
    foo { ... };
  
  where foo is an & prototyped sub that you forgot to import -- this is
  pernicious to track down since all I<seems> fine until it gets called
  and you get a crash. Worse still, you can fail to have imported it due
  to a circular require, at which point you have a load order dependent
  bug which I've seen before now I<only> show up in production due to tiny
  differences between the production and the development environment. I wrote
  L<http://shadow.cat/blog/matt-s-trout/indirect-but-still-fatal/> to explain
  this particular problem before L<strictures> itself existed.
  
  As such, in my experience so far L<strictures>' extra testing has
  I<avoided> production versus development differences, not caused them.
  
  Additionally, L<strictures>' policy is very much "try and provide as much
  protection as possible for newbies -- who won't think about whether there's
  an option to turn on or not" -- so having only the environment variable
  is not sufficient to achieve that (I get to explain that you need to add
  C<use strict> at least once a week on freenode #perl -- newbies sometimes
  completely skip steps because they don't understand that that step
  is important).
  
  I make no claims that the heuristic is perfect -- it's already been evolved
  significantly over time, especially for 1.004 where we changed things to
  ensure it only fires on files in your checkout (rather than L<strictures>-using
  modules you happened to have installed, which was just silly). However, I
  hope the above clarifies why a heuristic approach is not only necessary but
  desirable from a point of view of providing new users with as much safety as
  possible, and will allow any future discussion on the subject to focus on "how
  do we minimise annoyance to people deploying from checkouts intentionally".
  
  =head1 SEE ALSO
  
  =over 4
  
  =item *
  
  L<indirect>
  
  =item *
  
  L<multidimensional>
  
  =item *
  
  L<bareword::filehandles>
  
  =back
  
  =head1 COMMUNITY AND SUPPORT
  
  =head2 IRC channel
  
  irc.perl.org #toolchain
  
  (or bug 'mst' in query on there or freenode)
  
  =head2 Git repository
  
  Gitweb is on http://git.shadowcat.co.uk/ and the clone URL is:
  
    git clone git://git.shadowcat.co.uk/p5sagit/strictures.git
  
  The web interface to the repository is at:
  
    http://git.shadowcat.co.uk/gitweb/gitweb.cgi?p=p5sagit/strictures.git
  
  =head1 AUTHOR
  
  mst - Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
  
  =head1 CONTRIBUTORS
  
  Karen Etheridge (cpan:ETHER) <ether@cpan.org>
  
  Mithaldu - Christian Walde (cpan:MITHALDU) <walde.christian@gmail.com>
  
  haarg - Graham Knop (cpan:HAARG) <haarg@haarg.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2010 the strictures L</AUTHOR> and L</CONTRIBUTORS>
  as listed above.
  
  =head1 LICENSE
  
  This library is free software and may be distributed under the same terms
  as perl itself.
  
  =cut
STRICTURES

$fatpacked{"strictures/extra.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STRICTURES_EXTRA';
  package strictures::extra;
  use strict;
  use warnings FATAL => 'all';
  
  sub import {
    $ENV{PERL_STRICTURES_EXTRA} = 1;
  }
  
  sub unimport {
    $ENV{PERL_STRICTURES_EXTRA} = 0;
  }
  
  1;
  
  __END__
  =head1 NAME
  
  strictures::extra - enable or disable strictures additional checks
  
  =head1 SYNOPSIS
  
    no strictures::extra;
    # will not enable indirect, multidimensional, or bareword filehandle checks
    use strictures;
  
  =head1 DESCRIPTION
  
  Enable or disable strictures additional checks, preventing checks for C<.git>
  or other VCS directories.
  
  Equivalent to setting the C<PERL_STRICTURES_EXTRA> environment variable.
  
  =head1 AUTHORS
  
  See L<strictures> for authors.
  
  =head1 COPYRIGHT AND LICENSE
  
  See L<strictures> for the copyright and license.
  
  =cut
STRICTURES_EXTRA

$fatpacked{"x86_64-linux-gnu-thread-multi/Cwd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CWD';
  package Cwd;
  use strict;
  use Exporter;
  
  
  our $VERSION = '3.75';
  my $xs_version = $VERSION;
  $VERSION =~ tr/_//d;
  
  our @ISA = qw/ Exporter /;
  our @EXPORT = qw(cwd getcwd fastcwd fastgetcwd);
  push @EXPORT, qw(getdcwd) if $^O eq 'MSWin32';
  our @EXPORT_OK = qw(chdir abs_path fast_abs_path realpath fast_realpath);
  
  # sys_cwd may keep the builtin command
  
  # All the functionality of this module may provided by builtins,
  # there is no sense to process the rest of the file.
  # The best choice may be to have this in BEGIN, but how to return from BEGIN?
  
  if ($^O eq 'os2') {
      local $^W = 0;
  
      *cwd                = defined &sys_cwd ? \&sys_cwd : \&_os2_cwd;
      *getcwd             = \&cwd;
      *fastgetcwd         = \&cwd;
      *fastcwd            = \&cwd;
  
      *fast_abs_path      = \&sys_abspath if defined &sys_abspath;
      *abs_path           = \&fast_abs_path;
      *realpath           = \&fast_abs_path;
      *fast_realpath      = \&fast_abs_path;
  
      return 1;
  }
  
  # Need to look up the feature settings on VMS.  The preferred way is to use the
  # VMS::Feature module, but that may not be available to dual life modules.
  
  my $use_vms_feature;
  BEGIN {
      if ($^O eq 'VMS') {
          if (eval { local $SIG{__DIE__};
                     local @INC = @INC;
                     pop @INC if $INC[-1] eq '.';
                     require VMS::Feature; }) {
              $use_vms_feature = 1;
          }
      }
  }
  
  # Need to look up the UNIX report mode.  This may become a dynamic mode
  # in the future.
  sub _vms_unix_rpt {
      my $unix_rpt;
      if ($use_vms_feature) {
          $unix_rpt = VMS::Feature::current("filename_unix_report");
      } else {
          my $env_unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
          $unix_rpt = $env_unix_rpt =~ /^[ET1]/i; 
      }
      return $unix_rpt;
  }
  
  # Need to look up the EFS character set mode.  This may become a dynamic
  # mode in the future.
  sub _vms_efs {
      my $efs;
      if ($use_vms_feature) {
          $efs = VMS::Feature::current("efs_charset");
      } else {
          my $env_efs = $ENV{'DECC$EFS_CHARSET'} || '';
          $efs = $env_efs =~ /^[ET1]/i; 
      }
      return $efs;
  }
  
  
  # If loading the XS stuff doesn't work, we can fall back to pure perl
  if(! defined &getcwd && defined &DynaLoader::boot_DynaLoader) { # skipped on miniperl
      require XSLoader;
      XSLoader::load( __PACKAGE__, $xs_version);
  }
  
  # Big nasty table of function aliases
  my %METHOD_MAP =
    (
     VMS =>
     {
      cwd			=> '_vms_cwd',
      getcwd		=> '_vms_cwd',
      fastcwd		=> '_vms_cwd',
      fastgetcwd		=> '_vms_cwd',
      abs_path		=> '_vms_abs_path',
      fast_abs_path	=> '_vms_abs_path',
     },
  
     MSWin32 =>
     {
      # We assume that &_NT_cwd is defined as an XSUB or in the core.
      cwd			=> '_NT_cwd',
      getcwd		=> '_NT_cwd',
      fastcwd		=> '_NT_cwd',
      fastgetcwd		=> '_NT_cwd',
      abs_path		=> 'fast_abs_path',
      realpath		=> 'fast_abs_path',
     },
  
     dos => 
     {
      cwd			=> '_dos_cwd',
      getcwd		=> '_dos_cwd',
      fastgetcwd		=> '_dos_cwd',
      fastcwd		=> '_dos_cwd',
      abs_path		=> 'fast_abs_path',
     },
  
     # QNX4.  QNX6 has a $os of 'nto'.
     qnx =>
     {
      cwd			=> '_qnx_cwd',
      getcwd		=> '_qnx_cwd',
      fastgetcwd		=> '_qnx_cwd',
      fastcwd		=> '_qnx_cwd',
      abs_path		=> '_qnx_abs_path',
      fast_abs_path	=> '_qnx_abs_path',
     },
  
     cygwin =>
     {
      getcwd		=> 'cwd',
      fastgetcwd		=> 'cwd',
      fastcwd		=> 'cwd',
      abs_path		=> 'fast_abs_path',
      realpath		=> 'fast_abs_path',
     },
  
     amigaos =>
     {
      getcwd              => '_backtick_pwd',
      fastgetcwd          => '_backtick_pwd',
      fastcwd             => '_backtick_pwd',
      abs_path            => 'fast_abs_path',
     }
    );
  
  $METHOD_MAP{NT} = $METHOD_MAP{MSWin32};
  
  
  # Find the pwd command in the expected locations.  We assume these
  # are safe.  This prevents _backtick_pwd() consulting $ENV{PATH}
  # so everything works under taint mode.
  my $pwd_cmd;
  if($^O ne 'MSWin32') {
      foreach my $try ('/bin/pwd',
  		     '/usr/bin/pwd',
  		     '/QOpenSys/bin/pwd', # OS/400 PASE.
  		    ) {
  	if( -x $try ) {
  	    $pwd_cmd = $try;
  	    last;
  	}
      }
  }
  
  # Android has a built-in pwd. Using $pwd_cmd will DTRT if
  # this perl was compiled with -Dd_useshellcmds, which is the
  # default for Android, but the block below is needed for the
  # miniperl running on the host when cross-compiling, and
  # potentially for native builds with -Ud_useshellcmds.
  if ($^O =~ /android/) {
      # If targetsh is executable, then we're either a full
      # perl, or a miniperl for a native build.
      if (-x $Config::Config{targetsh}) {
          $pwd_cmd = "$Config::Config{targetsh} -c pwd"
      }
      else {
          my $sh = $Config::Config{sh} || (-x '/system/bin/sh' ? '/system/bin/sh' : 'sh');
          $pwd_cmd = "$sh -c pwd"
      }
  }
  
  my $found_pwd_cmd = defined($pwd_cmd);
  unless ($pwd_cmd) {
      # Isn't this wrong?  _backtick_pwd() will fail if someone has
      # pwd in their path but it is not /bin/pwd or /usr/bin/pwd?
      # See [perl #16774]. --jhi
      $pwd_cmd = 'pwd';
  }
  
  # Lazy-load Carp
  sub _carp  { require Carp; Carp::carp(@_)  }
  sub _croak { require Carp; Carp::croak(@_) }
  
  # The 'natural and safe form' for UNIX (pwd may be setuid root)
  sub _backtick_pwd {
  
      # Localize %ENV entries in a way that won't create new hash keys.
      # Under AmigaOS we don't want to localize as it stops perl from
      # finding 'sh' in the PATH.
      my @localize = grep exists $ENV{$_}, qw(PATH IFS CDPATH ENV BASH_ENV) if $^O ne "amigaos";
      local @ENV{@localize} if @localize;
      
      my $cwd = `$pwd_cmd`;
      # Belt-and-suspenders in case someone said "undef $/".
      local $/ = "\n";
      # `pwd` may fail e.g. if the disk is full
      chomp($cwd) if defined $cwd;
      $cwd;
  }
  
  # Since some ports may predefine cwd internally (e.g., NT)
  # we take care not to override an existing definition for cwd().
  
  unless ($METHOD_MAP{$^O}{cwd} or defined &cwd) {
      # The pwd command is not available in some chroot(2)'ed environments
      my $sep = $Config::Config{path_sep} || ':';
      my $os = $^O;  # Protect $^O from tainting
  
  
      # Try again to find a pwd, this time searching the whole PATH.
      if (defined $ENV{PATH} and $os ne 'MSWin32') {  # no pwd on Windows
  	my @candidates = split($sep, $ENV{PATH});
  	while (!$found_pwd_cmd and @candidates) {
  	    my $candidate = shift @candidates;
  	    $found_pwd_cmd = 1 if -x "$candidate/pwd";
  	}
      }
  
      if( $found_pwd_cmd )
      {
  	*cwd = \&_backtick_pwd;
      }
      else {
  	*cwd = \&getcwd;
      }
  }
  
  if ($^O eq 'cygwin') {
    # We need to make sure cwd() is called with no args, because it's
    # got an arg-less prototype and will die if args are present.
    local $^W = 0;
    my $orig_cwd = \&cwd;
    *cwd = sub { &$orig_cwd() }
  }
  
  
  # set a reasonable (and very safe) default for fastgetcwd, in case it
  # isn't redefined later (20001212 rspier)
  *fastgetcwd = \&cwd;
  
  # A non-XS version of getcwd() - also used to bootstrap the perl build
  # process, when miniperl is running and no XS loading happens.
  sub _perl_getcwd
  {
      abs_path('.');
  }
  
  # By John Bazik
  #
  # Usage: $cwd = &fastcwd;
  #
  # This is a faster version of getcwd.  It's also more dangerous because
  # you might chdir out of a directory that you can't chdir back into.
      
  sub fastcwd_ {
      my($odev, $oino, $cdev, $cino, $tdev, $tino);
      my(@path, $path);
      local(*DIR);
  
      my($orig_cdev, $orig_cino) = stat('.');
      ($cdev, $cino) = ($orig_cdev, $orig_cino);
      for (;;) {
  	my $direntry;
  	($odev, $oino) = ($cdev, $cino);
  	CORE::chdir('..') || return undef;
  	($cdev, $cino) = stat('.');
  	last if $odev == $cdev && $oino == $cino;
  	opendir(DIR, '.') || return undef;
  	for (;;) {
  	    $direntry = readdir(DIR);
  	    last unless defined $direntry;
  	    next if $direntry eq '.';
  	    next if $direntry eq '..';
  
  	    ($tdev, $tino) = lstat($direntry);
  	    last unless $tdev != $odev || $tino != $oino;
  	}
  	closedir(DIR);
  	return undef unless defined $direntry; # should never happen
  	unshift(@path, $direntry);
      }
      $path = '/' . join('/', @path);
      if ($^O eq 'apollo') { $path = "/".$path; }
      # At this point $path may be tainted (if tainting) and chdir would fail.
      # Untaint it then check that we landed where we started.
      $path =~ /^(.*)\z/s		# untaint
  	&& CORE::chdir($1) or return undef;
      ($cdev, $cino) = stat('.');
      die "Unstable directory path, current directory changed unexpectedly"
  	if $cdev != $orig_cdev || $cino != $orig_cino;
      $path;
  }
  if (not defined &fastcwd) { *fastcwd = \&fastcwd_ }
  
  
  # Keeps track of current working directory in PWD environment var
  # Usage:
  #	use Cwd 'chdir';
  #	chdir $newdir;
  
  my $chdir_init = 0;
  
  sub chdir_init {
      if ($ENV{'PWD'} and $^O ne 'os2' and $^O ne 'dos' and $^O ne 'MSWin32') {
  	my($dd,$di) = stat('.');
  	my($pd,$pi) = stat($ENV{'PWD'});
  	if (!defined $dd or !defined $pd or $di != $pi or $dd != $pd) {
  	    $ENV{'PWD'} = cwd();
  	}
      }
      else {
  	my $wd = cwd();
  	$wd = Win32::GetFullPathName($wd) if $^O eq 'MSWin32';
  	$ENV{'PWD'} = $wd;
      }
      # Strip an automounter prefix (where /tmp_mnt/foo/bar == /foo/bar)
      if ($^O ne 'MSWin32' and $ENV{'PWD'} =~ m|(/[^/]+(/[^/]+/[^/]+))(.*)|s) {
  	my($pd,$pi) = stat($2);
  	my($dd,$di) = stat($1);
  	if (defined $pd and defined $dd and $di == $pi and $dd == $pd) {
  	    $ENV{'PWD'}="$2$3";
  	}
      }
      $chdir_init = 1;
  }
  
  sub chdir {
      my $newdir = @_ ? shift : '';	# allow for no arg (chdir to HOME dir)
      if ($^O eq "cygwin") {
        $newdir =~ s|\A///+|//|;
        $newdir =~ s|(?<=[^/])//+|/|g;
      }
      elsif ($^O ne 'MSWin32') {
        $newdir =~ s|///*|/|g;
      }
      chdir_init() unless $chdir_init;
      my $newpwd;
      if ($^O eq 'MSWin32') {
  	# get the full path name *before* the chdir()
  	$newpwd = Win32::GetFullPathName($newdir);
      }
  
      return 0 unless CORE::chdir $newdir;
  
      if ($^O eq 'VMS') {
  	return $ENV{'PWD'} = $ENV{'DEFAULT'}
      }
      elsif ($^O eq 'MSWin32') {
  	$ENV{'PWD'} = $newpwd;
  	return 1;
      }
  
      if (ref $newdir eq 'GLOB') { # in case a file/dir handle is passed in
  	$ENV{'PWD'} = cwd();
      } elsif ($newdir =~ m#^/#s) {
  	$ENV{'PWD'} = $newdir;
      } else {
  	my @curdir = split(m#/#,$ENV{'PWD'});
  	@curdir = ('') unless @curdir;
  	my $component;
  	foreach $component (split(m#/#, $newdir)) {
  	    next if $component eq '.';
  	    pop(@curdir),next if $component eq '..';
  	    push(@curdir,$component);
  	}
  	$ENV{'PWD'} = join('/',@curdir) || '/';
      }
      1;
  }
  
  
  sub _perl_abs_path
  {
      my $start = @_ ? shift : '.';
      my($dotdots, $cwd, @pst, @cst, $dir, @tst);
  
      unless (@cst = stat( $start ))
      {
  	return undef;
      }
  
      unless (-d _) {
          # Make sure we can be invoked on plain files, not just directories.
          # NOTE that this routine assumes that '/' is the only directory separator.
  	
          my ($dir, $file) = $start =~ m{^(.*)/(.+)$}
  	    or return cwd() . '/' . $start;
  	
  	# Can't use "-l _" here, because the previous stat was a stat(), not an lstat().
  	if (-l $start) {
  	    my $link_target = readlink($start);
  	    die "Can't resolve link $start: $!" unless defined $link_target;
  	    
  	    require File::Spec;
              $link_target = $dir . '/' . $link_target
                  unless File::Spec->file_name_is_absolute($link_target);
  	    
  	    return abs_path($link_target);
  	}
  	
  	return $dir ? abs_path($dir) . "/$file" : "/$file";
      }
  
      $cwd = '';
      $dotdots = $start;
      do
      {
  	$dotdots .= '/..';
  	@pst = @cst;
  	local *PARENT;
  	unless (opendir(PARENT, $dotdots))
  	{
  	    return undef;
  	}
  	unless (@cst = stat($dotdots))
  	{
  	    my $e = $!;
  	    closedir(PARENT);
  	    $! = $e;
  	    return undef;
  	}
  	if ($pst[0] == $cst[0] && $pst[1] == $cst[1])
  	{
  	    $dir = undef;
  	}
  	else
  	{
  	    do
  	    {
  		unless (defined ($dir = readdir(PARENT)))
  	        {
  		    closedir(PARENT);
  		    require Errno;
  		    $! = Errno::ENOENT();
  		    return undef;
  		}
  		$tst[0] = $pst[0]+1 unless (@tst = lstat("$dotdots/$dir"))
  	    }
  	    while ($dir eq '.' || $dir eq '..' || $tst[0] != $pst[0] ||
  		   $tst[1] != $pst[1]);
  	}
  	$cwd = (defined $dir ? "$dir" : "" ) . "/$cwd" ;
  	closedir(PARENT);
      } while (defined $dir);
      chop($cwd) unless $cwd eq '/'; # drop the trailing /
      $cwd;
  }
  
  
  my $Curdir;
  sub fast_abs_path {
      local $ENV{PWD} = $ENV{PWD} || ''; # Guard against clobberage
      my $cwd = getcwd();
      defined $cwd or return undef;
      require File::Spec;
      my $path = @_ ? shift : ($Curdir ||= File::Spec->curdir);
  
      # Detaint else we'll explode in taint mode.  This is safe because
      # we're not doing anything dangerous with it.
      ($path) = $path =~ /(.*)/s;
      ($cwd)  = $cwd  =~ /(.*)/s;
  
      unless (-e $path) {
  	require Errno;
  	$! = Errno::ENOENT();
  	return undef;
      }
  
      unless (-d _) {
          # Make sure we can be invoked on plain files, not just directories.
  	
  	my ($vol, $dir, $file) = File::Spec->splitpath($path);
  	return File::Spec->catfile($cwd, $path) unless length $dir;
  
  	if (-l $path) {
  	    my $link_target = readlink($path);
  	    defined $link_target or return undef;
  	    
  	    $link_target = File::Spec->catpath($vol, $dir, $link_target)
                  unless File::Spec->file_name_is_absolute($link_target);
  	    
  	    return fast_abs_path($link_target);
  	}
  	
  	return $dir eq File::Spec->rootdir
  	  ? File::Spec->catpath($vol, $dir, $file)
  	  : fast_abs_path(File::Spec->catpath($vol, $dir, '')) . '/' . $file;
      }
  
      if (!CORE::chdir($path)) {
  	return undef;
      }
      my $realpath = getcwd();
      if (! ((-d $cwd) && (CORE::chdir($cwd)))) {
   	_croak("Cannot chdir back to $cwd: $!");
      }
      $realpath;
  }
  
  # added function alias to follow principle of least surprise
  # based on previous aliasing.  --tchrist 27-Jan-00
  *fast_realpath = \&fast_abs_path;
  
  
  # --- PORTING SECTION ---
  
  # VMS: $ENV{'DEFAULT'} points to default directory at all times
  # 06-Mar-1996  Charles Bailey  bailey@newman.upenn.edu
  # Note: Use of Cwd::chdir() causes the logical name PWD to be defined
  #   in the process logical name table as the default device and directory
  #   seen by Perl. This may not be the same as the default device
  #   and directory seen by DCL after Perl exits, since the effects
  #   the CRTL chdir() function persist only until Perl exits.
  
  sub _vms_cwd {
      return $ENV{'DEFAULT'};
  }
  
  sub _vms_abs_path {
      return $ENV{'DEFAULT'} unless @_;
      my $path = shift;
  
      my $efs = _vms_efs;
      my $unix_rpt = _vms_unix_rpt;
  
      if (defined &VMS::Filespec::vmsrealpath) {
          my $path_unix = 0;
          my $path_vms = 0;
  
          $path_unix = 1 if ($path =~ m#(?<=\^)/#);
          $path_unix = 1 if ($path =~ /^\.\.?$/);
          $path_vms = 1 if ($path =~ m#[\[<\]]#);
          $path_vms = 1 if ($path =~ /^--?$/);
  
          my $unix_mode = $path_unix;
          if ($efs) {
              # In case of a tie, the Unix report mode decides.
              if ($path_vms == $path_unix) {
                  $unix_mode = $unix_rpt;
              } else {
                  $unix_mode = 0 if $path_vms;
              }
          }
  
          if ($unix_mode) {
              # Unix format
              return VMS::Filespec::unixrealpath($path);
          }
  
  	# VMS format
  
  	my $new_path = VMS::Filespec::vmsrealpath($path);
  
  	# Perl expects directories to be in directory format
  	$new_path = VMS::Filespec::pathify($new_path) if -d $path;
  	return $new_path;
      }
  
      # Fallback to older algorithm if correct ones are not
      # available.
  
      if (-l $path) {
          my $link_target = readlink($path);
          die "Can't resolve link $path: $!" unless defined $link_target;
  
          return _vms_abs_path($link_target);
      }
  
      # may need to turn foo.dir into [.foo]
      my $pathified = VMS::Filespec::pathify($path);
      $path = $pathified if defined $pathified;
  	
      return VMS::Filespec::rmsexpand($path);
  }
  
  sub _os2_cwd {
      my $pwd = `cmd /c cd`;
      chomp $pwd;
      $pwd =~ s:\\:/:g ;
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  sub _win32_cwd_simple {
      my $pwd = `cd`;
      chomp $pwd;
      $pwd =~ s:\\:/:g ;
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  sub _win32_cwd {
      my $pwd;
      $pwd = Win32::GetCwd();
      $pwd =~ s:\\:/:g ;
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  *_NT_cwd = defined &Win32::GetCwd ? \&_win32_cwd : \&_win32_cwd_simple;
  
  sub _dos_cwd {
      my $pwd;
      if (!defined &Dos::GetCwd) {
          chomp($pwd = `command /c cd`);
          $pwd =~ s:\\:/:g ;
      } else {
          $pwd = Dos::GetCwd();
      }
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  sub _qnx_cwd {
  	local $ENV{PATH} = '';
  	local $ENV{CDPATH} = '';
  	local $ENV{ENV} = '';
      my $pwd = `/usr/bin/fullpath -t`;
      chomp $pwd;
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  sub _qnx_abs_path {
  	local $ENV{PATH} = '';
  	local $ENV{CDPATH} = '';
  	local $ENV{ENV} = '';
      my $path = @_ ? shift : '.';
      local *REALPATH;
  
      defined( open(REALPATH, '-|') || exec '/usr/bin/fullpath', '-t', $path ) or
        die "Can't open /usr/bin/fullpath: $!";
      my $realpath = <REALPATH>;
      close REALPATH;
      chomp $realpath;
      return $realpath;
  }
  
  # Now that all the base-level functions are set up, alias the
  # user-level functions to the right places
  
  if (exists $METHOD_MAP{$^O}) {
    my $map = $METHOD_MAP{$^O};
    foreach my $name (keys %$map) {
      local $^W = 0;  # assignments trigger 'subroutine redefined' warning
      no strict 'refs';
      *{$name} = \&{$map->{$name}};
    }
  }
  
  # In case the XS version doesn't load.
  *abs_path = \&_perl_abs_path unless defined &abs_path;
  *getcwd = \&_perl_getcwd unless defined &getcwd;
  
  # added function alias for those of us more
  # used to the libc function.  --tchrist 27-Jan-00
  *realpath = \&abs_path;
  
  1;
  __END__
  
  =head1 NAME
  
  Cwd - get pathname of current working directory
  
  =head1 SYNOPSIS
  
      use Cwd;
      my $dir = getcwd;
  
      use Cwd 'abs_path';
      my $abs_path = abs_path($file);
  
  =head1 DESCRIPTION
  
  This module provides functions for determining the pathname of the
  current working directory.  It is recommended that getcwd (or another
  *cwd() function) be used in I<all> code to ensure portability.
  
  By default, it exports the functions cwd(), getcwd(), fastcwd(), and
  fastgetcwd() (and, on Win32, getdcwd()) into the caller's namespace.  
  
  
  =head2 getcwd and friends
  
  Each of these functions are called without arguments and return the
  absolute path of the current working directory.
  
  =over 4
  
  =item getcwd
  
      my $cwd = getcwd();
  
  Returns the current working directory.  On error returns C<undef>,
  with C<$!> set to indicate the error.
  
  Exposes the POSIX function getcwd(3) or re-implements it if it's not
  available.
  
  =item cwd
  
      my $cwd = cwd();
  
  The cwd() is the most natural form for the current architecture.  For
  most systems it is identical to `pwd` (but without the trailing line
  terminator).
  
  =item fastcwd
  
      my $cwd = fastcwd();
  
  A more dangerous version of getcwd(), but potentially faster.
  
  It might conceivably chdir() you out of a directory that it can't
  chdir() you back into.  If fastcwd encounters a problem it will return
  undef but will probably leave you in a different directory.  For a
  measure of extra security, if everything appears to have worked, the
  fastcwd() function will check that it leaves you in the same directory
  that it started in.  If it has changed it will C<die> with the message
  "Unstable directory path, current directory changed
  unexpectedly".  That should never happen.
  
  =item fastgetcwd
  
    my $cwd = fastgetcwd();
  
  The fastgetcwd() function is provided as a synonym for cwd().
  
  =item getdcwd
  
      my $cwd = getdcwd();
      my $cwd = getdcwd('C:');
  
  The getdcwd() function is also provided on Win32 to get the current working
  directory on the specified drive, since Windows maintains a separate current
  working directory for each drive.  If no drive is specified then the current
  drive is assumed.
  
  This function simply calls the Microsoft C library _getdcwd() function.
  
  =back
  
  
  =head2 abs_path and friends
  
  These functions are exported only on request.  They each take a single
  argument and return the absolute pathname for it.  If no argument is
  given they'll use the current working directory.
  
  =over 4
  
  =item abs_path
  
    my $abs_path = abs_path($file);
  
  Uses the same algorithm as getcwd().  Symbolic links and relative-path
  components ("." and "..") are resolved to return the canonical
  pathname, just like realpath(3).  On error returns C<undef>, with C<$!>
  set to indicate the error.
  
  =item realpath
  
    my $abs_path = realpath($file);
  
  A synonym for abs_path().
  
  =item fast_abs_path
  
    my $abs_path = fast_abs_path($file);
  
  A more dangerous, but potentially faster version of abs_path.
  
  =back
  
  =head2 $ENV{PWD}
  
  If you ask to override your chdir() built-in function, 
  
    use Cwd qw(chdir);
  
  then your PWD environment variable will be kept up to date.  Note that
  it will only be kept up to date if all packages which use chdir import
  it from Cwd.
  
  
  =head1 NOTES
  
  =over 4
  
  =item *
  
  Since the path separators are different on some operating systems ('/'
  on Unix, ':' on MacPerl, etc...) we recommend you use the File::Spec
  modules wherever portability is a concern.
  
  =item *
  
  Actually, on Mac OS, the C<getcwd()>, C<fastgetcwd()> and C<fastcwd()>
  functions are all aliases for the C<cwd()> function, which, on Mac OS,
  calls `pwd`.  Likewise, the C<abs_path()> function is an alias for
  C<fast_abs_path()>.
  
  =back
  
  =head1 AUTHOR
  
  Originally by the perl5-porters.
  
  Maintained by Ken Williams <KWILLIAMS@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  Portions of the C code in this library are copyright (c) 1994 by the
  Regents of the University of California.  All rights reserved.  The
  license on this code is compatible with the licensing of the rest of
  the distribution - please see the source code in F<Cwd.xs> for the
  details.
  
  =head1 SEE ALSO
  
  L<File::chdir>
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_CWD

$fatpacked{"x86_64-linux-gnu-thread-multi/Encode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_ENCODE';
  #
  # $Id: Encode.pm,v 3.19 2022/08/04 04:42:30 dankogai Exp $
  #
  package Encode;
  use strict;
  use warnings;
  use constant DEBUG => !!$ENV{PERL_ENCODE_DEBUG};
  our $VERSION;
  BEGIN {
      $VERSION = sprintf "%d.%02d", q$Revision: 3.19 $ =~ /(\d+)/g;
      require XSLoader;
      XSLoader::load( __PACKAGE__, $VERSION );
  }
  
  use Exporter 5.57 'import';
  
  use Carp ();
  our @CARP_NOT = qw(Encode::Encoder);
  
  # Public, encouraged API is exported by default
  
  our @EXPORT = qw(
    decode  decode_utf8  encode  encode_utf8 str2bytes bytes2str
    encodings  find_encoding find_mime_encoding clone_encoding
  );
  our @FB_FLAGS = qw(
    DIE_ON_ERR WARN_ON_ERR RETURN_ON_ERR LEAVE_SRC
    PERLQQ HTMLCREF XMLCREF STOP_AT_PARTIAL
  );
  our @FB_CONSTS = qw(
    FB_DEFAULT FB_CROAK FB_QUIET FB_WARN
    FB_PERLQQ FB_HTMLCREF FB_XMLCREF
  );
  our @EXPORT_OK = (
      qw(
        _utf8_off _utf8_on define_encoding from_to is_16bit is_8bit
        is_utf8 perlio_ok resolve_alias utf8_downgrade utf8_upgrade
        ),
      @FB_FLAGS, @FB_CONSTS,
  );
  
  our %EXPORT_TAGS = (
      all          => [ @EXPORT,    @EXPORT_OK ],
      default      => [ @EXPORT ],
      fallbacks    => [ @FB_CONSTS ],
      fallback_all => [ @FB_CONSTS, @FB_FLAGS ],
  );
  
  # Documentation moved after __END__ for speed - NI-S
  
  our $ON_EBCDIC = ( ord("A") == 193 );
  
  use Encode::Alias ();
  use Encode::MIME::Name;
  
  use Storable;
  
  # Make a %Encoding package variable to allow a certain amount of cheating
  our %Encoding;
  our %ExtModule;
  require Encode::Config;
  #  See
  #  https://bugzilla.redhat.com/show_bug.cgi?id=435505#c2
  #  to find why sig handlers inside eval{} are disabled.
  eval {
      local $SIG{__DIE__};
      local $SIG{__WARN__};
      local @INC = @INC;
      pop @INC if @INC && $INC[-1] eq '.';
      require Encode::ConfigLocal;
  };
  
  sub encodings {
      my %enc;
      my $arg  = $_[1] || '';
      if ( $arg eq ":all" ) {
          %enc = ( %Encoding, %ExtModule );
      }
      else {
          %enc = %Encoding;
          for my $mod ( map { m/::/ ? $_ : "Encode::$_" } @_ ) {
              DEBUG and warn $mod;
              for my $enc ( keys %ExtModule ) {
                  $ExtModule{$enc} eq $mod and $enc{$enc} = $mod;
              }
          }
      }
      return sort { lc $a cmp lc $b }
        grep      { !/^(?:Internal|Unicode|Guess)$/o } keys %enc;
  }
  
  sub perlio_ok {
      my $obj = ref( $_[0] ) ? $_[0] : find_encoding( $_[0] );
      $obj->can("perlio_ok") and return $obj->perlio_ok();
      return 0;    # safety net
  }
  
  sub define_encoding {
      my $obj  = shift;
      my $name = shift;
      $Encoding{$name} = $obj;
      my $lc = lc($name);
      define_alias( $lc => $obj ) unless $lc eq $name;
      while (@_) {
          my $alias = shift;
          define_alias( $alias, $obj );
      }
      my $class = ref($obj);
      push @Encode::CARP_NOT, $class unless grep { $_ eq $class } @Encode::CARP_NOT;
      push @Encode::Encoding::CARP_NOT, $class unless grep { $_ eq $class } @Encode::Encoding::CARP_NOT;
      return $obj;
  }
  
  sub getEncoding {
      my ( $class, $name, $skip_external ) = @_;
  
      defined($name) or return;
  
      $name =~ s/\s+//g; # https://rt.cpan.org/Ticket/Display.html?id=65796
  
      ref($name) && $name->can('renew') and return $name;
      exists $Encoding{$name} and return $Encoding{$name};
      my $lc = lc $name;
      exists $Encoding{$lc} and return $Encoding{$lc};
  
      my $oc = $class->find_alias($name);
      defined($oc) and return $oc;
      $lc ne $name and $oc = $class->find_alias($lc);
      defined($oc) and return $oc;
  
      unless ($skip_external) {
          if ( my $mod = $ExtModule{$name} || $ExtModule{$lc} ) {
              $mod =~ s,::,/,g;
              $mod .= '.pm';
              eval { require $mod; };
              exists $Encoding{$name} and return $Encoding{$name};
          }
      }
      return;
  }
  
  # HACK: These two functions must be defined in Encode and because of
  # cyclic dependency between Encode and Encode::Alias, Exporter does not work
  sub find_alias {
      goto &Encode::Alias::find_alias;
  }
  sub define_alias {
      goto &Encode::Alias::define_alias;
  }
  
  sub find_encoding($;$) {
      my ( $name, $skip_external ) = @_;
      return __PACKAGE__->getEncoding( $name, $skip_external );
  }
  
  sub find_mime_encoding($;$) {
      my ( $mime_name, $skip_external ) = @_;
      my $name = Encode::MIME::Name::get_encode_name( $mime_name );
      return find_encoding( $name, $skip_external );
  }
  
  sub resolve_alias($) {
      my $obj = find_encoding(shift);
      defined $obj and return $obj->name;
      return;
  }
  
  sub clone_encoding($) {
      my $obj = find_encoding(shift);
      ref $obj or return;
      return Storable::dclone($obj);
  }
  
  onBOOT;
  
  if ($ON_EBCDIC) {
      package Encode::UTF_EBCDIC;
      use parent 'Encode::Encoding';
      my $obj = bless { Name => "UTF_EBCDIC" } => "Encode::UTF_EBCDIC";
      Encode::define_encoding($obj, 'Unicode');
      sub decode {
          my ( undef, $str, $chk ) = @_;
          my $res = '';
          for ( my $i = 0 ; $i < length($str) ; $i++ ) {
              $res .=
                chr(
                  utf8::unicode_to_native( ord( substr( $str, $i, 1 ) ) )
                );
          }
          $_[1] = '' if $chk;
          return $res;
      }
      sub encode {
          my ( undef, $str, $chk ) = @_;
          my $res = '';
          for ( my $i = 0 ; $i < length($str) ; $i++ ) {
              $res .=
                chr(
                  utf8::native_to_unicode( ord( substr( $str, $i, 1 ) ) )
                );
          }
          $_[1] = '' if $chk;
          return $res;
      }
  }
  
  {
      # https://rt.cpan.org/Public/Bug/Display.html?id=103253
      package Encode::XS;
      use parent 'Encode::Encoding';
  }
  
  {
      package Encode::utf8;
      use parent 'Encode::Encoding';
      my %obj = (
          'utf8'         => { Name => 'utf8' },
          'utf-8-strict' => { Name => 'utf-8-strict', strict_utf8 => 1 }
      );
      for ( keys %obj ) {
          bless $obj{$_} => __PACKAGE__;
          Encode::define_encoding( $obj{$_} => $_ );
      }
      sub cat_decode {
          # ($obj, $dst, $src, $pos, $trm, $chk)
          # currently ignores $chk
          my ( undef, undef, undef, $pos, $trm ) = @_;
          my ( $rdst, $rsrc, $rpos ) = \@_[ 1, 2, 3 ];
          use bytes;
          if ( ( my $npos = index( $$rsrc, $trm, $pos ) ) >= 0 ) {
              $$rdst .=
                substr( $$rsrc, $pos, $npos - $pos + length($trm) );
              $$rpos = $npos + length($trm);
              return 1;
          }
          $$rdst .= substr( $$rsrc, $pos );
          $$rpos = length($$rsrc);
          return '';
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Encode - character encodings in Perl
  
  =head1 SYNOPSIS
  
      use Encode qw(decode encode);
      $characters = decode('UTF-8', $octets,     Encode::FB_CROAK);
      $octets     = encode('UTF-8', $characters, Encode::FB_CROAK);
  
  =head2 Table of Contents
  
  Encode consists of a collection of modules whose details are too extensive
  to fit in one document.  This one itself explains the top-level APIs
  and general topics at a glance.  For other topics and more details,
  see the documentation for these modules:
  
  =over 2
  
  =item L<Encode::Alias> - Alias definitions to encodings
  
  =item L<Encode::Encoding> - Encode Implementation Base Class
  
  =item L<Encode::Supported> - List of Supported Encodings
  
  =item L<Encode::CN> - Simplified Chinese Encodings
  
  =item L<Encode::JP> - Japanese Encodings
  
  =item L<Encode::KR> - Korean Encodings
  
  =item L<Encode::TW> - Traditional Chinese Encodings
  
  =back
  
  =head1 DESCRIPTION
  
  The C<Encode> module provides the interface between Perl strings
  and the rest of the system.  Perl strings are sequences of
  I<characters>.
  
  The repertoire of characters that Perl can represent is a superset of those
  defined by the Unicode Consortium. On most platforms the ordinal
  values of a character as returned by C<ord(I<S>)> is the I<Unicode
  codepoint> for that character. The exceptions are platforms where
  the legacy encoding is some variant of EBCDIC rather than a superset
  of ASCII; see L<perlebcdic>.
  
  During recent history, data is moved around a computer in 8-bit chunks,
  often called "bytes" but also known as "octets" in standards documents.
  Perl is widely used to manipulate data of many types: not only strings of
  characters representing human or computer languages, but also "binary"
  data, being the machine's representation of numbers, pixels in an image, or
  just about anything.
  
  When Perl is processing "binary data", the programmer wants Perl to
  process "sequences of bytes". This is not a problem for Perl: because a
  byte has 256 possible values, it easily fits in Perl's much larger
  "logical character".
  
  This document mostly explains the I<how>. L<perlunitut> and L<perlunifaq>
  explain the I<why>.
  
  =head2 TERMINOLOGY
  
  =head3 character
  
  A character in the range 0 .. 2**32-1 (or more);
  what Perl's strings are made of.
  
  =head3 byte
  
  A character in the range 0..255;
  a special case of a Perl character.
  
  =head3 octet
  
  8 bits of data, with ordinal values 0..255;
  term for bytes passed to or from a non-Perl context, such as a disk file,
  standard I/O stream, database, command-line argument, environment variable,
  socket etc.
  
  =head1 THE PERL ENCODING API
  
  =head2 Basic methods
  
  =head3 encode
  
    $octets  = encode(ENCODING, STRING[, CHECK])
  
  Encodes the scalar value I<STRING> from Perl's internal form into
  I<ENCODING> and returns a sequence of octets.  I<ENCODING> can be either a
  canonical name or an alias.  For encoding names and aliases, see
  L</"Defining Aliases">.  For CHECK, see L</"Handling Malformed Data">.
  
  B<CAVEAT>: the input scalar I<STRING> might be modified in-place depending
  on what is set in CHECK. See L</LEAVE_SRC> if you want your inputs to be
  left unchanged.
  
  For example, to convert a string from Perl's internal format into
  ISO-8859-1, also known as Latin1:
  
    $octets = encode("iso-8859-1", $string);
  
  B<CAVEAT>: When you run C<$octets = encode("UTF-8", $string)>, then
  $octets I<might not be equal to> $string.  Though both contain the
  same data, the UTF8 flag for $octets is I<always> off.  When you
  encode anything, the UTF8 flag on the result is always off, even when it
  contains a completely valid UTF-8 string. See L</"The UTF8 flag"> below.
  
  If the $string is C<undef>, then C<undef> is returned.
  
  C<str2bytes> may be used as an alias for C<encode>.
  
  =head3 decode
  
    $string = decode(ENCODING, OCTETS[, CHECK])
  
  This function returns the string that results from decoding the scalar
  value I<OCTETS>, assumed to be a sequence of octets in I<ENCODING>, into
  Perl's internal form.  As with encode(),
  I<ENCODING> can be either a canonical name or an alias. For encoding names
  and aliases, see L</"Defining Aliases">; for I<CHECK>, see L</"Handling
  Malformed Data">.
  
  B<CAVEAT>: the input scalar I<OCTETS> might be modified in-place depending
  on what is set in CHECK. See L</LEAVE_SRC> if you want your inputs to be
  left unchanged.
  
  For example, to convert ISO-8859-1 data into a string in Perl's
  internal format:
  
    $string = decode("iso-8859-1", $octets);
  
  B<CAVEAT>: When you run C<$string = decode("UTF-8", $octets)>, then $string
  I<might not be equal to> $octets.  Though both contain the same data, the
  UTF8 flag for $string is on.  See L</"The UTF8 flag">
  below.
  
  If the $string is C<undef>, then C<undef> is returned.
  
  C<bytes2str> may be used as an alias for C<decode>.
  
  =head3 find_encoding
  
    [$obj =] find_encoding(ENCODING)
  
  Returns the I<encoding object> corresponding to I<ENCODING>.  Returns
  C<undef> if no matching I<ENCODING> is find.  The returned object is
  what does the actual encoding or decoding.
  
    $string = decode($name, $bytes);
  
  is in fact
  
      $string = do {
          $obj = find_encoding($name);
          croak qq(encoding "$name" not found) unless ref $obj;
          $obj->decode($bytes);
      };
  
  with more error checking.
  
  You can therefore save time by reusing this object as follows;
  
      my $enc = find_encoding("iso-8859-1");
      while(<>) {
          my $string = $enc->decode($_);
          ... # now do something with $string;
      }
  
  Besides L</decode> and L</encode>, other methods are
  available as well.  For instance, C<name()> returns the canonical
  name of the encoding object.
  
    find_encoding("latin1")->name; # iso-8859-1
  
  See L<Encode::Encoding> for details.
  
  =head3 find_mime_encoding
  
    [$obj =] find_mime_encoding(MIME_ENCODING)
  
  Returns the I<encoding object> corresponding to I<MIME_ENCODING>.  Acts
  same as C<find_encoding()> but C<mime_name()> of returned object must
  match to I<MIME_ENCODING>.  So as opposite of C<find_encoding()>
  canonical names and aliases are not used when searching for object.
  
      find_mime_encoding("utf8"); # returns undef because "utf8" is not valid I<MIME_ENCODING>
      find_mime_encoding("utf-8"); # returns encode object "utf-8-strict"
      find_mime_encoding("UTF-8"); # same as "utf-8" because I<MIME_ENCODING> is case insensitive
      find_mime_encoding("utf-8-strict"); returns undef because "utf-8-strict" is not valid I<MIME_ENCODING>
  
  =head3 from_to
  
    [$length =] from_to($octets, FROM_ENC, TO_ENC [, CHECK])
  
  Converts I<in-place> data between two encodings. The data in $octets
  must be encoded as octets and I<not> as characters in Perl's internal
  format. For example, to convert ISO-8859-1 data into Microsoft's CP1250
  encoding:
  
    from_to($octets, "iso-8859-1", "cp1250");
  
  and to convert it back:
  
    from_to($octets, "cp1250", "iso-8859-1");
  
  Because the conversion happens in place, the data to be
  converted cannot be a string constant: it must be a scalar variable.
  
  C<from_to()> returns the length of the converted string in octets on success,
  and C<undef> on error.
  
  B<CAVEAT>: The following operations may look the same, but are not:
  
    from_to($data, "iso-8859-1", "UTF-8"); #1
    $data = decode("iso-8859-1", $data);  #2
  
  Both #1 and #2 make $data consist of a completely valid UTF-8 string,
  but only #2 turns the UTF8 flag on.  #1 is equivalent to:
  
    $data = encode("UTF-8", decode("iso-8859-1", $data));
  
  See L</"The UTF8 flag"> below.
  
  Also note that:
  
    from_to($octets, $from, $to, $check);
  
  is equivalent to:
  
    $octets = encode($to, decode($from, $octets), $check);
  
  Yes, it does I<not> respect the $check during decoding.  It is
  deliberately done that way.  If you need minute control, use C<decode>
  followed by C<encode> as follows:
  
    $octets = encode($to, decode($from, $octets, $check_from), $check_to);
  
  =head3 encode_utf8
  
    $octets = encode_utf8($string);
  
  B<WARNING>: L<This function can produce invalid UTF-8!|/UTF-8 vs. utf8 vs. UTF8>
  Do not use it for data exchange.
  Unless you want Perl's older "lax" mode, prefer
  C<$octets = encode("UTF-8", $string)>.
  
  Equivalent to C<$octets = encode("utf8", $string)>.  The characters in
  $string are encoded in Perl's internal format, and the result is returned
  as a sequence of octets.  Because all possible characters in Perl have a
  (loose, not strict) utf8 representation, this function cannot fail.
  
  =head3 decode_utf8
  
    $string = decode_utf8($octets [, CHECK]);
  
  B<WARNING>: L<This function accepts invalid UTF-8!|/UTF-8 vs. utf8 vs. UTF8>
  Do not use it for data exchange.
  Unless you want Perl's older "lax" mode, prefer
  C<$string = decode("UTF-8", $octets [, CHECK])>.
  
  Equivalent to C<$string = decode("utf8", $octets [, CHECK])>.
  The sequence of octets represented by $octets is decoded
  from (loose, not strict) utf8 into a sequence of logical characters.
  Because not all sequences of octets are valid not strict utf8,
  it is quite possible for this function to fail.
  For CHECK, see L</"Handling Malformed Data">.
  
  B<CAVEAT>: the input I<$octets> might be modified in-place depending on
  what is set in CHECK. See L</LEAVE_SRC> if you want your inputs to be
  left unchanged.
  
  =head2 Listing available encodings
  
    use Encode;
    @list = Encode->encodings();
  
  Returns a list of canonical names of available encodings that have already
  been loaded.  To get a list of all available encodings including those that
  have not yet been loaded, say:
  
    @all_encodings = Encode->encodings(":all");
  
  Or you can give the name of a specific module:
  
    @with_jp = Encode->encodings("Encode::JP");
  
  When "C<::>" is not in the name, "C<Encode::>" is assumed.
  
    @ebcdic = Encode->encodings("EBCDIC");
  
  To find out in detail which encodings are supported by this package,
  see L<Encode::Supported>.
  
  =head2 Defining Aliases
  
  To add a new alias to a given encoding, use:
  
    use Encode;
    use Encode::Alias;
    define_alias(NEWNAME => ENCODING);
  
  After that, I<NEWNAME> can be used as an alias for I<ENCODING>.
  I<ENCODING> may be either the name of an encoding or an
  I<encoding object>.
  
  Before you do that, first make sure the alias is nonexistent using
  C<resolve_alias()>, which returns the canonical name thereof.
  For example:
  
    Encode::resolve_alias("latin1") eq "iso-8859-1" # true
    Encode::resolve_alias("iso-8859-12")   # false; nonexistent
    Encode::resolve_alias($name) eq $name  # true if $name is canonical
  
  C<resolve_alias()> does not need C<use Encode::Alias>; it can be
  imported via C<use Encode qw(resolve_alias)>.
  
  See L<Encode::Alias> for details.
  
  =head2 Finding IANA Character Set Registry names
  
  The canonical name of a given encoding does not necessarily agree with
  IANA Character Set Registry, commonly seen as C<< Content-Type:
  text/plain; charset=I<WHATEVER> >>.  For most cases, the canonical name
  works, but sometimes it does not, most notably with "utf-8-strict".
  
  As of C<Encode> version 2.21, a new method C<mime_name()> is therefore added.
  
    use Encode;
    my $enc = find_encoding("UTF-8");
    warn $enc->name;      # utf-8-strict
    warn $enc->mime_name; # UTF-8
  
  See also:  L<Encode::Encoding>
  
  =head1 Encoding via PerlIO
  
  If your perl supports C<PerlIO> (which is the default), you can use a
  C<PerlIO> layer to decode and encode directly via a filehandle.  The
  following two examples are fully identical in functionality:
  
    ### Version 1 via PerlIO
      open(INPUT,  "< :encoding(shiftjis)", $infile)
          || die "Can't open < $infile for reading: $!";
      open(OUTPUT, "> :encoding(euc-jp)",  $outfile)
          || die "Can't open > $output for writing: $!";
      while (<INPUT>) {   # auto decodes $_
          print OUTPUT;   # auto encodes $_
      }
      close(INPUT)   || die "can't close $infile: $!";
      close(OUTPUT)  || die "can't close $outfile: $!";
  
    ### Version 2 via from_to()
      open(INPUT,  "< :raw", $infile)
          || die "Can't open < $infile for reading: $!";
      open(OUTPUT, "> :raw",  $outfile)
          || die "Can't open > $output for writing: $!";
  
      while (<INPUT>) {
          from_to($_, "shiftjis", "euc-jp", 1);  # switch encoding
          print OUTPUT;   # emit raw (but properly encoded) data
      }
      close(INPUT)   || die "can't close $infile: $!";
      close(OUTPUT)  || die "can't close $outfile: $!";
  
  In the first version above, you let the appropriate encoding layer
  handle the conversion.  In the second, you explicitly translate
  from one encoding to the other.
  
  Unfortunately, it may be that encodings are not C<PerlIO>-savvy.  You can check
  to see whether your encoding is supported by C<PerlIO> by invoking the
  C<perlio_ok> method on it:
  
    Encode::perlio_ok("hz");             # false
    find_encoding("euc-cn")->perlio_ok;  # true wherever PerlIO is available
  
    use Encode qw(perlio_ok);            # imported upon request
    perlio_ok("euc-jp")
  
  Fortunately, all encodings that come with C<Encode> core are C<PerlIO>-savvy
  except for C<hz> and C<ISO-2022-kr>.  For the gory details, see
  L<Encode::Encoding> and L<Encode::PerlIO>.
  
  =head1 Handling Malformed Data
  
  The optional I<CHECK> argument tells C<Encode> what to do when
  encountering malformed data.  Without I<CHECK>, C<Encode::FB_DEFAULT>
  (== 0) is assumed.
  
  As of version 2.12, C<Encode> supports coderef values for C<CHECK>;
  see below.
  
  B<NOTE:> Not all encodings support this feature.
  Some encodings ignore the I<CHECK> argument.  For example,
  L<Encode::Unicode> ignores I<CHECK> and it always croaks on error.
  
  =head2 List of I<CHECK> values
  
  =head3 FB_DEFAULT
  
    I<CHECK> = Encode::FB_DEFAULT ( == 0)
  
  If I<CHECK> is 0, encoding and decoding replace any malformed character
  with a I<substitution character>.  When you encode, I<SUBCHAR> is used.
  When you decode, the Unicode REPLACEMENT CHARACTER, code point U+FFFD, is
  used.  If the data is supposed to be UTF-8, an optional lexical warning of
  warning category C<"utf8"> is given.
  
  =head3 FB_CROAK
  
    I<CHECK> = Encode::FB_CROAK ( == 1)
  
  If I<CHECK> is 1, methods immediately die with an error
  message.  Therefore, when I<CHECK> is 1, you should trap
  exceptions with C<eval{}>, unless you really want to let it C<die>.
  
  =head3 FB_QUIET
  
    I<CHECK> = Encode::FB_QUIET
  
  If I<CHECK> is set to C<Encode::FB_QUIET>, encoding and decoding immediately
  return the portion of the data that has been processed so far when an
  error occurs. The data argument is overwritten with everything
  after that point; that is, the unprocessed portion of the data.  This is
  handy when you have to call C<decode> repeatedly in the case where your
  source data may contain partial multi-byte character sequences,
  (that is, you are reading with a fixed-width buffer). Here's some sample
  code to do exactly that:
  
      my($buffer, $string) = ("", "");
      while (read($fh, $buffer, 256, length($buffer))) {
          $string .= decode($encoding, $buffer, Encode::FB_QUIET);
          # $buffer now contains the unprocessed partial character
      }
  
  =head3 FB_WARN
  
    I<CHECK> = Encode::FB_WARN
  
  This is the same as C<FB_QUIET> above, except that instead of being silent
  on errors, it issues a warning.  This is handy for when you are debugging.
  
  B<CAVEAT>: All warnings from Encode module are reported, independently of
  L<pragma warnings|warnings> settings. If you want to follow settings of
  lexical warnings configured by L<pragma warnings|warnings> then append
  also check value C<ENCODE::ONLY_PRAGMA_WARNINGS>. This value is available
  since Encode version 2.99.
  
  =head3 FB_PERLQQ FB_HTMLCREF FB_XMLCREF
  
  =over 2
  
  =item perlqq mode (I<CHECK> = Encode::FB_PERLQQ)
  
  =item HTML charref mode (I<CHECK> = Encode::FB_HTMLCREF)
  
  =item XML charref mode (I<CHECK> = Encode::FB_XMLCREF)
  
  =back
  
  For encodings that are implemented by the C<Encode::XS> module, C<CHECK> C<==>
  C<Encode::FB_PERLQQ> puts C<encode> and C<decode> into C<perlqq> fallback mode.
  
  When you decode, C<\xI<HH>> is inserted for a malformed character, where
  I<HH> is the hex representation of the octet that could not be decoded to
  utf8.  When you encode, C<\x{I<HHHH>}> will be inserted, where I<HHHH> is
  the Unicode code point (in any number of hex digits) of the character that
  cannot be found in the character repertoire of the encoding.
  
  The HTML/XML character reference modes are about the same. In place of
  C<\x{I<HHHH>}>, HTML uses C<&#I<NNN>;> where I<NNN> is a decimal number, and
  XML uses C<&#xI<HHHH>;> where I<HHHH> is the hexadecimal number.
  
  In C<Encode> 2.10 or later, C<LEAVE_SRC> is also implied.
  
  =head3 The bitmask
  
  These modes are all actually set via a bitmask.  Here is how the C<FB_I<XXX>>
  constants are laid out.  You can import the C<FB_I<XXX>> constants via
  C<use Encode qw(:fallbacks)>, and you can import the generic bitmask
  constants via C<use Encode qw(:fallback_all)>.
  
                       FB_DEFAULT FB_CROAK FB_QUIET FB_WARN  FB_PERLQQ
   DIE_ON_ERR    0x0001             X
   WARN_ON_ERR   0x0002                               X
   RETURN_ON_ERR 0x0004                      X        X
   LEAVE_SRC     0x0008                                        X
   PERLQQ        0x0100                                        X
   HTMLCREF      0x0200
   XMLCREF       0x0400
  
  =head3 LEAVE_SRC
  
    Encode::LEAVE_SRC
  
  If the C<Encode::LEAVE_SRC> bit is I<not> set but I<CHECK> is set, then the
  source string to encode() or decode() will be overwritten in place.
  If you're not interested in this, then bitwise-OR it with the bitmask.
  
  =head2 coderef for CHECK
  
  As of C<Encode> 2.12, C<CHECK> can also be a code reference which takes the
  ordinal value of the unmapped character as an argument and returns
  octets that represent the fallback character.  For instance:
  
    $ascii = encode("ascii", $utf8, sub{ sprintf "<U+%04X>", shift });
  
  Acts like C<FB_PERLQQ> but U+I<XXXX> is used instead of C<\x{I<XXXX>}>.
  
  Fallback for C<decode> must return decoded string (sequence of characters)
  and takes a list of ordinal values as its arguments. So for
  example if you wish to decode octets as UTF-8, and use ISO-8859-15 as
  a fallback for bytes that are not valid UTF-8, you could write
  
      $str = decode 'UTF-8', $octets, sub {
          my $tmp = join '', map chr, @_;
          return decode 'ISO-8859-15', $tmp;
      };
  
  =head1 Defining Encodings
  
  To define a new encoding, use:
  
      use Encode qw(define_encoding);
      define_encoding($object, CANONICAL_NAME [, alias...]);
  
  I<CANONICAL_NAME> will be associated with I<$object>.  The object
  should provide the interface described in L<Encode::Encoding>.
  If more than two arguments are provided, additional
  arguments are considered aliases for I<$object>.
  
  See L<Encode::Encoding> for details.
  
  =head1 The UTF8 flag
  
  Before the introduction of Unicode support in Perl, The C<eq> operator
  just compared the strings represented by two scalars. Beginning with
  Perl 5.8, C<eq> compares two strings with simultaneous consideration of
  I<the UTF8 flag>. To explain why we made it so, I quote from page 402 of
  I<Programming Perl, 3rd ed.>
  
  =over 2
  
  =item Goal #1:
  
  Old byte-oriented programs should not spontaneously break on the old
  byte-oriented data they used to work on.
  
  =item Goal #2:
  
  Old byte-oriented programs should magically start working on the new
  character-oriented data when appropriate.
  
  =item Goal #3:
  
  Programs should run just as fast in the new character-oriented mode
  as in the old byte-oriented mode.
  
  =item Goal #4:
  
  Perl should remain one language, rather than forking into a
  byte-oriented Perl and a character-oriented Perl.
  
  =back
  
  When I<Programming Perl, 3rd ed.> was written, not even Perl 5.6.0 had been
  born yet, many features documented in the book remained unimplemented for a
  long time.  Perl 5.8 corrected much of this, and the introduction of the
  UTF8 flag is one of them.  You can think of there being two fundamentally
  different kinds of strings and string-operations in Perl: one a
  byte-oriented mode  for when the internal UTF8 flag is off, and the other a
  character-oriented mode for when the internal UTF8 flag is on.
  
  This UTF8 flag is not visible in Perl scripts, exactly for the same reason
  you cannot (or rather, you I<don't have to>) see whether a scalar contains
  a string, an integer, or a floating-point number.   But you can still peek
  and poke these if you will.  See the next section.
  
  =head2 Messing with Perl's Internals
  
  The following API uses parts of Perl's internals in the current
  implementation.  As such, they are efficient but may change in a future
  release.
  
  =head3 is_utf8
  
    is_utf8(STRING [, CHECK])
  
  [INTERNAL] Tests whether the UTF8 flag is turned on in the I<STRING>.
  If I<CHECK> is true, also checks whether I<STRING> contains well-formed
  UTF-8.  Returns true if successful, false otherwise.
  
  Typically only necessary for debugging and testing.  Don't use this flag as
  a marker to distinguish character and binary data, that should be decided
  for each variable when you write your code.
  
  B<CAVEAT>: If I<STRING> has UTF8 flag set, it does B<NOT> mean that
  I<STRING> is UTF-8 encoded and vice-versa.
  
  As of Perl 5.8.1, L<utf8> also has the C<utf8::is_utf8> function.
  
  =head3 _utf8_on
  
    _utf8_on(STRING)
  
  [INTERNAL] Turns the I<STRING>'s internal UTF8 flag B<on>.  The I<STRING>
  is I<not> checked for containing only well-formed UTF-8.  Do not use this
  unless you I<know with absolute certainty> that the STRING holds only
  well-formed UTF-8.  Returns the previous state of the UTF8 flag (so please
  don't treat the return value as indicating success or failure), or C<undef>
  if I<STRING> is not a string.
  
  B<NOTE>: For security reasons, this function does not work on tainted values.
  
  =head3 _utf8_off
  
    _utf8_off(STRING)
  
  [INTERNAL] Turns the I<STRING>'s internal UTF8 flag B<off>.  Do not use
  frivolously.  Returns the previous state of the UTF8 flag, or C<undef> if
  I<STRING> is not a string.  Do not treat the return value as indicative of
  success or failure, because that isn't what it means: it is only the
  previous setting.
  
  B<NOTE>: For security reasons, this function does not work on tainted values.
  
  =head1 UTF-8 vs. utf8 vs. UTF8
  
    ....We now view strings not as sequences of bytes, but as sequences
    of numbers in the range 0 .. 2**32-1 (or in the case of 64-bit
    computers, 0 .. 2**64-1) -- Programming Perl, 3rd ed.
  
  That has historically been Perl's notion of UTF-8, as that is how UTF-8 was
  first conceived by Ken Thompson when he invented it. However, thanks to
  later revisions to the applicable standards, official UTF-8 is now rather
  stricter than that. For example, its range is much narrower (0 .. 0x10_FFFF
  to cover only 21 bits instead of 32 or 64 bits) and some sequences
  are not allowed, like those used in surrogate pairs, the 31 non-character
  code points 0xFDD0 .. 0xFDEF, the last two code points in I<any> plane
  (0xI<XX>_FFFE and 0xI<XX>_FFFF), all non-shortest encodings, etc.
  
  The former default in which Perl would always use a loose interpretation of
  UTF-8 has now been overruled:
  
    From: Larry Wall <larry@wall.org>
    Date: December 04, 2004 11:51:58 JST
    To: perl-unicode@perl.org
    Subject: Re: Make Encode.pm support the real UTF-8
    Message-Id: <20041204025158.GA28754@wall.org>
  
    On Fri, Dec 03, 2004 at 10:12:12PM +0000, Tim Bunce wrote:
    : I've no problem with 'utf8' being perl's unrestricted uft8 encoding,
    : but "UTF-8" is the name of the standard and should give the
    : corresponding behaviour.
  
    For what it's worth, that's how I've always kept them straight in my
    head.
  
    Also for what it's worth, Perl 6 will mostly default to strict but
    make it easy to switch back to lax.
  
    Larry
  
  Got that?  As of Perl 5.8.7, B<"UTF-8"> means UTF-8 in its current
  sense, which is conservative and strict and security-conscious, whereas
  B<"utf8"> means UTF-8 in its former sense, which was liberal and loose and
  lax.  C<Encode> version 2.10 or later thus groks this subtle but critically
  important distinction between C<"UTF-8"> and C<"utf8">.
  
    encode("utf8",  "\x{FFFF_FFFF}", 1); # okay
    encode("UTF-8", "\x{FFFF_FFFF}", 1); # croaks
  
  This distinction is also important for decoding. In the following,
  C<$s> stores character U+200000, which exceeds UTF-8's allowed range.
  C<$s> thus stores an invalid Unicode code point:
  
    $s = decode("utf8", "\xf8\x88\x80\x80\x80");
  
  C<"UTF-8">, by contrast, will either coerce the input to something valid:
  
      $s = decode("UTF-8", "\xf8\x88\x80\x80\x80"); # U+FFFD
  
  .. or croak:
  
      decode("UTF-8", "\xf8\x88\x80\x80\x80", FB_CROAK|LEAVE_SRC);
  
  In the C<Encode> module, C<"UTF-8"> is actually a canonical name for
  C<"utf-8-strict">.  That hyphen between the C<"UTF"> and the C<"8"> is
  critical; without it, C<Encode> goes "liberal" and (perhaps overly-)permissive:
  
    find_encoding("UTF-8")->name # is 'utf-8-strict'
    find_encoding("utf-8")->name # ditto. names are case insensitive
    find_encoding("utf_8")->name # ditto. "_" are treated as "-"
    find_encoding("UTF8")->name  # is 'utf8'.
  
  Perl's internal UTF8 flag is called "UTF8", without a hyphen. It indicates
  whether a string is internally encoded as "utf8", also without a hyphen.
  
  =head1 SEE ALSO
  
  L<Encode::Encoding>,
  L<Encode::Supported>,
  L<Encode::PerlIO>,
  L<encoding>,
  L<perlebcdic>,
  L<perlfunc/open>,
  L<perlunicode>, L<perluniintro>, L<perlunifaq>, L<perlunitut>
  L<utf8>,
  the Perl Unicode Mailing List L<http://lists.perl.org/list/perl-unicode.html>
  
  =head1 MAINTAINER
  
  This project was originated by the late Nick Ing-Simmons and later
  maintained by Dan Kogai I<< <dankogai@cpan.org> >>.  See AUTHORS
  for a full list of people involved.  For any questions, send mail to
  I<< <perl-unicode@perl.org> >> so that we can all share.
  
  While Dan Kogai retains the copyright as a maintainer, credit
  should go to all those involved.  See AUTHORS for a list of those
  who submitted code to the project.
  
  =head1 COPYRIGHT
  
  Copyright 2002-2014 Dan Kogai I<< <dankogai@cpan.org> >>.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_ENCODE

$fatpacked{"x86_64-linux-gnu-thread-multi/Encode/Alias.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_ALIAS';
  package Encode::Alias;
  use strict;
  use warnings;
  our $VERSION = do { my @r = ( q$Revision: 2.25 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  use constant DEBUG => !!$ENV{PERL_ENCODE_DEBUG};
  
  use Exporter 'import';
  
  # Public, encouraged API is exported by default
  
  our @EXPORT =
    qw (
    define_alias
    find_alias
  );
  
  our @Alias;    # ordered matching list
  our %Alias;    # cached known aliases
  
  sub find_alias {
      my $class = shift;
      my $find  = shift;
      unless ( exists $Alias{$find} ) {
          $Alias{$find} = undef;    # Recursion guard
          for ( my $i = 0 ; $i < @Alias ; $i += 2 ) {
              my $alias = $Alias[$i];
              my $val   = $Alias[ $i + 1 ];
              my $new;
              if ( ref($alias) eq 'Regexp' && $find =~ $alias ) {
                  DEBUG and warn "eval $val";
                  $new = eval $val;
                  DEBUG and $@ and warn "$val, $@";
              }
              elsif ( ref($alias) eq 'CODE' ) {
                  DEBUG and warn "$alias", "->", "($find)";
                  $new = $alias->($find);
              }
              elsif ( lc($find) eq lc($alias) ) {
                  $new = $val;
              }
              if ( defined($new) ) {
                  next if $new eq $find;    # avoid (direct) recursion on bugs
                  DEBUG and warn "$alias, $new";
                  my $enc =
                    ( ref($new) ) ? $new : Encode::find_encoding($new);
                  if ($enc) {
                      $Alias{$find} = $enc;
                      last;
                  }
              }
          }
  
          # case insensitive search when canonical is not in all lowercase
          # RT ticket #7835
          unless ( $Alias{$find} ) {
              my $lcfind = lc($find);
              for my $name ( keys %Encode::Encoding, keys %Encode::ExtModule )
              {
                  $lcfind eq lc($name) or next;
                  $Alias{$find} = Encode::find_encoding($name);
                  DEBUG and warn "$find => $name";
              }
          }
      }
      if (DEBUG) {
          my $name;
          if ( my $e = $Alias{$find} ) {
              $name = $e->name;
          }
          else {
              $name = "";
          }
          warn "find_alias($class, $find)->name = $name";
      }
      return $Alias{$find};
  }
  
  sub define_alias {
      while (@_) {
          my $alias = shift;
          my $name = shift;
          unshift( @Alias, $alias => $name )    # newer one has precedence
              if defined $alias;
          if ( ref($alias) ) {
  
              # clear %Alias cache to allow overrides
              my @a = keys %Alias;
              for my $k (@a) {
                  if ( ref($alias) eq 'Regexp' && $k =~ $alias ) {
                      DEBUG and warn "delete \$Alias\{$k\}";
                      delete $Alias{$k};
                  }
                  elsif ( ref($alias) eq 'CODE' && $alias->($k) ) {
                      DEBUG and warn "delete \$Alias\{$k\}";
                      delete $Alias{$k};
                  }
              }
          }
          elsif (defined $alias) {
              DEBUG and warn "delete \$Alias\{$alias\}";
              delete $Alias{$alias};
          }
          elsif (DEBUG) {
              require Carp;
              Carp::croak("undef \$alias");
          }
      }
  }
  
  # HACK: Encode must be used after define_alias is declarated as Encode calls define_alias
  use Encode ();
  
  # Allow latin-1 style names as well
  # 0  1  2  3  4  5   6   7   8   9  10
  our @Latin2iso = ( 0, 1, 2, 3, 4, 9, 10, 13, 14, 15, 16 );
  
  # Allow winlatin1 style names as well
  our %Winlatin2cp = (
      'latin1'     => 1252,
      'latin2'     => 1250,
      'cyrillic'   => 1251,
      'greek'      => 1253,
      'turkish'    => 1254,
      'hebrew'     => 1255,
      'arabic'     => 1256,
      'baltic'     => 1257,
      'vietnamese' => 1258,
  );
  
  init_aliases();
  
  sub undef_aliases {
      @Alias = ();
      %Alias = ();
  }
  
  sub init_aliases {
      undef_aliases();
  
      # Try all-lower-case version should all else fails
      define_alias( qr/^(.*)$/ => '"\L$1"' );
  
      # UTF/UCS stuff
      define_alias( qr/^(unicode-1-1-)?UTF-?7$/i     => '"UTF-7"' );
      define_alias( qr/^UCS-?2-?LE$/i => '"UCS-2LE"' );
      define_alias(
          qr/^UCS-?2-?(BE)?$/i    => '"UCS-2BE"',
          qr/^UCS-?4-?(BE|LE|)?$/i => 'uc("UTF-32$1")',
          qr/^iso-10646-1$/i      => '"UCS-2BE"'
      );
      define_alias(
          qr/^UTF-?(16|32)-?BE$/i => '"UTF-$1BE"',
          qr/^UTF-?(16|32)-?LE$/i => '"UTF-$1LE"',
          qr/^UTF-?(16|32)$/i     => '"UTF-$1"',
      );
  
      # ASCII
      define_alias( qr/^(?:US-?)ascii$/i       => '"ascii"' );
      define_alias( 'C'                        => 'ascii' );
      define_alias( qr/\b(?:ISO[-_]?)?646(?:[-_]?US)?$/i => '"ascii"' );
  
      # Allow variants of iso-8859-1 etc.
      define_alias( qr/\biso[-_]?(\d+)[-_](\d+)$/i => '"iso-$1-$2"' );
  
      # ISO-8859-8-I => ISO-8859-8
      # https://en.wikipedia.org/wiki/ISO-8859-8-I
      define_alias( qr/\biso[-_]8859[-_]8[-_]I$/i => '"iso-8859-8"' );
  
      # At least HP-UX has these.
      define_alias( qr/\biso8859(\d+)$/i => '"iso-8859-$1"' );
  
      # More HP stuff.
      define_alias(
          qr/\b(?:hp-)?(arabic|greek|hebrew|kana|roman|thai|turkish)8$/i =>
            '"${1}8"' );
  
      # The Official name of ASCII.
      define_alias( qr/\bANSI[-_]?X3\.4[-_]?1968$/i => '"ascii"' );
  
      # This is a font issue, not an encoding issue.
      # (The currency symbol of the Latin 1 upper half
      #  has been redefined as the euro symbol.)
      define_alias( qr/^(.+)\@euro$/i => '"$1"' );
  
      define_alias( qr/\b(?:iso[-_]?)?latin[-_]?(\d+)$/i =>
  'defined $Encode::Alias::Latin2iso[$1] ? "iso-8859-$Encode::Alias::Latin2iso[$1]" : undef'
      );
  
      define_alias(
          qr/\bwin(latin[12]|cyrillic|baltic|greek|turkish|
               hebrew|arabic|baltic|vietnamese)$/ix =>
            '"cp" . $Encode::Alias::Winlatin2cp{lc($1)}'
      );
  
      # Common names for non-latin preferred MIME names
      define_alias(
          'ascii'    => 'US-ascii',
          'cyrillic' => 'iso-8859-5',
          'arabic'   => 'iso-8859-6',
          'greek'    => 'iso-8859-7',
          'hebrew'   => 'iso-8859-8',
          'thai'     => 'iso-8859-11',
      );
      # RT #20781
      define_alias(qr/\btis-?620\b/i  => '"iso-8859-11"');
  
      # At least AIX has IBM-NNN (surprisingly...) instead of cpNNN.
      # And Microsoft has their own naming (again, surprisingly).
      # And windows-* is registered in IANA!
      define_alias(
          qr/\b(?:cp|ibm|ms|windows)[-_ ]?(\d{2,4})$/i => '"cp$1"' );
  
      # Sometimes seen with a leading zero.
      # define_alias( qr/\bcp037\b/i => '"cp37"');
  
      # Mac Mappings
      # predefined in *.ucm; unneeded
      # define_alias( qr/\bmacIcelandic$/i => '"macIceland"');
      define_alias( qr/^(?:x[_-])?mac[_-](.*)$/i => '"mac$1"' );
      # http://rt.cpan.org/Ticket/Display.html?id=36326
      define_alias( qr/^macintosh$/i => '"MacRoman"' );
      # https://rt.cpan.org/Ticket/Display.html?id=78125
      define_alias( qr/^macce$/i => '"MacCentralEurRoman"' );
      # Ououououou. gone.  They are different!
      # define_alias( qr/\bmacRomanian$/i => '"macRumanian"');
  
      # Standardize on the dashed versions.
      define_alias( qr/\bkoi8[\s\-_]*([ru])$/i => '"koi8-$1"' );
  
      unless ($Encode::ON_EBCDIC) {
  
          # for Encode::CN
          define_alias( qr/\beuc.*cn$/i => '"euc-cn"' );
          define_alias( qr/\bcn.*euc$/i => '"euc-cn"' );
  
          # define_alias( qr/\bGB[- ]?(\d+)$/i => '"euc-cn"' )
          # CP936 doesn't have vendor-addon for GBK, so they're identical.
          define_alias( qr/^gbk$/i => '"cp936"' );
  
          # This fixes gb2312 vs. euc-cn confusion, practically
          define_alias( qr/\bGB[-_ ]?2312(?!-?raw)/i => '"euc-cn"' );
  
          # for Encode::JP
          define_alias( qr/\bjis$/i         => '"7bit-jis"' );
          define_alias( qr/\beuc.*jp$/i     => '"euc-jp"' );
          define_alias( qr/\bjp.*euc$/i     => '"euc-jp"' );
          define_alias( qr/\bujis$/i        => '"euc-jp"' );
          define_alias( qr/\bshift.*jis$/i  => '"shiftjis"' );
          define_alias( qr/\bsjis$/i        => '"shiftjis"' );
          define_alias( qr/\bwindows-31j$/i => '"cp932"' );
  
          # for Encode::KR
          define_alias( qr/\beuc.*kr$/i => '"euc-kr"' );
          define_alias( qr/\bkr.*euc$/i => '"euc-kr"' );
  
          # This fixes ksc5601 vs. euc-kr confusion, practically
          define_alias( qr/(?:x-)?uhc$/i         => '"cp949"' );
          define_alias( qr/(?:x-)?windows-949$/i => '"cp949"' );
          define_alias( qr/\bks_c_5601-1987$/i   => '"cp949"' );
  
          # for Encode::TW
          define_alias( qr/\bbig-?5$/i              => '"big5-eten"' );
          define_alias( qr/\bbig5-?et(?:en)?$/i     => '"big5-eten"' );
          define_alias( qr/\btca[-_]?big5$/i        => '"big5-eten"' );
          define_alias( qr/\bbig5-?hk(?:scs)?$/i    => '"big5-hkscs"' );
          define_alias( qr/\bhk(?:scs)?[-_]?big5$/i => '"big5-hkscs"' );
      }
  
      # https://github.com/dankogai/p5-encode/issues/37
      define_alias(qr/cp65000/i => '"UTF-7"');
      define_alias(qr/cp65001/i => '"utf-8-strict"');
  
      # utf8 is blessed :)
      define_alias( qr/\bUTF-8$/i => '"utf-8-strict"' );
  
      # At last, Map white space and _ to '-'
      define_alias( qr/^([^\s_]+)[\s_]+([^\s_]*)$/i => '"$1-$2"' );
  }
  
  1;
  __END__
  
  # TODO: HP-UX '8' encodings arabic8 greek8 hebrew8 kana8 thai8 turkish8
  # TODO: HP-UX '15' encodings japanese15 korean15 roi15
  # TODO: Cyrillic encoding ISO-IR-111 (useful?)
  # TODO: Armenian encoding ARMSCII-8
  # TODO: Hebrew encoding ISO-8859-8-1
  # TODO: Thai encoding TCVN
  # TODO: Vietnamese encodings VPS
  # TODO: Mac Asian+African encodings: Arabic Armenian Bengali Burmese
  #       ChineseSimp ChineseTrad Devanagari Ethiopic ExtArabic
  #       Farsi Georgian Gujarati Gurmukhi Hebrew Japanese
  #       Kannada Khmer Korean Laotian Malayalam Mongolian
  #       Oriya Sinhalese Symbol Tamil Telugu Tibetan Vietnamese
  
  =head1 NAME
  
  Encode::Alias - alias definitions to encodings
  
  =head1 SYNOPSIS
  
    use Encode;
    use Encode::Alias;
    define_alias( "newName" => ENCODING);
    define_alias( qr/.../ => ENCODING);
    define_alias( sub { return ENCODING if ...; } );
  
  =head1 DESCRIPTION
  
  Allows newName to be used as an alias for ENCODING. ENCODING may be
  either the name of an encoding or an encoding object (as described 
  in L<Encode>).
  
  Currently the first argument to define_alias() can be specified in the
  following ways:
  
  =over 4
  
  =item As a simple string.
  
  =item As a qr// compiled regular expression, e.g.:
  
    define_alias( qr/^iso8859-(\d+)$/i => '"iso-8859-$1"' );
  
  In this case, if I<ENCODING> is not a reference, it is C<eval>-ed
  in order to allow C<$1> etc. to be substituted.  The example is one
  way to alias names as used in X11 fonts to the MIME names for the
  iso-8859-* family.  Note the double quotes inside the single quotes.
  
  (or, you don't have to do this yourself because this example is predefined)
  
  If you are using a regex here, you have to use the quotes as shown or
  it won't work.  Also note that regex handling is tricky even for the
  experienced.  Use this feature with caution.
  
  =item As a code reference, e.g.:
  
    define_alias( sub {shift =~ /^iso8859-(\d+)$/i ? "iso-8859-$1" : undef } );
  
  The same effect as the example above in a different way.  The coderef
  takes the alias name as an argument and returns a canonical name on
  success or undef if not.  Note the second argument is ignored if provided.
  Use this with even more caution than the regex version.
  
  =back
  
  =head3 Changes in code reference aliasing
  
  As of Encode 1.87, the older form
  
    define_alias( sub { return  /^iso8859-(\d+)$/i ? "iso-8859-$1" : undef } );
  
  no longer works. 
  
  Encode up to 1.86 internally used "local $_" to implement this older
  form.  But consider the code below;
  
    use Encode;
    $_ = "eeeee" ;
    while (/(e)/g) {
      my $utf = decode('aliased-encoding-name', $1);
      print "position:",pos,"\n";
    }
  
  Prior to Encode 1.86 this fails because of "local $_".
  
  =head2 Alias overloading
  
  You can override predefined aliases by simply applying define_alias().
  The new alias is always evaluated first, and when necessary,
  define_alias() flushes the internal cache to make the new definition
  available.
  
    # redirect SHIFT_JIS to MS/IBM Code Page 932, which is a
    # superset of SHIFT_JIS
  
    define_alias( qr/shift.*jis$/i  => '"cp932"' );
    define_alias( qr/sjis$/i        => '"cp932"' );
  
  If you want to zap all predefined aliases, you can use
  
    Encode::Alias->undef_aliases;
  
  to do so.  And
  
    Encode::Alias->init_aliases;
  
  gets the factory settings back.
  
  Note that define_alias() will not be able to override the canonical name
  of encodings. Encodings are first looked up by canonical name before
  potential aliases are tried.
  
  =head1 SEE ALSO
  
  L<Encode>, L<Encode::Supported>
  
  =cut
  
X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_ALIAS

$fatpacked{"x86_64-linux-gnu-thread-multi/Encode/Byte.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_BYTE';
  package Encode::Byte;
  use strict;
  use warnings;
  use Encode;
  our $VERSION = do { my @r = ( q$Revision: 2.4 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use XSLoader;
  XSLoader::load( __PACKAGE__, $VERSION );
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::Byte - Single Byte Encodings
  
  =head1 SYNOPSIS
  
      use Encode qw/encode decode/; 
      $greek = encode("iso-8859-7", $utf8);  # loads Encode::Byte implicitly
      $utf8  = decode("iso-8859-7", $greek); # ditto
  
  =head1 ABSTRACT
  
  This module implements various single byte encodings.  For most cases it uses
  \x80-\xff (upper half) to map non-ASCII characters.  Encodings
  supported are as follows.   
  
    Canonical      Alias		                      Description
    --------------------------------------------------------------------
    # ISO 8859 series
    (iso-8859-1	is in built-in)
    iso-8859-2	latin2					     [ISO]
    iso-8859-3	latin3					     [ISO]
    iso-8859-4	latin4					     [ISO]
    iso-8859-5						     [ISO]
    iso-8859-6						     [ISO]
    iso-8859-7						     [ISO]
    iso-8859-8						     [ISO]
    iso-8859-9	latin5					     [ISO]
    iso-8859-10	latin6					     [ISO]
    iso-8859-11
    (iso-8859-12 is nonexistent)
    iso-8859-13   latin7					     [ISO]
    iso-8859-14	latin8					     [ISO]
    iso-8859-15	latin9					     [ISO]
    iso-8859-16	latin10					     [ISO]
  
    # Cyrillic
    koi8-f					
    koi8-r        cp878					 [RFC1489]
    koi8-u						 [RFC2319]
  
    # Vietnamese
    viscii
  
    # all cp* are also available as ibm-*, ms-*, and windows-*
    # also see L<http://msdn.microsoft.com/en-us/library/aa752010%28VS.85%29.aspx>
  
    cp424  
    cp437  
    cp737  
    cp775  
    cp850  
    cp852  
    cp855  
    cp856  
    cp857  
    cp860  
    cp861  
    cp862  
    cp863  
    cp864  
    cp865  
    cp866  
    cp869  
    cp874  
    cp1006  
    cp1250	WinLatin2
    cp1251	WinCyrillic
    cp1252	WinLatin1
    cp1253	WinGreek
    cp1254	WinTurkish
    cp1255	WinHebrew
    cp1256	WinArabic
    cp1257	WinBaltic
    cp1258	WinVietnamese
  
    # Macintosh
    # Also see L<http://developer.apple.com/technotes/tn/tn1150.html>
    MacArabic  
    MacCentralEurRoman  
    MacCroatian  
    MacCyrillic  
    MacFarsi  
    MacGreek  
    MacHebrew  
    MacIcelandic  
    MacRoman  
    MacRomanian  
    MacRumanian  
    MacSami  
    MacThai  
    MacTurkish  
    MacUkrainian  
  
    # More vendor encodings
    AdobeStandardEncoding
    nextstep
    hp-roman8
  
  =head1 DESCRIPTION
  
  To find how to use this module in detail, see L<Encode>.
  
  =head1 SEE ALSO
  
  L<Encode>
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_BYTE

$fatpacked{"x86_64-linux-gnu-thread-multi/Encode/CJKConstants.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_CJKCONSTANTS';
  #
  # $Id: CJKConstants.pm,v 2.2 2006/06/03 20:28:48 dankogai Exp $
  #
  
  package Encode::CJKConstants;
  
  use strict;
  use warnings;
  our $RCSID = q$Id: CJKConstants.pm,v 2.2 2006/06/03 20:28:48 dankogai Exp $;
  our $VERSION = do { my @r = ( q$Revision: 2.2 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use Carp;
  
  require Exporter;
  our @ISA         = qw(Exporter);
  our @EXPORT      = qw();
  our @EXPORT_OK   = qw(%CHARCODE %ESC %RE);
  our %EXPORT_TAGS = ( 'all' => [ @EXPORT_OK, @EXPORT ] );
  
  my %_0208 = (
      1978 => '\e\$\@',
      1983 => '\e\$B',
      1990 => '\e&\@\e\$B',
  );
  
  our %CHARCODE = (
      UNDEF_EUC     => "\xa2\xae",    #  in EUC
      UNDEF_SJIS    => "\x81\xac",    #  in SJIS
      UNDEF_JIS     => "\xa2\xf7",    #  -- used in unicode
      UNDEF_UNICODE => "\x20\x20",    #  -- used in unicode
  );
  
  our %ESC = (
      GB_2312   => "\e\$A",
      JIS_0208  => "\e\$B",
      JIS_0212  => "\e\$(D",
      KSC_5601  => "\e\$(C",
      ASC       => "\e\(B",
      KANA      => "\e\(I",
      '2022_KR' => "\e\$)C",
  );
  
  our %RE = (
      ASCII     => '[\x00-\x7f]',
      BIN       => '[\x00-\x06\x7f\xff]',
      EUC_0212  => '\x8f[\xa1-\xfe][\xa1-\xfe]',
      EUC_C     => '[\xa1-\xfe][\xa1-\xfe]',
      EUC_KANA  => '\x8e[\xa1-\xdf]',
      JIS_0208  => "$_0208{1978}|$_0208{1983}|$_0208{1990}",
      JIS_0212  => "\e" . '\$\(D',
      ISO_ASC   => "\e" . '\([BJ]',
      JIS_KANA  => "\e" . '\(I',
      '2022_KR' => "\e" . '\$\)C',
      SJIS_C    => '[\x81-\x9f\xe0-\xfc][\x40-\x7e\x80-\xfc]',
      SJIS_KANA => '[\xa1-\xdf]',
      UTF8      => '[\xc0-\xdf][\x80-\xbf]|[\xe0-\xef][\x80-\xbf][\x80-\xbf]'
  );
  
  1;
  
  =head1 NAME
  
  Encode::CJKConstants.pm -- Internally used by Encode::??::ISO_2022_*
  
  =cut
  
X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_CJKCONSTANTS

$fatpacked{"x86_64-linux-gnu-thread-multi/Encode/CN.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_CN';
  package Encode::CN;
  BEGIN {
      if ( ord("A") == 193 ) {
          die "Encode::CN not supported on EBCDIC\n";
      }
  }
  use strict;
  use warnings;
  use Encode;
  our $VERSION = do { my @r = ( q$Revision: 2.3 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  use XSLoader;
  XSLoader::load( __PACKAGE__, $VERSION );
  
  # Relocated from Encode.pm
  
  use Encode::CN::HZ;
  
  # use Encode::CN::2022_CN;
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::CN - China-based Chinese Encodings
  
  =head1 SYNOPSIS
  
      use Encode qw/encode decode/; 
      $euc_cn = encode("euc-cn", $utf8);   # loads Encode::CN implicitly
      $utf8   = decode("euc-cn", $euc_cn); # ditto
  
  =head1 DESCRIPTION
  
  This module implements China-based Chinese charset encodings.
  Encodings supported are as follows.
  
    Canonical   Alias		Description
    --------------------------------------------------------------------
    euc-cn      /\beuc.*cn$/i	EUC (Extended Unix Character)
            /\bcn.*euc$/i
                /\bGB[-_ ]?2312(?:\D.*$|$)/i (see below)
    gb2312-raw			The raw (low-bit) GB2312 character map
    gb12345-raw			Traditional chinese counterpart to 
                  GB2312 (raw)
    iso-ir-165			GB2312 + GB6345 + GB8565 + additions
    MacChineseSimp                GB2312 + Apple Additions
    cp936				Code Page 936, also known as GBK 
                  (Extended GuoBiao)
    hz				7-bit escaped GB2312 encoding
    --------------------------------------------------------------------
  
  To find how to use this module in detail, see L<Encode>.
  
  =head1 NOTES
  
  Due to size concerns, C<GB 18030> (an extension to C<GBK>) is distributed
  separately on CPAN, under the name L<Encode::HanExtra>. That module
  also contains extra Taiwan-based encodings.
  
  =head1 BUGS
  
  When you see C<charset=gb2312> on mails and web pages, they really
  mean C<euc-cn> encodings.  To fix that, C<gb2312> is aliased to C<euc-cn>.
  Use C<gb2312-raw> when you really mean it.
  
  The ASCII region (0x00-0x7f) is preserved for all encodings, even though
  this conflicts with mappings by the Unicode Consortium.
  
  =head1 SEE ALSO
  
  L<Encode>
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_CN

$fatpacked{"x86_64-linux-gnu-thread-multi/Encode/CN/HZ.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_CN_HZ';
  package Encode::CN::HZ;
  
  use strict;
  use warnings;
  use utf8 ();
  
  use vars qw($VERSION);
  $VERSION = do { my @r = ( q$Revision: 2.10 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use Encode qw(:fallbacks);
  
  use parent qw(Encode::Encoding);
  __PACKAGE__->Define('hz');
  
  # HZ is a combination of ASCII and escaped GB, so we implement it
  # with the GB2312(raw) encoding here. Cf. RFCs 1842 & 1843.
  
  # not ported for EBCDIC.  Which should be used, "~" or "\x7E"?
  
  sub needs_lines { 1 }
  
  sub decode ($$;$) {
      my ( $obj, $str, $chk ) = @_;
      return undef unless defined $str;
  
      my $GB  = Encode::find_encoding('gb2312-raw');
      my $ret = substr($str, 0, 0); # to propagate taintedness
      my $in_ascii = 1;    # default mode is ASCII.
  
      while ( length $str ) {
          if ($in_ascii) {    # ASCII mode
              if ( $str =~ s/^([\x00-\x7D\x7F]+)// ) {    # no '~' => ASCII
                  $ret .= $1;
  
                  # EBCDIC should need ascii2native, but not ported.
              }
              elsif ( $str =~ s/^\x7E\x7E// ) {           # escaped tilde
                  $ret .= '~';
              }
              elsif ( $str =~ s/^\x7E\cJ// ) {    # '\cJ' == LF in ASCII
                  1;                              # no-op
              }
              elsif ( $str =~ s/^\x7E\x7B// ) {    # '~{'
                  $in_ascii = 0;                   # to GB
              }
              else {    # encounters an invalid escape, \x80 or greater
                  last;
              }
          }
          else {        # GB mode; the byte ranges are as in RFC 1843.
              no warnings 'uninitialized';
              if ( $str =~ s/^((?:[\x21-\x77][\x21-\x7E])+)// ) {
                  my $prefix = $1;
                  $ret .= $GB->decode( $prefix, $chk );
              }
              elsif ( $str =~ s/^\x7E\x7D// ) {    # '~}'
                  $in_ascii = 1;
              }
              else {                               # invalid
                  last;
              }
          }
      }
      $_[1] = '' if $chk;    # needs_lines guarantees no partial character
      return $ret;
  }
  
  sub cat_decode {
      my ( $obj, undef, $src, $pos, $trm, $chk ) = @_;
      my ( $rdst, $rsrc, $rpos ) = \@_[ 1 .. 3 ];
  
      my $GB  = Encode::find_encoding('gb2312-raw');
      my $ret = '';
      my $in_ascii = 1;      # default mode is ASCII.
  
      my $ini_pos = pos($$rsrc);
  
      substr( $src, 0, $pos ) = '';
  
      my $ini_len = bytes::length($src);
  
      # $trm is the first of the pair '~~', then 2nd tilde is to be removed.
      # XXX: Is better C<$src =~ s/^\x7E// or die if ...>?
      $src =~ s/^\x7E// if $trm eq "\x7E";
  
      while ( length $src ) {
          my $now;
          if ($in_ascii) {    # ASCII mode
              if ( $src =~ s/^([\x00-\x7D\x7F])// ) {    # no '~' => ASCII
                  $now = $1;
              }
              elsif ( $src =~ s/^\x7E\x7E// ) {          # escaped tilde
                  $now = '~';
              }
              elsif ( $src =~ s/^\x7E\cJ// ) {    # '\cJ' == LF in ASCII
                  next;
              }
              elsif ( $src =~ s/^\x7E\x7B// ) {    # '~{'
                  $in_ascii = 0;                   # to GB
                  next;
              }
              else {    # encounters an invalid escape, \x80 or greater
                  last;
              }
          }
          else {        # GB mode; the byte ranges are as in RFC 1843.
              if ( $src =~ s/^((?:[\x21-\x77][\x21-\x7F])+)// ) {
                  $now = $GB->decode( $1, $chk );
              }
              elsif ( $src =~ s/^\x7E\x7D// ) {    # '~}'
                  $in_ascii = 1;
                  next;
              }
              else {                               # invalid
                  last;
              }
          }
  
          next if !defined $now;
  
          $ret .= $now;
  
          if ( $now eq $trm ) {
              $$rdst .= $ret;
              $$rpos = $ini_pos + $pos + $ini_len - bytes::length($src);
              pos($$rsrc) = $ini_pos;
              return 1;
          }
      }
  
      $$rdst .= $ret;
      $$rpos = $ini_pos + $pos + $ini_len - bytes::length($src);
      pos($$rsrc) = $ini_pos;
      return '';    # terminator not found
  }
  
  sub encode($$;$) {
       my ( $obj, $str, $chk ) = @_;
      return undef unless defined $str;
  
      my $GB  = Encode::find_encoding('gb2312-raw');
      my $ret = substr($str, 0, 0); # to propagate taintedness;
      my $in_ascii = 1;    # default mode is ASCII.
  
      no warnings 'utf8';  # $str may be malformed UTF8 at the end of a chunk.
  
      while ( length $str ) {
          if ( $str =~ s/^([[:ascii:]]+)// ) {
              my $tmp = $1;
              $tmp =~ s/~/~~/g;    # escapes tildes
              if ( !$in_ascii ) {
                  $ret .= "\x7E\x7D";    # '~}'
                  $in_ascii = 1;
              }
              $ret .= pack 'a*', $tmp;    # remove UTF8 flag.
          }
          elsif ( $str =~ s/(.)// ) {
              my $s = $1;
              my $tmp = $GB->encode( $s, $chk || 0 );
              last if !defined $tmp;
              if ( length $tmp == 2 ) {    # maybe a valid GB char (XXX)
                  if ($in_ascii) {
                      $ret .= "\x7E\x7B";    # '~{'
                      $in_ascii = 0;
                  }
                  $ret .= $tmp;
              }
              elsif ( length $tmp ) {        # maybe FALLBACK in ASCII (XXX)
                  if ( !$in_ascii ) {
                      $ret .= "\x7E\x7D";    # '~}'
                      $in_ascii = 1;
                  }
                  $ret .= $tmp;
              }
          }
          else {    # if $str is malformed UTF8 *and* if length $str != 0.
              last;
          }
      }
      $_[1] = $str if $chk;
  
      # The state at the end of the chunk is discarded, even if in GB mode.
      # That results in the combination of GB-OUT and GB-IN, i.e. "~}~{".
      # Parhaps it is harmless, but further investigations may be required...
  
      if ( !$in_ascii ) {
          $ret .= "\x7E\x7D";    # '~}'
          $in_ascii = 1;
      }
      utf8::encode($ret); # https://rt.cpan.org/Ticket/Display.html?id=35120
      return $ret;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::CN::HZ -- internally used by Encode::CN
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_CN_HZ

$fatpacked{"x86_64-linux-gnu-thread-multi/Encode/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_CONFIG';
  #
  # Demand-load module list
  #
  package Encode::Config;
  our $VERSION = do { my @r = ( q$Revision: 2.5 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use strict;
  use warnings;
  
  our %ExtModule = (
  
      # Encode::Byte
      #iso-8859-1 is in Encode.pm itself
      'iso-8859-2'            => 'Encode::Byte',
      'iso-8859-3'            => 'Encode::Byte',
      'iso-8859-4'            => 'Encode::Byte',
      'iso-8859-5'            => 'Encode::Byte',
      'iso-8859-6'            => 'Encode::Byte',
      'iso-8859-7'            => 'Encode::Byte',
      'iso-8859-8'            => 'Encode::Byte',
      'iso-8859-9'            => 'Encode::Byte',
      'iso-8859-10'           => 'Encode::Byte',
      'iso-8859-11'           => 'Encode::Byte',
      'iso-8859-13'           => 'Encode::Byte',
      'iso-8859-14'           => 'Encode::Byte',
      'iso-8859-15'           => 'Encode::Byte',
      'iso-8859-16'           => 'Encode::Byte',
      'koi8-f'                => 'Encode::Byte',
      'koi8-r'                => 'Encode::Byte',
      'koi8-u'                => 'Encode::Byte',
      'viscii'                => 'Encode::Byte',
      'cp424'                 => 'Encode::Byte',
      'cp437'                 => 'Encode::Byte',
      'cp737'                 => 'Encode::Byte',
      'cp775'                 => 'Encode::Byte',
      'cp850'                 => 'Encode::Byte',
      'cp852'                 => 'Encode::Byte',
      'cp855'                 => 'Encode::Byte',
      'cp856'                 => 'Encode::Byte',
      'cp857'                 => 'Encode::Byte',
      'cp858'                 => 'Encode::Byte',
      'cp860'                 => 'Encode::Byte',
      'cp861'                 => 'Encode::Byte',
      'cp862'                 => 'Encode::Byte',
      'cp863'                 => 'Encode::Byte',
      'cp864'                 => 'Encode::Byte',
      'cp865'                 => 'Encode::Byte',
      'cp866'                 => 'Encode::Byte',
      'cp869'                 => 'Encode::Byte',
      'cp874'                 => 'Encode::Byte',
      'cp1006'                => 'Encode::Byte',
      'cp1250'                => 'Encode::Byte',
      'cp1251'                => 'Encode::Byte',
      'cp1252'                => 'Encode::Byte',
      'cp1253'                => 'Encode::Byte',
      'cp1254'                => 'Encode::Byte',
      'cp1255'                => 'Encode::Byte',
      'cp1256'                => 'Encode::Byte',
      'cp1257'                => 'Encode::Byte',
      'cp1258'                => 'Encode::Byte',
      'AdobeStandardEncoding' => 'Encode::Byte',
      'MacArabic'             => 'Encode::Byte',
      'MacCentralEurRoman'    => 'Encode::Byte',
      'MacCroatian'           => 'Encode::Byte',
      'MacCyrillic'           => 'Encode::Byte',
      'MacFarsi'              => 'Encode::Byte',
      'MacGreek'              => 'Encode::Byte',
      'MacHebrew'             => 'Encode::Byte',
      'MacIcelandic'          => 'Encode::Byte',
      'MacRoman'              => 'Encode::Byte',
      'MacRomanian'           => 'Encode::Byte',
      'MacRumanian'           => 'Encode::Byte',
      'MacSami'               => 'Encode::Byte',
      'MacThai'               => 'Encode::Byte',
      'MacTurkish'            => 'Encode::Byte',
      'MacUkrainian'          => 'Encode::Byte',
      'nextstep'              => 'Encode::Byte',
      'hp-roman8'             => 'Encode::Byte',
      #'gsm0338'               => 'Encode::Byte',
      'gsm0338'               => 'Encode::GSM0338',
  
      # Encode::EBCDIC
      'cp37'     => 'Encode::EBCDIC',
      'cp500'    => 'Encode::EBCDIC',
      'cp875'    => 'Encode::EBCDIC',
      'cp1026'   => 'Encode::EBCDIC',
      'cp1047'   => 'Encode::EBCDIC',
      'posix-bc' => 'Encode::EBCDIC',
  
      # Encode::Symbol
      'dingbats'      => 'Encode::Symbol',
      'symbol'        => 'Encode::Symbol',
      'AdobeSymbol'   => 'Encode::Symbol',
      'AdobeZdingbat' => 'Encode::Symbol',
      'MacDingbats'   => 'Encode::Symbol',
      'MacSymbol'     => 'Encode::Symbol',
  
      # Encode::Unicode
      'UCS-2BE'  => 'Encode::Unicode',
      'UCS-2LE'  => 'Encode::Unicode',
      'UTF-16'   => 'Encode::Unicode',
      'UTF-16BE' => 'Encode::Unicode',
      'UTF-16LE' => 'Encode::Unicode',
      'UTF-32'   => 'Encode::Unicode',
      'UTF-32BE' => 'Encode::Unicode',
      'UTF-32LE' => 'Encode::Unicode',
      'UTF-7'    => 'Encode::Unicode::UTF7',
  );
  
  unless ( ord("A") == 193 ) {
      %ExtModule = (
          %ExtModule,
          'euc-cn'         => 'Encode::CN',
          'gb12345-raw'    => 'Encode::CN',
          'gb2312-raw'     => 'Encode::CN',
          'hz'             => 'Encode::CN',
          'iso-ir-165'     => 'Encode::CN',
          'cp936'          => 'Encode::CN',
          'MacChineseSimp' => 'Encode::CN',
  
          '7bit-jis'      => 'Encode::JP',
          'euc-jp'        => 'Encode::JP',
          'iso-2022-jp'   => 'Encode::JP',
          'iso-2022-jp-1' => 'Encode::JP',
          'jis0201-raw'   => 'Encode::JP',
          'jis0208-raw'   => 'Encode::JP',
          'jis0212-raw'   => 'Encode::JP',
          'cp932'         => 'Encode::JP',
          'MacJapanese'   => 'Encode::JP',
          'shiftjis'      => 'Encode::JP',
  
          'euc-kr'      => 'Encode::KR',
          'iso-2022-kr' => 'Encode::KR',
          'johab'       => 'Encode::KR',
          'ksc5601-raw' => 'Encode::KR',
          'cp949'       => 'Encode::KR',
          'MacKorean'   => 'Encode::KR',
  
          'big5-eten'      => 'Encode::TW',
          'big5-hkscs'     => 'Encode::TW',
          'cp950'          => 'Encode::TW',
          'MacChineseTrad' => 'Encode::TW',
  
          #'big5plus'           => 'Encode::HanExtra',
          #'euc-tw'             => 'Encode::HanExtra',
          #'gb18030'            => 'Encode::HanExtra',
  
          'MIME-Header' => 'Encode::MIME::Header',
          'MIME-B'      => 'Encode::MIME::Header',
          'MIME-Q'      => 'Encode::MIME::Header',
  
          'MIME-Header-ISO_2022_JP' => 'Encode::MIME::Header::ISO_2022_JP',
      );
  }
  
  #
  # Why not export ? to keep ConfigLocal Happy!
  #
  while ( my ( $enc, $mod ) = each %ExtModule ) {
      $Encode::ExtModule{$enc} = $mod;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::Config -- internally used by Encode
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_CONFIG

$fatpacked{"x86_64-linux-gnu-thread-multi/Encode/EBCDIC.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_EBCDIC';
  package Encode::EBCDIC;
  use strict;
  use warnings;
  use Encode;
  our $VERSION = do { my @r = ( q$Revision: 2.2 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use XSLoader;
  XSLoader::load( __PACKAGE__, $VERSION );
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::EBCDIC - EBCDIC Encodings
  
  =head1 SYNOPSIS
  
      use Encode qw/encode decode/; 
      $posix_bc  = encode("posix-bc", $utf8); # loads Encode::EBCDIC implicitly
      $utf8 = decode("", $posix_bc);          # ditto
  
  =head1 ABSTRACT
  
  This module implements various EBCDIC-Based encodings.  Encodings
  supported are as follows.   
  
    Canonical   Alias		Description
    --------------------------------------------------------------------
    cp37  
    cp500  
    cp875  
    cp1026  
    cp1047  
    posix-bc
  
  =head1 DESCRIPTION
  
  To find how to use this module in detail, see L<Encode>.
  
  =head1 SEE ALSO
  
  L<Encode>, L<perlebcdic>
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_EBCDIC

$fatpacked{"x86_64-linux-gnu-thread-multi/Encode/Encoder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_ENCODER';
  #
  # $Id: Encoder.pm,v 2.3 2013/09/14 07:51:59 dankogai Exp $
  #
  package Encode::Encoder;
  use strict;
  use warnings;
  our $VERSION = do { my @r = ( q$Revision: 2.3 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  require Exporter;
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw ( encoder );
  
  our $AUTOLOAD;
  use constant DEBUG => !!$ENV{PERL_ENCODE_DEBUG};
  use Encode qw(encode decode find_encoding from_to);
  use Carp;
  
  sub new {
      my ( $class, $data, $encname ) = @_;
      unless ($encname) {
          $encname = Encode::is_utf8($data) ? 'utf8' : '';
      }
      else {
          my $obj = find_encoding($encname)
            or croak __PACKAGE__, ": unknown encoding: $encname";
          $encname = $obj->name;
      }
      my $self = {
          data     => $data,
          encoding => $encname,
      };
      bless $self => $class;
  }
  
  sub encoder { __PACKAGE__->new(@_) }
  
  sub data {
      my ( $self, $data ) = @_;
      if ( defined $data ) {
          $self->{data} = $data;
          return $data;
      }
      else {
          return $self->{data};
      }
  }
  
  sub encoding {
      my ( $self, $encname ) = @_;
      if ($encname) {
          my $obj = find_encoding($encname)
            or confess __PACKAGE__, ": unknown encoding: $encname";
          $self->{encoding} = $obj->name;
          return $self;
      }
      else {
          return $self->{encoding};
      }
  }
  
  sub bytes {
      my ( $self, $encname ) = @_;
      $encname ||= $self->{encoding};
      my $obj = find_encoding($encname)
        or confess __PACKAGE__, ": unknown encoding: $encname";
      $self->{data} = $obj->decode( $self->{data}, 1 );
      $self->{encoding} = '';
      return $self;
  }
  
  sub DESTROY {    # defined so it won't autoload.
      DEBUG and warn shift;
  }
  
  sub AUTOLOAD {
      my $self = shift;
      my $type = ref($self)
        or confess "$self is not an object";
      my $myname = $AUTOLOAD;
      $myname =~ s/.*://;    # strip fully-qualified portion
      my $obj = find_encoding($myname)
        or confess __PACKAGE__, ": unknown encoding: $myname";
      DEBUG and warn $self->{encoding}, " => ", $obj->name;
      if ( $self->{encoding} ) {
          from_to( $self->{data}, $self->{encoding}, $obj->name, 1 );
      }
      else {
          $self->{data} = $obj->encode( $self->{data}, 1 );
      }
      $self->{encoding} = $obj->name;
      return $self;
  }
  
  use overload
    q("") => sub { $_[0]->{data} },
    q(0+) => sub { use bytes(); bytes::length( $_[0]->{data} ) },
    fallback => 1,
    ;
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::Encoder -- Object Oriented Encoder
  
  =head1 SYNOPSIS
  
    use Encode::Encoder;
    # Encode::encode("ISO-8859-1", $data); 
    Encode::Encoder->new($data)->iso_8859_1; # OOP way
    # shortcut
    use Encode::Encoder qw(encoder);
    encoder($data)->iso_8859_1;
    # you can stack them!
    encoder($data)->iso_8859_1->base64;  # provided base64() is defined
    # you can use it as a decoder as well
    encoder($base64)->bytes('base64')->latin1;
    # stringified
    print encoder($data)->utf8->latin1;  # prints the string in latin1
    # numified
    encoder("\x{abcd}\x{ef}g")->utf8 == 6; # true. bytes::length($data)
  
  =head1 ABSTRACT
  
  B<Encode::Encoder> allows you to use Encode in an object-oriented
  style.  This is not only more intuitive than a functional approach,
  but also handier when you want to stack encodings.  Suppose you want
  your UTF-8 string converted to Latin1 then Base64: you can simply say
  
    my $base64 = encoder($utf8)->latin1->base64;
  
  instead of
  
    my $latin1 = encode("latin1", $utf8);
    my $base64 = encode_base64($utf8);
  
  or the lazier and more convoluted
  
    my $base64 = encode_base64(encode("latin1", $utf8));
  
  =head1 Description
  
  Here is how to use this module.
  
  =over 4
  
  =item *
  
  There are at least two instance variables stored in a hash reference,
  {data} and {encoding}.
  
  =item *
  
  When there is no method, it takes the method name as the name of the
  encoding and encodes the instance I<data> with I<encoding>.  If successful,
  the instance I<encoding> is set accordingly.
  
  =item *
  
  You can retrieve the result via -E<gt>data but usually you don't have to 
  because the stringify operator ("") is overridden to do exactly that.
  
  =back
  
  =head2 Predefined Methods
  
  This module predefines the methods below:
  
  =over 4
  
  =item $e = Encode::Encoder-E<gt>new([$data, $encoding]);
  
  returns an encoder object.  Its data is initialized with $data if
  present, and its encoding is set to $encoding if present.
  
  When $encoding is omitted, it defaults to utf8 if $data is already in
  utf8 or "" (empty string) otherwise.
  
  =item encoder()
  
  is an alias of Encode::Encoder-E<gt>new().  This one is exported on demand.
  
  =item $e-E<gt>data([$data])
  
  When $data is present, sets the instance data to $data and returns the
  object itself.  Otherwise, the current instance data is returned.
  
  =item $e-E<gt>encoding([$encoding])
  
  When $encoding is present, sets the instance encoding to $encoding and
  returns the object itself.  Otherwise, the current instance encoding is
  returned.
  
  =item $e-E<gt>bytes([$encoding])
  
  decodes instance data from $encoding, or the instance encoding if
  omitted.  If the conversion is successful, the instance encoding
  will be set to "".
  
  The name I<bytes> was deliberately picked to avoid namespace tainting
  -- this module may be used as a base class so method names that appear
  in Encode::Encoding are avoided.
  
  =back
  
  =head2 Example: base64 transcoder
  
  This module is designed to work with L<Encode::Encoding>.
  To make the Base64 transcoder example above really work, you could
  write a module like this:
  
    package Encode::Base64;
    use parent 'Encode::Encoding';
    __PACKAGE__->Define('base64');
    use MIME::Base64;
    sub encode{ 
        my ($obj, $data) = @_; 
        return encode_base64($data);
    }
    sub decode{
        my ($obj, $data) = @_; 
        return decode_base64($data);
    }
    1;
    __END__
  
  And your caller module would be something like this:
  
    use Encode::Encoder;
    use Encode::Base64;
  
    # now you can really do the following
  
    encoder($data)->iso_8859_1->base64;
    encoder($base64)->bytes('base64')->latin1;
  
  =head2 Operator Overloading
  
  This module overloads two operators, stringify ("") and numify (0+).
  
  Stringify dumps the data inside the object.
  
  Numify returns the number of bytes in the instance data.
  
  They come in handy when you want to print or find the size of data.
  
  =head1 SEE ALSO
  
  L<Encode>,
  L<Encode::Encoding>
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_ENCODER

$fatpacked{"x86_64-linux-gnu-thread-multi/Encode/Encoding.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_ENCODING';
  package Encode::Encoding;
  
  # Base class for classes which implement encodings
  use strict;
  use warnings;
  our $VERSION = do { my @r = ( q$Revision: 2.8 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  our @CARP_NOT = qw(Encode Encode::Encoder);
  
  use Carp ();
  use Encode ();
  use Encode::MIME::Name;
  
  use constant DEBUG => !!$ENV{PERL_ENCODE_DEBUG};
  
  sub Define {
      my $obj       = shift;
      my $canonical = shift;
      $obj = bless { Name => $canonical }, $obj unless ref $obj;
  
      # warn "$canonical => $obj\n";
      Encode::define_encoding( $obj, $canonical, @_ );
  }
  
  sub name { return shift->{'Name'} }
  
  sub mime_name {
      return Encode::MIME::Name::get_mime_name(shift->name);
  }
  
  sub renew {
      my $self = shift;
      my $clone = bless {%$self} => ref($self);
      $clone->{renewed}++;    # so the caller can see it
      DEBUG and warn $clone->{renewed};
      return $clone;
  }
  
  sub renewed { return $_[0]->{renewed} || 0 }
  
  *new_sequence = \&renew;
  
  sub needs_lines { 0 }
  
  sub perlio_ok {
      return eval { require PerlIO::encoding } ? 1 : 0;
  }
  
  # (Temporary|legacy) methods
  
  sub toUnicode   { shift->decode(@_) }
  sub fromUnicode { shift->encode(@_) }
  
  #
  # Needs to be overloaded or just croak
  #
  
  sub encode {
      my $obj = shift;
      my $class = ref($obj) ? ref($obj) : $obj;
      Carp::croak( $class . "->encode() not defined!" );
  }
  
  sub decode {
      my $obj = shift;
      my $class = ref($obj) ? ref($obj) : $obj;
      Carp::croak( $class . "->encode() not defined!" );
  }
  
  sub DESTROY { }
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::Encoding - Encode Implementation Base Class
  
  =head1 SYNOPSIS
  
    package Encode::MyEncoding;
    use parent qw(Encode::Encoding);
  
    __PACKAGE__->Define(qw(myCanonical myAlias));
  
  =head1 DESCRIPTION
  
  As mentioned in L<Encode>, encodings are (in the current
  implementation at least) defined as objects. The mapping of encoding
  name to object is via the C<%Encode::Encoding> hash.  Though you can
  directly manipulate this hash, it is strongly encouraged to use this
  base class module and add encode() and decode() methods.
  
  =head2 Methods you should implement
  
  You are strongly encouraged to implement methods below, at least
  either encode() or decode().
  
  =over 4
  
  =item -E<gt>encode($string [,$check])
  
  MUST return the octet sequence representing I<$string>. 
  
  =over 2
  
  =item *
  
  If I<$check> is true, it SHOULD modify I<$string> in place to remove
  the converted part (i.e.  the whole string unless there is an error).
  If perlio_ok() is true, SHOULD becomes MUST.
  
  =item *
  
  If an error occurs, it SHOULD return the octet sequence for the
  fragment of string that has been converted and modify $string in-place
  to remove the converted part leaving it starting with the problem
  fragment.  If perlio_ok() is true, SHOULD becomes MUST.
  
  =item *
  
  If I<$check> is false then C<encode> MUST  make a "best effort" to
  convert the string - for example, by using a replacement character.
  
  =back
  
  =item -E<gt>decode($octets [,$check])
  
  MUST return the string that I<$octets> represents.
  
  =over 2
  
  =item *
  
  If I<$check> is true, it SHOULD modify I<$octets> in place to remove
  the converted part (i.e.  the whole sequence unless there is an
  error).  If perlio_ok() is true, SHOULD becomes MUST.
  
  =item *
  
  If an error occurs, it SHOULD return the fragment of string that has
  been converted and modify $octets in-place to remove the converted
  part leaving it starting with the problem fragment.  If perlio_ok() is
  true, SHOULD becomes MUST.
  
  =item *
  
  If I<$check> is false then C<decode> should make a "best effort" to
  convert the string - for example by using Unicode's "\x{FFFD}" as a
  replacement character.
  
  =back
  
  =back
  
  If you want your encoding to work with L<encoding> pragma, you should
  also implement the method below.
  
  =over 4
  
  =item -E<gt>cat_decode($destination, $octets, $offset, $terminator [,$check])
  
  MUST decode I<$octets> with I<$offset> and concatenate it to I<$destination>.
  Decoding will terminate when $terminator (a string) appears in output.
  I<$offset> will be modified to the last $octets position at end of decode.
  Returns true if $terminator appears output, else returns false.
  
  =back
  
  =head2 Other methods defined in Encode::Encodings
  
  You do not have to override methods shown below unless you have to.
  
  =over 4
  
  =item -E<gt>name
  
  Predefined As:
  
    sub name  { return shift->{'Name'} }
  
  MUST return the string representing the canonical name of the encoding.
  
  =item -E<gt>mime_name
  
  Predefined As:
  
    sub mime_name{
      return Encode::MIME::Name::get_mime_name(shift->name);
    }
  
  MUST return the string representing the IANA charset name of the encoding.
  
  =item -E<gt>renew
  
  Predefined As:
  
    sub renew {
      my $self = shift;
      my $clone = bless { %$self } => ref($self);
      $clone->{renewed}++;
      return $clone;
    }
  
  This method reconstructs the encoding object if necessary.  If you need
  to store the state during encoding, this is where you clone your object.
  
  PerlIO ALWAYS calls this method to make sure it has its own private
  encoding object.
  
  =item -E<gt>renewed
  
  Predefined As:
  
    sub renewed { $_[0]->{renewed} || 0 }
  
  Tells whether the object is renewed (and how many times).  Some
  modules emit C<Use of uninitialized value in null operation> warning
  unless the value is numeric so return 0 for false.
  
  =item -E<gt>perlio_ok()
  
  Predefined As:
  
    sub perlio_ok { 
      return eval { require PerlIO::encoding } ? 1 : 0;
    }
  
  If your encoding does not support PerlIO for some reasons, just;
  
   sub perlio_ok { 0 }
  
  =item -E<gt>needs_lines()
  
  Predefined As:
  
    sub needs_lines { 0 };
  
  If your encoding can work with PerlIO but needs line buffering, you
  MUST define this method so it returns true.  7bit ISO-2022 encodings
  are one example that needs this.  When this method is missing, false
  is assumed.
  
  =back
  
  =head2 Example: Encode::ROT13
  
    package Encode::ROT13;
    use strict;
    use parent qw(Encode::Encoding);
  
    __PACKAGE__->Define('rot13');
  
    sub encode($$;$){
        my ($obj, $str, $chk) = @_;
        $str =~ tr/A-Za-z/N-ZA-Mn-za-m/;
        $_[1] = '' if $chk; # this is what in-place edit means
        return $str;
    }
  
    # Jr pna or ynml yvxr guvf;
    *decode = \&encode;
  
    1;
  
  =head1 Why the heck Encode API is different?
  
  It should be noted that the I<$check> behaviour is different from the
  outer public API. The logic is that the "unchecked" case is useful
  when the encoding is part of a stream which may be reporting errors
  (e.g. STDERR).  In such cases, it is desirable to get everything
  through somehow without causing additional errors which obscure the
  original one. Also, the encoding is best placed to know what the
  correct replacement character is, so if that is the desired behaviour
  then letting low level code do it is the most efficient.
  
  By contrast, if I<$check> is true, the scheme above allows the
  encoding to do as much as it can and tell the layer above how much
  that was. What is lacking at present is a mechanism to report what
  went wrong. The most likely interface will be an additional method
  call to the object, or perhaps (to avoid forcing per-stream objects
  on otherwise stateless encodings) an additional parameter.
  
  It is also highly desirable that encoding classes inherit from
  C<Encode::Encoding> as a base class. This allows that class to define
  additional behaviour for all encoding objects.
  
    package Encode::MyEncoding;
    use parent qw(Encode::Encoding);
  
    __PACKAGE__->Define(qw(myCanonical myAlias));
  
  to create an object with C<< bless {Name => ...}, $class >>, and call
  define_encoding.  They inherit their C<name> method from
  C<Encode::Encoding>.
  
  =head2 Compiled Encodings
  
  For the sake of speed and efficiency, most of the encodings are now
  supported via a I<compiled form>: XS modules generated from UCM
  files.   Encode provides the enc2xs tool to achieve that.  Please see
  L<enc2xs> for more details.
  
  =head1 SEE ALSO
  
  L<perlmod>, L<enc2xs>
  
  =begin future
  
  =over 4
  
  =item Scheme 1
  
  The fixup routine gets passed the remaining fragment of string being
  processed.  It modifies it in place to remove bytes/characters it can
  understand and returns a string used to represent them.  For example:
  
   sub fixup {
     my $ch = substr($_[0],0,1,'');
     return sprintf("\x{%02X}",ord($ch);
   }
  
  This scheme is close to how the underlying C code for Encode works,
  but gives the fixup routine very little context.
  
  =item Scheme 2
  
  The fixup routine gets passed the original string, an index into
  it of the problem area, and the output string so far.  It appends
  what it wants to the output string and returns a new index into the
  original string.  For example:
  
   sub fixup {
     # my ($s,$i,$d) = @_;
     my $ch = substr($_[0],$_[1],1);
     $_[2] .= sprintf("\x{%02X}",ord($ch);
     return $_[1]+1;
   }
  
  This scheme gives maximal control to the fixup routine but is more
  complicated to code, and may require that the internals of Encode be tweaked to
  keep the original string intact.
  
  =item Other Schemes
  
  Hybrids of the above.
  
  Multiple return values rather than in-place modifications.
  
  Index into the string could be C<pos($str)> allowing C<s/\G...//>.
  
  =back
  
  =end future
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_ENCODING

$fatpacked{"x86_64-linux-gnu-thread-multi/Encode/GSM0338.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_GSM0338';
  #
  # $Id: GSM0338.pm,v 2.10 2021/05/24 10:56:53 dankogai Exp $
  #
  package Encode::GSM0338;
  
  use strict;
  use warnings;
  use Carp;
  
  use vars qw($VERSION);
  $VERSION = do { my @r = ( q$Revision: 2.10 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use Encode qw(:fallbacks);
  
  use parent qw(Encode::Encoding);
  __PACKAGE__->Define('gsm0338');
  
  use utf8;
  
  # Mapping table according to 3GPP TS 23.038 version 16.0.0 Release 16 and ETSI TS 123 038 V16.0.0 (2020-07)
  # https://www.etsi.org/deliver/etsi_ts/123000_123099/123038/16.00.00_60/ts_123038v160000p.pdf (page 20 and 22)
  our %UNI2GSM = (
      "\x{000A}" => "\x0A",        # LINE FEED
      "\x{000C}" => "\x1B\x0A",    # FORM FEED
      "\x{000D}" => "\x0D",        # CARRIAGE RETURN
      "\x{0020}" => "\x20",        # SPACE
      "\x{0021}" => "\x21",        # EXCLAMATION MARK
      "\x{0022}" => "\x22",        # QUOTATION MARK
      "\x{0023}" => "\x23",        # NUMBER SIGN
      "\x{0024}" => "\x02",        # DOLLAR SIGN
      "\x{0025}" => "\x25",        # PERCENT SIGN
      "\x{0026}" => "\x26",        # AMPERSAND
      "\x{0027}" => "\x27",        # APOSTROPHE
      "\x{0028}" => "\x28",        # LEFT PARENTHESIS
      "\x{0029}" => "\x29",        # RIGHT PARENTHESIS
      "\x{002A}" => "\x2A",        # ASTERISK
      "\x{002B}" => "\x2B",        # PLUS SIGN
      "\x{002C}" => "\x2C",        # COMMA
      "\x{002D}" => "\x2D",        # HYPHEN-MINUS
      "\x{002E}" => "\x2E",        # FULL STOP
      "\x{002F}" => "\x2F",        # SOLIDUS
      "\x{0030}" => "\x30",        # DIGIT ZERO
      "\x{0031}" => "\x31",        # DIGIT ONE
      "\x{0032}" => "\x32",        # DIGIT TWO
      "\x{0033}" => "\x33",        # DIGIT THREE
      "\x{0034}" => "\x34",        # DIGIT FOUR
      "\x{0035}" => "\x35",        # DIGIT FIVE
      "\x{0036}" => "\x36",        # DIGIT SIX
      "\x{0037}" => "\x37",        # DIGIT SEVEN
      "\x{0038}" => "\x38",        # DIGIT EIGHT
      "\x{0039}" => "\x39",        # DIGIT NINE
      "\x{003A}" => "\x3A",        # COLON
      "\x{003B}" => "\x3B",        # SEMICOLON
      "\x{003C}" => "\x3C",        # LESS-THAN SIGN
      "\x{003D}" => "\x3D",        # EQUALS SIGN
      "\x{003E}" => "\x3E",        # GREATER-THAN SIGN
      "\x{003F}" => "\x3F",        # QUESTION MARK
      "\x{0040}" => "\x00",        # COMMERCIAL AT
      "\x{0041}" => "\x41",        # LATIN CAPITAL LETTER A
      "\x{0042}" => "\x42",        # LATIN CAPITAL LETTER B
      "\x{0043}" => "\x43",        # LATIN CAPITAL LETTER C
      "\x{0044}" => "\x44",        # LATIN CAPITAL LETTER D
      "\x{0045}" => "\x45",        # LATIN CAPITAL LETTER E
      "\x{0046}" => "\x46",        # LATIN CAPITAL LETTER F
      "\x{0047}" => "\x47",        # LATIN CAPITAL LETTER G
      "\x{0048}" => "\x48",        # LATIN CAPITAL LETTER H
      "\x{0049}" => "\x49",        # LATIN CAPITAL LETTER I
      "\x{004A}" => "\x4A",        # LATIN CAPITAL LETTER J
      "\x{004B}" => "\x4B",        # LATIN CAPITAL LETTER K
      "\x{004C}" => "\x4C",        # LATIN CAPITAL LETTER L
      "\x{004D}" => "\x4D",        # LATIN CAPITAL LETTER M
      "\x{004E}" => "\x4E",        # LATIN CAPITAL LETTER N
      "\x{004F}" => "\x4F",        # LATIN CAPITAL LETTER O
      "\x{0050}" => "\x50",        # LATIN CAPITAL LETTER P
      "\x{0051}" => "\x51",        # LATIN CAPITAL LETTER Q
      "\x{0052}" => "\x52",        # LATIN CAPITAL LETTER R
      "\x{0053}" => "\x53",        # LATIN CAPITAL LETTER S
      "\x{0054}" => "\x54",        # LATIN CAPITAL LETTER T
      "\x{0055}" => "\x55",        # LATIN CAPITAL LETTER U
      "\x{0056}" => "\x56",        # LATIN CAPITAL LETTER V
      "\x{0057}" => "\x57",        # LATIN CAPITAL LETTER W
      "\x{0058}" => "\x58",        # LATIN CAPITAL LETTER X
      "\x{0059}" => "\x59",        # LATIN CAPITAL LETTER Y
      "\x{005A}" => "\x5A",        # LATIN CAPITAL LETTER Z
      "\x{005B}" => "\x1B\x3C",    # LEFT SQUARE BRACKET
      "\x{005C}" => "\x1B\x2F",    # REVERSE SOLIDUS
      "\x{005D}" => "\x1B\x3E",    # RIGHT SQUARE BRACKET
      "\x{005E}" => "\x1B\x14",    # CIRCUMFLEX ACCENT
      "\x{005F}" => "\x11",        # LOW LINE
      "\x{0061}" => "\x61",        # LATIN SMALL LETTER A
      "\x{0062}" => "\x62",        # LATIN SMALL LETTER B
      "\x{0063}" => "\x63",        # LATIN SMALL LETTER C
      "\x{0064}" => "\x64",        # LATIN SMALL LETTER D
      "\x{0065}" => "\x65",        # LATIN SMALL LETTER E
      "\x{0066}" => "\x66",        # LATIN SMALL LETTER F
      "\x{0067}" => "\x67",        # LATIN SMALL LETTER G
      "\x{0068}" => "\x68",        # LATIN SMALL LETTER H
      "\x{0069}" => "\x69",        # LATIN SMALL LETTER I
      "\x{006A}" => "\x6A",        # LATIN SMALL LETTER J
      "\x{006B}" => "\x6B",        # LATIN SMALL LETTER K
      "\x{006C}" => "\x6C",        # LATIN SMALL LETTER L
      "\x{006D}" => "\x6D",        # LATIN SMALL LETTER M
      "\x{006E}" => "\x6E",        # LATIN SMALL LETTER N
      "\x{006F}" => "\x6F",        # LATIN SMALL LETTER O
      "\x{0070}" => "\x70",        # LATIN SMALL LETTER P
      "\x{0071}" => "\x71",        # LATIN SMALL LETTER Q
      "\x{0072}" => "\x72",        # LATIN SMALL LETTER R
      "\x{0073}" => "\x73",        # LATIN SMALL LETTER S
      "\x{0074}" => "\x74",        # LATIN SMALL LETTER T
      "\x{0075}" => "\x75",        # LATIN SMALL LETTER U
      "\x{0076}" => "\x76",        # LATIN SMALL LETTER V
      "\x{0077}" => "\x77",        # LATIN SMALL LETTER W
      "\x{0078}" => "\x78",        # LATIN SMALL LETTER X
      "\x{0079}" => "\x79",        # LATIN SMALL LETTER Y
      "\x{007A}" => "\x7A",        # LATIN SMALL LETTER Z
      "\x{007B}" => "\x1B\x28",    # LEFT CURLY BRACKET
      "\x{007C}" => "\x1B\x40",    # VERTICAL LINE
      "\x{007D}" => "\x1B\x29",    # RIGHT CURLY BRACKET
      "\x{007E}" => "\x1B\x3D",    # TILDE
      "\x{00A1}" => "\x40",        # INVERTED EXCLAMATION MARK
      "\x{00A3}" => "\x01",        # POUND SIGN
      "\x{00A4}" => "\x24",        # CURRENCY SIGN
      "\x{00A5}" => "\x03",        # YEN SIGN
      "\x{00A7}" => "\x5F",        # SECTION SIGN
      "\x{00BF}" => "\x60",        # INVERTED QUESTION MARK
      "\x{00C4}" => "\x5B",        # LATIN CAPITAL LETTER A WITH DIAERESIS
      "\x{00C5}" => "\x0E",        # LATIN CAPITAL LETTER A WITH RING ABOVE
      "\x{00C6}" => "\x1C",        # LATIN CAPITAL LETTER AE
      "\x{00C7}" => "\x09",        # LATIN CAPITAL LETTER C WITH CEDILLA
      "\x{00C9}" => "\x1F",        # LATIN CAPITAL LETTER E WITH ACUTE
      "\x{00D1}" => "\x5D",        # LATIN CAPITAL LETTER N WITH TILDE
      "\x{00D6}" => "\x5C",        # LATIN CAPITAL LETTER O WITH DIAERESIS
      "\x{00D8}" => "\x0B",        # LATIN CAPITAL LETTER O WITH STROKE
      "\x{00DC}" => "\x5E",        # LATIN CAPITAL LETTER U WITH DIAERESIS
      "\x{00DF}" => "\x1E",        # LATIN SMALL LETTER SHARP S
      "\x{00E0}" => "\x7F",        # LATIN SMALL LETTER A WITH GRAVE
      "\x{00E4}" => "\x7B",        # LATIN SMALL LETTER A WITH DIAERESIS
      "\x{00E5}" => "\x0F",        # LATIN SMALL LETTER A WITH RING ABOVE
      "\x{00E6}" => "\x1D",        # LATIN SMALL LETTER AE
      "\x{00E8}" => "\x04",        # LATIN SMALL LETTER E WITH GRAVE
      "\x{00E9}" => "\x05",        # LATIN SMALL LETTER E WITH ACUTE
      "\x{00EC}" => "\x07",        # LATIN SMALL LETTER I WITH GRAVE
      "\x{00F1}" => "\x7D",        # LATIN SMALL LETTER N WITH TILDE
      "\x{00F2}" => "\x08",        # LATIN SMALL LETTER O WITH GRAVE
      "\x{00F6}" => "\x7C",        # LATIN SMALL LETTER O WITH DIAERESIS
      "\x{00F8}" => "\x0C",        # LATIN SMALL LETTER O WITH STROKE
      "\x{00F9}" => "\x06",        # LATIN SMALL LETTER U WITH GRAVE
      "\x{00FC}" => "\x7E",        # LATIN SMALL LETTER U WITH DIAERESIS
      "\x{0393}" => "\x13",        # GREEK CAPITAL LETTER GAMMA
      "\x{0394}" => "\x10",        # GREEK CAPITAL LETTER DELTA
      "\x{0398}" => "\x19",        # GREEK CAPITAL LETTER THETA
      "\x{039B}" => "\x14",        # GREEK CAPITAL LETTER LAMDA
      "\x{039E}" => "\x1A",        # GREEK CAPITAL LETTER XI
      "\x{03A0}" => "\x16",        # GREEK CAPITAL LETTER PI
      "\x{03A3}" => "\x18",        # GREEK CAPITAL LETTER SIGMA
      "\x{03A6}" => "\x12",        # GREEK CAPITAL LETTER PHI
      "\x{03A8}" => "\x17",        # GREEK CAPITAL LETTER PSI
      "\x{03A9}" => "\x15",        # GREEK CAPITAL LETTER OMEGA
      "\x{20AC}" => "\x1B\x65",    # EURO SIGN
  );
  our %GSM2UNI = reverse %UNI2GSM;
  our $ESC     = "\x1b";
  
  sub decode ($$;$) {
      my ( $obj, $bytes, $chk ) = @_;
      return undef unless defined $bytes;
      my $str = substr( $bytes, 0, 0 );    # to propagate taintedness;
      while ( length $bytes ) {
          my $seq = '';
          my $c;
          do {
              $c = substr( $bytes, 0, 1, '' );
              $seq .= $c;
          } while ( length $bytes and $c eq $ESC );
          my $u =
              exists $GSM2UNI{$seq}          ? $GSM2UNI{$seq}
            : ( $chk && ref $chk eq 'CODE' ) ? $chk->( unpack 'C*', $seq )
            :                                  "\x{FFFD}";
          if ( not exists $GSM2UNI{$seq} and $chk and not ref $chk ) {
              if ( substr( $seq, 0, 1 ) eq $ESC
                  and ( $chk & Encode::STOP_AT_PARTIAL ) )
              {
                  $bytes .= $seq;
                  last;
              }
              croak join( '', map { sprintf "\\x%02X", $_ } unpack 'C*', $seq )
                . ' does not map to Unicode'
                if $chk & Encode::DIE_ON_ERR;
              carp join( '', map { sprintf "\\x%02X", $_ } unpack 'C*', $seq )
                . ' does not map to Unicode'
                if $chk & Encode::WARN_ON_ERR;
              if ( $chk & Encode::RETURN_ON_ERR ) {
                  $bytes .= $seq;
                  last;
              }
          }
          $str .= $u;
      }
      $_[1] = $bytes if not ref $chk and $chk and !( $chk & Encode::LEAVE_SRC );
      return $str;
  }
  
  sub encode($$;$) {
      my ( $obj, $str, $chk ) = @_;
      return undef unless defined $str;
      my $bytes = substr( $str, 0, 0 );    # to propagate taintedness
      while ( length $str ) {
          my $u = substr( $str, 0, 1, '' );
          my $c;
          my $seq =
              exists $UNI2GSM{$u}            ? $UNI2GSM{$u}
            : ( $chk && ref $chk eq 'CODE' ) ? $chk->( ord($u) )
            :                                  $UNI2GSM{'?'};
          if ( not exists $UNI2GSM{$u} and $chk and not ref $chk ) {
              croak sprintf( "\\x{%04x} does not map to %s", ord($u), $obj->name )
                if $chk & Encode::DIE_ON_ERR;
              carp sprintf( "\\x{%04x} does not map to %s", ord($u), $obj->name )
                if $chk & Encode::WARN_ON_ERR;
              if ( $chk & Encode::RETURN_ON_ERR ) {
                  $str .= $u;
                  last;
              }
          }
          $bytes .= $seq;
      }
      $_[1] = $str if not ref $chk and $chk and !( $chk & Encode::LEAVE_SRC );
      return $bytes;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::GSM0338 -- ETSI GSM 03.38 Encoding
  
  =head1 SYNOPSIS
  
    use Encode qw/encode decode/;
    $gsm0338 = encode("gsm0338", $unicode); # loads Encode::GSM0338 implicitly
    $unicode = decode("gsm0338", $gsm0338); # ditto
  
  =head1 DESCRIPTION
  
  GSM0338 is for GSM handsets. Though it shares alphanumerals with ASCII,
  control character ranges and other parts are mapped very differently,
  mainly to store Greek characters.  There are also escape sequences
  (starting with 0x1B) to cover e.g. the Euro sign.
  
  This was once handled by L<Encode::Bytes> but because of all those
  unusual specifications, Encode 2.20 has relocated the support to
  this module.
  
  This module implements only I<GSM 7 bit Default Alphabet> and
  I<GSM 7 bit default alphabet extension table> according to standard
  3GPP TS 23.038 version 16. Therefore I<National Language Single Shift>
  and I<National Language Locking Shift> are not implemented nor supported.
  
  =head2 Septets
  
  This modules operates with octets (like any other Encode module) and not
  with packed septets (unlike other GSM standards). Therefore for processing
  binary SMS or parts of GSM TPDU payload (3GPP TS 23.040) it is needed to do
  conversion between octets and packed septets. For this purpose perl's C<pack>
  and C<unpack> functions may be useful:
  
    $bytes = substr(pack('(b*)*', unpack '(A7)*', unpack 'b*', $septets), 0, $num_of_septets);
    $unicode = decode('GSM0338', $bytes);
  
    $bytes = encode('GSM0338', $unicode);
    $septets = pack 'b*', join '', map { substr $_, 0, 7 } unpack '(A8)*', unpack 'b*', $bytes;
    $num_of_septets = length $bytes;
  
  Please note that for correct decoding of packed septets it is required to
  know number of septets packed in binary buffer as binary buffer is always
  padded with zero bits and 7 zero bits represents character C<@>. Number
  of septets is also stored in TPDU payload when dealing with 3GPP TS 23.040.
  
  =head1 BUGS
  
  Encode::GSM0338 2.7 and older versions (part of Encode 3.06) incorrectly
  handled zero bytes (character C<@>). This was fixed in Encode::GSM0338
  version 2.8 (part of Encode 3.07).
  
  =head1 SEE ALSO
  
  L<3GPP TS 23.038|https://www.3gpp.org/dynareport/23038.htm>
  
  L<ETSI TS 123 038 V16.0.0 (2020-07)|https://www.etsi.org/deliver/etsi_ts/123000_123099/123038/16.00.00_60/ts_123038v160000p.pdf>
  
  L<Encode>
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_GSM0338

$fatpacked{"x86_64-linux-gnu-thread-multi/Encode/Guess.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_GUESS';
  package Encode::Guess;
  use strict;
  use warnings;
  use Encode qw(:fallbacks find_encoding);
  our $VERSION = do { my @r = ( q$Revision: 2.8 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  my $Canon = 'Guess';
  use constant DEBUG => !!$ENV{PERL_ENCODE_DEBUG};
  our %DEF_SUSPECTS = map { $_ => find_encoding($_) } qw(ascii utf8);
  my $obj = bless {
      Name     => $Canon,
      Suspects => {%DEF_SUSPECTS},
  } => __PACKAGE__;
  Encode::define_encoding($obj, $Canon);
  
  use parent qw(Encode::Encoding);
  sub needs_lines { 1 }
  sub perlio_ok   { 0 }
  
  our @EXPORT         = qw(guess_encoding);
  our $NoUTFAutoGuess = 0;
  our $UTF8_BOM       = pack( "C3", 0xef, 0xbb, 0xbf );
  
  sub import {    # Exporter not used so we do it on our own
      my $callpkg = caller;
      for my $item (@EXPORT) {
          no strict 'refs';
          *{"$callpkg\::$item"} = \&{"$item"};
      }
      set_suspects(@_);
  }
  
  sub set_suspects {
      my $class = shift;
      my $self = ref($class) ? $class : $Encode::Encoding{$Canon};
      $self->{Suspects} = {%DEF_SUSPECTS};
      $self->add_suspects(@_);
  }
  
  sub add_suspects {
      my $class = shift;
      my $self = ref($class) ? $class : $Encode::Encoding{$Canon};
      for my $c (@_) {
          my $e = find_encoding($c) or die "Unknown encoding: $c";
          $self->{Suspects}{ $e->name } = $e;
          DEBUG and warn "Added: ", $e->name;
      }
  }
  
  sub decode($$;$) {
      my ( $obj, $octet, $chk ) = @_;
      my $guessed = guess( $obj, $octet );
      unless ( ref($guessed) ) {
          require Carp;
          Carp::croak($guessed);
      }
      my $utf8 = $guessed->decode( $octet, $chk || 0 );
      $_[1] = $octet if $chk;
      return $utf8;
  }
  
  sub guess_encoding {
      guess( $Encode::Encoding{$Canon}, @_ );
  }
  
  sub guess {
      my $class = shift;
      my $obj   = ref($class) ? $class : $Encode::Encoding{$Canon};
      my $octet = shift;
  
      # sanity check
      return "Empty string, empty guess" unless defined $octet and length $octet;
  
      # cheat 0: utf8 flag;
      if ( Encode::is_utf8($octet) ) {
          return find_encoding('utf8') unless $NoUTFAutoGuess;
          Encode::_utf8_off($octet);
      }
  
      # cheat 1: BOM
      use Encode::Unicode;
      unless ($NoUTFAutoGuess) {
          my $BOM = pack( 'C3', unpack( "C3", $octet ) );
          return find_encoding('utf8')
            if ( defined $BOM and $BOM eq $UTF8_BOM );
          $BOM = unpack( 'N', $octet );
          return find_encoding('UTF-32')
            if ( defined $BOM and ( $BOM == 0xFeFF or $BOM == 0xFFFe0000 ) );
          $BOM = unpack( 'n', $octet );
          return find_encoding('UTF-16')
            if ( defined $BOM and ( $BOM == 0xFeFF or $BOM == 0xFFFe ) );
          if ( $octet =~ /\x00/o )
          {    # if \x00 found, we assume UTF-(16|32)(BE|LE)
              my $utf;
              my ( $be, $le ) = ( 0, 0 );
              if ( $octet =~ /\x00\x00/o ) {    # UTF-32(BE|LE) assumed
                  $utf = "UTF-32";
                  for my $char ( unpack( 'N*', $octet ) ) {
                      $char & 0x0000ffff and $be++;
                      $char & 0xffff0000 and $le++;
                  }
              }
              else {                            # UTF-16(BE|LE) assumed
                  $utf = "UTF-16";
                  for my $char ( unpack( 'n*', $octet ) ) {
                      $char & 0x00ff and $be++;
                      $char & 0xff00 and $le++;
                  }
              }
              DEBUG and warn "$utf, be == $be, le == $le";
              $be == $le
                and return
                "Encodings ambiguous between $utf BE and LE ($be, $le)";
              $utf .= ( $be > $le ) ? 'BE' : 'LE';
              return find_encoding($utf);
          }
      }
      my %try = %{ $obj->{Suspects} };
      for my $c (@_) {
          my $e = find_encoding($c) or die "Unknown encoding: $c";
          $try{ $e->name } = $e;
          DEBUG and warn "Added: ", $e->name;
      }
      my $nline = 1;
      for my $line ( split /\r\n?|\n/, $octet ) {
  
          # cheat 2 -- \e in the string
          if ( $line =~ /\e/o ) {
              my @keys = keys %try;
              delete @try{qw/utf8 ascii/};
              for my $k (@keys) {
                  ref( $try{$k} ) eq 'Encode::XS' and delete $try{$k};
              }
          }
          my %ok = %try;
  
          # warn join(",", keys %try);
          for my $k ( keys %try ) {
              my $scratch = $line;
              $try{$k}->decode( $scratch, FB_QUIET );
              if ( $scratch eq '' ) {
                  DEBUG and warn sprintf( "%4d:%-24s ok\n", $nline, $k );
              }
              else {
                  use bytes ();
                  DEBUG
                    and warn sprintf( "%4d:%-24s not ok; %d bytes left\n",
                      $nline, $k, bytes::length($scratch) );
                  delete $ok{$k};
              }
          }
          %ok or return "No appropriate encodings found!";
          if ( scalar( keys(%ok) ) == 1 ) {
              my ($retval) = values(%ok);
              return $retval;
          }
          %try = %ok;
          $nline++;
      }
      $try{ascii}
        or return "Encodings too ambiguous: " . join( " or ", keys %try );
      return $try{ascii};
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::Guess -- Guesses encoding from data
  
  =head1 SYNOPSIS
  
    # if you are sure $data won't contain anything bogus
  
    use Encode;
    use Encode::Guess qw/euc-jp shiftjis 7bit-jis/;
    my $utf8 = decode("Guess", $data);
    my $data = encode("Guess", $utf8);   # this doesn't work!
  
    # more elaborate way
    use Encode::Guess;
    my $enc = guess_encoding($data, qw/euc-jp shiftjis 7bit-jis/);
    ref($enc) or die "Can't guess: $enc"; # trap error this way
    $utf8 = $enc->decode($data);
    # or
    $utf8 = decode($enc->name, $data)
  
  =head1 ABSTRACT
  
  Encode::Guess enables you to guess in what encoding a given data is
  encoded, or at least tries to.  
  
  =head1 DESCRIPTION
  
  By default, it checks only ascii, utf8 and UTF-16/32 with BOM.
  
    use Encode::Guess; # ascii/utf8/BOMed UTF
  
  To use it more practically, you have to give the names of encodings to
  check (I<suspects> as follows).  The name of suspects can either be
  canonical names or aliases.
  
  CAVEAT: Unlike UTF-(16|32), BOM in utf8 is NOT AUTOMATICALLY STRIPPED.
  
   # tries all major Japanese Encodings as well
    use Encode::Guess qw/euc-jp shiftjis 7bit-jis/;
  
  If the C<$Encode::Guess::NoUTFAutoGuess> variable is set to a true
  value, no heuristics will be applied to UTF8/16/32, and the result
  will be limited to the suspects and C<ascii>.
  
  =over 4
  
  =item Encode::Guess->set_suspects
  
  You can also change the internal suspects list via C<set_suspects>
  method. 
  
    use Encode::Guess;
    Encode::Guess->set_suspects(qw/euc-jp shiftjis 7bit-jis/);
  
  =item Encode::Guess->add_suspects
  
  Or you can use C<add_suspects> method.  The difference is that
  C<set_suspects> flushes the current suspects list while
  C<add_suspects> adds.
  
    use Encode::Guess;
    Encode::Guess->add_suspects(qw/euc-jp shiftjis 7bit-jis/);
    # now the suspects are euc-jp,shiftjis,7bit-jis, AND
    # euc-kr,euc-cn, and big5-eten
    Encode::Guess->add_suspects(qw/euc-kr euc-cn big5-eten/);
  
  =item Encode::decode("Guess" ...)
  
  When you are content with suspects list, you can now
  
    my $utf8 = Encode::decode("Guess", $data);
  
  =item Encode::Guess->guess($data)
  
  But it will croak if:
  
  =over
  
  =item *
  
  Two or more suspects remain
  
  =item *
  
  No suspects left
  
  =back
  
  So you should instead try this;
  
    my $decoder = Encode::Guess->guess($data);
  
  On success, $decoder is an object that is documented in
  L<Encode::Encoding>.  So you can now do this;
  
    my $utf8 = $decoder->decode($data);
  
  On failure, $decoder now contains an error message so the whole thing
  would be as follows;
  
    my $decoder = Encode::Guess->guess($data);
    die $decoder unless ref($decoder);
    my $utf8 = $decoder->decode($data);
  
  =item guess_encoding($data, [, I<list of suspects>])
  
  You can also try C<guess_encoding> function which is exported by
  default.  It takes $data to check and it also takes the list of
  suspects by option.  The optional suspect list is I<not reflected> to
  the internal suspects list.
  
    my $decoder = guess_encoding($data, qw/euc-jp euc-kr euc-cn/);
    die $decoder unless ref($decoder);
    my $utf8 = $decoder->decode($data);
    # check only ascii, utf8 and UTF-(16|32) with BOM
    my $decoder = guess_encoding($data);
  
  =back
  
  =head1 CAVEATS
  
  =over 4
  
  =item *
  
  Because of the algorithm used, ISO-8859 series and other single-byte
  encodings do not work well unless either one of ISO-8859 is the only
  one suspect (besides ascii and utf8).
  
    use Encode::Guess;
    # perhaps ok
    my $decoder = guess_encoding($data, 'latin1');
    # definitely NOT ok
    my $decoder = guess_encoding($data, qw/latin1 greek/);
  
  The reason is that Encode::Guess guesses encoding by trial and error.
  It first splits $data into lines and tries to decode the line for each
  suspect.  It keeps it going until all but one encoding is eliminated
  out of suspects list.  ISO-8859 series is just too successful for most
  cases (because it fills almost all code points in \x00-\xff).
  
  =item *
  
  Do not mix national standard encodings and the corresponding vendor
  encodings.
  
    # a very bad idea
    my $decoder
       = guess_encoding($data, qw/shiftjis MacJapanese cp932/);
  
  The reason is that vendor encoding is usually a superset of national
  standard so it becomes too ambiguous for most cases.
  
  =item *
  
  On the other hand, mixing various national standard encodings
  automagically works unless $data is too short to allow for guessing.
  
   # This is ok if $data is long enough
   my $decoder =  
    guess_encoding($data, qw/euc-cn
                             euc-jp shiftjis 7bit-jis
                             euc-kr
                             big5-eten/);
  
  =item *
  
  DO NOT PUT TOO MANY SUSPECTS!  Don't you try something like this!
  
    my $decoder = guess_encoding($data, 
                                 Encode->encodings(":all"));
  
  =back
  
  It is, after all, just a guess.  You should alway be explicit when it
  comes to encodings.  But there are some, especially Japanese,
  environment that guess-coding is a must.  Use this module with care. 
  
  =head1 TO DO
  
  Encode::Guess does not work on EBCDIC platforms.
  
  =head1 SEE ALSO
  
  L<Encode>, L<Encode::Encoding>
  
  =cut
  
X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_GUESS

$fatpacked{"x86_64-linux-gnu-thread-multi/Encode/JP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_JP';
  package Encode::JP;
  BEGIN {
      if ( ord("A") == 193 ) {
          die "Encode::JP not supported on EBCDIC\n";
      }
  }
  use strict;
  use warnings;
  use Encode;
  our $VERSION = do { my @r = ( q$Revision: 2.5 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use XSLoader;
  XSLoader::load( __PACKAGE__, $VERSION );
  
  use Encode::JP::JIS7;
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::JP - Japanese Encodings
  
  =head1 SYNOPSIS
  
      use Encode qw/encode decode/; 
      $euc_jp = encode("euc-jp", $utf8);   # loads Encode::JP implicitly
      $utf8   = decode("euc-jp", $euc_jp); # ditto
  
  =head1 ABSTRACT
  
  This module implements Japanese charset encodings.  Encodings
  supported are as follows.
  
    Canonical   Alias		Description
    --------------------------------------------------------------------
    euc-jp      /\beuc.*jp$/i	EUC (Extended Unix Character)
                /\bjp.*euc/i   
            /\bujis$/i
    shiftjis    /\bshift.*jis$/i	Shift JIS (aka MS Kanji)
            /\bsjis$/i
    7bit-jis    /\bjis$/i		7bit JIS
    iso-2022-jp			ISO-2022-JP                  [RFC1468]
                  = 7bit JIS with all Halfwidth Kana 
                    converted to Fullwidth
    iso-2022-jp-1			ISO-2022-JP-1                [RFC2237]
                                  = ISO-2022-JP with JIS X 0212-1990
                    support.  See below
    MacJapanese	                Shift JIS + Apple vendor mappings
    cp932       /\bwindows-31j$/i Code Page 932
                                  = Shift JIS + MS/IBM vendor mappings
    jis0201-raw                   JIS0201, raw format
    jis0208-raw                   JIS0208, raw format
    jis0212-raw                   JIS0212, raw format
    --------------------------------------------------------------------
  
  =head1 DESCRIPTION
  
  To find out how to use this module in detail, see L<Encode>.
  
  =head1 Note on ISO-2022-JP(-1)?
  
  ISO-2022-JP-1 (RFC2237) is a superset of ISO-2022-JP (RFC1468) which
  adds support for JIS X 0212-1990.  That means you can use the same
  code to decode to utf8 but not vice versa.
  
    $utf8 = decode('iso-2022-jp-1', $stream);
  
  and
  
    $utf8 = decode('iso-2022-jp',   $stream);
  
  yield the same result but
  
    $with_0212 = encode('iso-2022-jp-1', $utf8);
  
  is now different from
  
    $without_0212 = encode('iso-2022-jp', $utf8 );
  
  In the latter case, characters that map to 0212 are first converted
  to U+3013 (0xA2AE in EUC-JP; a white square also known as 'Tofu' or
  'geta mark') then fed to the decoding engine.  U+FFFD is not used,
  in order to preserve text layout as much as possible.
  
  =head1 BUGS
  
  The ASCII region (0x00-0x7f) is preserved for all encodings, even
  though this conflicts with mappings by the Unicode Consortium.
  
  =head1 SEE ALSO
  
  L<Encode>
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_JP

$fatpacked{"x86_64-linux-gnu-thread-multi/Encode/JP/H2Z.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_JP_H2Z';
  #
  # $Id: H2Z.pm,v 2.2 2006/06/03 20:28:48 dankogai Exp $
  #
  
  package Encode::JP::H2Z;
  
  use strict;
  use warnings;
  
  our $RCSID = q$Id: H2Z.pm,v 2.2 2006/06/03 20:28:48 dankogai Exp $;
  our $VERSION = do { my @r = ( q$Revision: 2.2 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use Encode::CJKConstants qw(:all);
  
  use vars qw(%_D2Z  $_PAT_D2Z
    %_Z2D  $_PAT_Z2D
    %_H2Z  $_PAT_H2Z
    %_Z2H  $_PAT_Z2H);
  
  %_H2Z = (
      "\x8e\xa1" => "\xa1\xa3",    #
      "\x8e\xa2" => "\xa1\xd6",    #
      "\x8e\xa3" => "\xa1\xd7",    #
      "\x8e\xa4" => "\xa1\xa2",    #
      "\x8e\xa5" => "\xa1\xa6",    #
      "\x8e\xa6" => "\xa5\xf2",    #
      "\x8e\xa7" => "\xa5\xa1",    #
      "\x8e\xa8" => "\xa5\xa3",    #
      "\x8e\xa9" => "\xa5\xa5",    #
      "\x8e\xaa" => "\xa5\xa7",    #
      "\x8e\xab" => "\xa5\xa9",    #
      "\x8e\xac" => "\xa5\xe3",    #
      "\x8e\xad" => "\xa5\xe5",    #
      "\x8e\xae" => "\xa5\xe7",    #
      "\x8e\xaf" => "\xa5\xc3",    #
      "\x8e\xb0" => "\xa1\xbc",    #
      "\x8e\xb1" => "\xa5\xa2",    #
      "\x8e\xb2" => "\xa5\xa4",    #
      "\x8e\xb3" => "\xa5\xa6",    #
      "\x8e\xb4" => "\xa5\xa8",    #
      "\x8e\xb5" => "\xa5\xaa",    #
      "\x8e\xb6" => "\xa5\xab",    #
      "\x8e\xb7" => "\xa5\xad",    #
      "\x8e\xb8" => "\xa5\xaf",    #
      "\x8e\xb9" => "\xa5\xb1",    #
      "\x8e\xba" => "\xa5\xb3",    #
      "\x8e\xbb" => "\xa5\xb5",    #
      "\x8e\xbc" => "\xa5\xb7",    #
      "\x8e\xbd" => "\xa5\xb9",    #
      "\x8e\xbe" => "\xa5\xbb",    #
      "\x8e\xbf" => "\xa5\xbd",    #
      "\x8e\xc0" => "\xa5\xbf",    #
      "\x8e\xc1" => "\xa5\xc1",    #
      "\x8e\xc2" => "\xa5\xc4",    #
      "\x8e\xc3" => "\xa5\xc6",    #
      "\x8e\xc4" => "\xa5\xc8",    #
      "\x8e\xc5" => "\xa5\xca",    #
      "\x8e\xc6" => "\xa5\xcb",    #
      "\x8e\xc7" => "\xa5\xcc",    #
      "\x8e\xc8" => "\xa5\xcd",    #
      "\x8e\xc9" => "\xa5\xce",    #
      "\x8e\xca" => "\xa5\xcf",    #
      "\x8e\xcb" => "\xa5\xd2",    #
      "\x8e\xcc" => "\xa5\xd5",    #
      "\x8e\xcd" => "\xa5\xd8",    #
      "\x8e\xce" => "\xa5\xdb",    #
      "\x8e\xcf" => "\xa5\xde",    #
      "\x8e\xd0" => "\xa5\xdf",    #
      "\x8e\xd1" => "\xa5\xe0",    #
      "\x8e\xd2" => "\xa5\xe1",    #
      "\x8e\xd3" => "\xa5\xe2",    #
      "\x8e\xd4" => "\xa5\xe4",    #
      "\x8e\xd5" => "\xa5\xe6",    #
      "\x8e\xd6" => "\xa5\xe8",    #
      "\x8e\xd7" => "\xa5\xe9",    #
      "\x8e\xd8" => "\xa5\xea",    #
      "\x8e\xd9" => "\xa5\xeb",    #
      "\x8e\xda" => "\xa5\xec",    #
      "\x8e\xdb" => "\xa5\xed",    #
      "\x8e\xdc" => "\xa5\xef",    #
      "\x8e\xdd" => "\xa5\xf3",    #
      "\x8e\xde" => "\xa1\xab",    #
      "\x8e\xdf" => "\xa1\xac",    #
  );
  
  %_D2Z = (
      "\x8e\xb6\x8e\xde" => "\xa5\xac",    #
      "\x8e\xb7\x8e\xde" => "\xa5\xae",    #
      "\x8e\xb8\x8e\xde" => "\xa5\xb0",    #
      "\x8e\xb9\x8e\xde" => "\xa5\xb2",    #
      "\x8e\xba\x8e\xde" => "\xa5\xb4",    #
      "\x8e\xbb\x8e\xde" => "\xa5\xb6",    #
      "\x8e\xbc\x8e\xde" => "\xa5\xb8",    #
      "\x8e\xbd\x8e\xde" => "\xa5\xba",    #
      "\x8e\xbe\x8e\xde" => "\xa5\xbc",    #
      "\x8e\xbf\x8e\xde" => "\xa5\xbe",    #
      "\x8e\xc0\x8e\xde" => "\xa5\xc0",    #
      "\x8e\xc1\x8e\xde" => "\xa5\xc2",    #
      "\x8e\xc2\x8e\xde" => "\xa5\xc5",    #
      "\x8e\xc3\x8e\xde" => "\xa5\xc7",    #
      "\x8e\xc4\x8e\xde" => "\xa5\xc9",    #
      "\x8e\xca\x8e\xde" => "\xa5\xd0",    #
      "\x8e\xcb\x8e\xde" => "\xa5\xd3",    #
      "\x8e\xcc\x8e\xde" => "\xa5\xd6",    #
      "\x8e\xcd\x8e\xde" => "\xa5\xd9",    #
      "\x8e\xce\x8e\xde" => "\xa5\xdc",    #
      "\x8e\xca\x8e\xdf" => "\xa5\xd1",    #
      "\x8e\xcb\x8e\xdf" => "\xa5\xd4",    #
      "\x8e\xcc\x8e\xdf" => "\xa5\xd7",    #
      "\x8e\xcd\x8e\xdf" => "\xa5\xda",    #
      "\x8e\xce\x8e\xdf" => "\xa5\xdd",    #
      "\x8e\xb3\x8e\xde" => "\xa5\xf4",    #
  );
  
  # init only once;
  
  #$_PAT_D2Z = join("|", keys %_D2Z);
  #$_PAT_H2Z = join("|", keys %_H2Z);
  
  %_Z2H = reverse %_H2Z;
  %_Z2D = reverse %_D2Z;
  
  #$_PAT_Z2H    = join("|", keys %_Z2H);
  #$_PAT_Z2D    = join("|", keys %_Z2D);
  
  sub h2z {
      no warnings qw(uninitialized);
      my $r_str          = shift;
      my ($keep_dakuten) = @_;
      my $n              = 0;
      unless ($keep_dakuten) {
          $n = (
              $$r_str =~ s(
                 ($RE{EUC_KANA}
                  (?:\x8e[\xde\xdf])?)
                 ){
            my $str = $1;
            $_D2Z{$str} || $_H2Z{$str} || 
                # in case dakuten and handakuten are side-by-side!
                $_H2Z{substr($str,0,2)} . $_H2Z{substr($str,2,2)};
            }eogx
          );
      }
      else {
          $n = (
              $$r_str =~ s(
                 ($RE{EUC_KANA})
                 ){
            $_H2Z{$1};
            }eogx
          );
      }
      $n;
  }
  
  sub z2h {
      my $r_str = shift;
      my $n     = (
          $$r_str =~ s(
                ($RE{EUC_C}|$RE{EUC_0212}|$RE{EUC_KANA})
                ){
           $_Z2D{$1} || $_Z2H{$1} || $1;
           }eogx
      );
      $n;
  }
  
  1;
  __END__
  
  
  =head1 NAME
  
  Encode::JP::H2Z -- internally used by Encode::JP::2022_JP*
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_JP_H2Z

$fatpacked{"x86_64-linux-gnu-thread-multi/Encode/JP/JIS7.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_JP_JIS7';
  package Encode::JP::JIS7;
  use strict;
  use warnings;
  our $VERSION = do { my @r = ( q$Revision: 2.8 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use Encode qw(:fallbacks);
  
  for my $name ( '7bit-jis', 'iso-2022-jp', 'iso-2022-jp-1' ) {
      my $h2z     = ( $name eq '7bit-jis' )    ? 0 : 1;
      my $jis0212 = ( $name eq 'iso-2022-jp' ) ? 0 : 1;
  
      my $obj = bless {
          Name    => $name,
          h2z     => $h2z,
          jis0212 => $jis0212,
      } => __PACKAGE__;
      Encode::define_encoding($obj, $name);
  }
  
  use parent qw(Encode::Encoding);
  
  # we override this to 1 so PerlIO works
  sub needs_lines { 1 }
  
  use Encode::CJKConstants qw(:all);
  
  #
  # decode is identical for all 2022 variants
  #
  
  sub decode($$;$) {
      my ( $obj, $str, $chk ) = @_;
      return undef unless defined $str;
      my $residue = '';
      if ($chk) {
          $str =~ s/([^\x00-\x7f].*)$//so and $residue = $1;
      }
      $residue .= jis_euc( \$str );
      $_[1] = $residue if $chk;
      return Encode::decode( 'euc-jp', $str, FB_PERLQQ );
  }
  
  #
  # encode is different
  #
  
  sub encode($$;$) {
      require Encode::JP::H2Z;
      my ( $obj, $utf8, $chk ) = @_;
      return undef unless defined $utf8;
  
      # empty the input string in the stack so perlio is ok
      $_[1] = '' if $chk;
      my ( $h2z, $jis0212 ) = @$obj{qw(h2z jis0212)};
      my $octet = Encode::encode( 'euc-jp', $utf8, $chk || 0 );
      $h2z and &Encode::JP::H2Z::h2z( \$octet );
      euc_jis( \$octet, $jis0212 );
      return $octet;
  }
  
  #
  # cat_decode
  #
  my $re_scan_jis_g = qr{
     \G ( ($RE{JIS_0212}) |  $RE{JIS_0208}  |
          ($RE{ISO_ASC})  | ($RE{JIS_KANA}) | )
        ([^\e]*)
  }x;
  
  sub cat_decode {    # ($obj, $dst, $src, $pos, $trm, $chk)
      my ( $obj, undef, undef, $pos, $trm ) = @_;    # currently ignores $chk
      my ( $rdst, $rsrc, $rpos ) = \@_[ 1, 2, 3 ];
      local ${^ENCODING};
      use bytes;
      my $opos = pos($$rsrc);
      pos($$rsrc) = $pos;
      while ( $$rsrc =~ /$re_scan_jis_g/gc ) {
          my ( $esc, $esc_0212, $esc_asc, $esc_kana, $chunk ) =
            ( $1, $2, $3, $4, $5 );
  
          unless ($chunk) { $esc or last; next; }
  
          if ( $esc && !$esc_asc ) {
              $chunk =~ tr/\x21-\x7e/\xa1-\xfe/;
              if ($esc_kana) {
                  $chunk =~ s/([\xa1-\xdf])/\x8e$1/og;
              }
              elsif ($esc_0212) {
                  $chunk =~ s/([\xa1-\xfe][\xa1-\xfe])/\x8f$1/og;
              }
              $chunk = Encode::decode( 'euc-jp', $chunk, 0 );
          }
          elsif ( ( my $npos = index( $chunk, $trm ) ) >= 0 ) {
              $$rdst .= substr( $chunk, 0, $npos + length($trm) );
              $$rpos += length($esc) + $npos + length($trm);
              pos($$rsrc) = $opos;
              return 1;
          }
          $$rdst .= $chunk;
          $$rpos = pos($$rsrc);
      }
      $$rpos = pos($$rsrc);
      pos($$rsrc) = $opos;
      return '';
  }
  
  # JIS<->EUC
  my $re_scan_jis = qr{
     (?:($RE{JIS_0212})|$RE{JIS_0208}|($RE{ISO_ASC})|($RE{JIS_KANA}))([^\e]*)
  }x;
  
  sub jis_euc {
      local ${^ENCODING};
      my $r_str = shift;
      $$r_str =~ s($re_scan_jis)
      {
      my ($esc_0212, $esc_asc, $esc_kana, $chunk) =
         ($1, $2, $3, $4);
      if (!$esc_asc) {
          $chunk =~ tr/\x21-\x7e/\xa1-\xfe/;
          if ($esc_kana) {
          $chunk =~ s/([\xa1-\xdf])/\x8e$1/og;
          }
          elsif ($esc_0212) {
          $chunk =~ s/([\xa1-\xfe][\xa1-\xfe])/\x8f$1/og;
          }
      }
      $chunk;
      }geox;
      my ($residue) = ( $$r_str =~ s/(\e.*)$//so );
      return $residue;
  }
  
  sub euc_jis {
      no warnings qw(uninitialized);
      local ${^ENCODING};
      my $r_str   = shift;
      my $jis0212 = shift;
      $$r_str =~ s{
      ((?:$RE{EUC_C})+|(?:$RE{EUC_KANA})+|(?:$RE{EUC_0212})+)
      }{
          my $chunk = $1;
          my $esc =
          ( $chunk =~ tr/\x8E//d ) ? $ESC{KANA} :
              ( $chunk =~ tr/\x8F//d ) ? $ESC{JIS_0212} :
              $ESC{JIS_0208};
          if ($esc eq $ESC{JIS_0212} && !$jis0212){
          # fallback to '?'
          $chunk =~ tr/\xA1-\xFE/\x3F/;
          }else{
          $chunk =~ tr/\xA1-\xFE/\x21-\x7E/;
          }
          $esc . $chunk . $ESC{ASC};
      }geox;
      $$r_str =~ s/\Q$ESC{ASC}\E
          (\Q$ESC{KANA}\E|\Q$ESC{JIS_0212}\E|\Q$ESC{JIS_0208}\E)/$1/gox;
      $$r_str;
  }
  
  1;
  __END__
  
  
  =head1 NAME
  
  Encode::JP::JIS7 -- internally used by Encode::JP
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_JP_JIS7

$fatpacked{"x86_64-linux-gnu-thread-multi/Encode/KR.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_KR';
  package Encode::KR;
  BEGIN {
      if ( ord("A") == 193 ) {
          die "Encode::KR not supported on EBCDIC\n";
      }
  }
  use strict;
  use warnings;
  use Encode;
  our $VERSION = do { my @r = ( q$Revision: 2.3 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  use XSLoader;
  XSLoader::load( __PACKAGE__, $VERSION );
  
  use Encode::KR::2022_KR;
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::KR - Korean Encodings
  
  =head1 SYNOPSIS
  
      use Encode qw/encode decode/; 
      $euc_kr = encode("euc-kr", $utf8);   # loads Encode::KR implicitly
      $utf8   = decode("euc-kr", $euc_kr); # ditto
  
  =head1 DESCRIPTION
  
  This module implements Korean charset encodings.  Encodings supported
  are as follows.
  
  
    Canonical   Alias		Description
    --------------------------------------------------------------------
    euc-kr      /\beuc.*kr$/i	EUC (Extended Unix Character)
            /\bkr.*euc$/i
    ksc5601-raw			Korean standard code set (as is)
    cp949	      /(?:x-)?uhc$/i
                /(?:x-)?windows-949$/i
                /\bks_c_5601-1987$/i
                                  Code Page 949 (EUC-KR + 8,822 
                                  (additional Hangul syllables)
    MacKorean			EUC-KR + Apple Vendor Mappings
    johab       JOHAB             A supplementary encoding defined in 
                                               Annex 3 of KS X 1001:1998
    iso-2022-kr                   iso-2022-kr                  [RFC1557]
    --------------------------------------------------------------------
  
  To find how to use this module in detail, see L<Encode>.
  
  =head1 BUGS
  
  When you see C<charset=ks_c_5601-1987> on mails and web pages, they really
  mean "cp949" encodings.  To fix that, the following aliases are set;
  
    qr/(?:x-)?uhc$/i         => '"cp949"'
    qr/(?:x-)?windows-949$/i => '"cp949"'
    qr/ks_c_5601-1987$/i     => '"cp949"'
  
  The ASCII region (0x00-0x7f) is preserved for all encodings, even
  though this conflicts with mappings by the Unicode Consortium.
  
  =head1 SEE ALSO
  
  L<Encode>
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_KR

$fatpacked{"x86_64-linux-gnu-thread-multi/Encode/KR/2022_KR.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_KR_2022_KR';
  package Encode::KR::2022_KR;
  use strict;
  use warnings;
  our $VERSION = do { my @r = ( q$Revision: 2.4 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use Encode qw(:fallbacks);
  
  use parent qw(Encode::Encoding);
  __PACKAGE__->Define('iso-2022-kr');
  
  sub needs_lines { 1 }
  
  sub perlio_ok {
      return 0;    # for the time being
  }
  
  sub decode {
      my ( $obj, $str, $chk ) = @_;
      return undef unless defined $str;
      my $res     = $str;
      my $residue = iso_euc( \$res );
  
      # This is for PerlIO
      $_[1] = $residue if $chk;
      return Encode::decode( 'euc-kr', $res, FB_PERLQQ );
  }
  
  sub encode {
      my ( $obj, $utf8, $chk ) = @_;
      return undef unless defined $utf8;
  
      # empty the input string in the stack so perlio is ok
      $_[1] = '' if $chk;
      my $octet = Encode::encode( 'euc-kr', $utf8, FB_PERLQQ );
      euc_iso( \$octet );
      return $octet;
  }
  
  use Encode::CJKConstants qw(:all);
  
  # ISO<->EUC
  
  sub iso_euc {
      my $r_str = shift;
      $$r_str =~ s/$RE{'2022_KR'}//gox;    # remove the designator
      $$r_str =~ s{                      # replace characters in GL
       \x0e                              # between SO(\x0e) and SI(\x0f)
       ([^\x0f]*)                        # with characters in GR
       \x0f
          }
      {
                          my $out= $1;
        $out =~ tr/\x21-\x7e/\xa1-\xfe/;
        $out;
      }geox;
      my ($residue) = ( $$r_str =~ s/(\e.*)$//so );
      return $residue;
  }
  
  sub euc_iso {
      no warnings qw(uninitialized);
      my $r_str = shift;
      substr( $$r_str, 0, 0 ) =
        $ESC{'2022_KR'};    # put the designator at the beg.
      $$r_str =~
        s{                         # move KS X 1001 characters in GR to GL
          ($RE{EUC_C}+)                     # and enclose them with SO and SI
          }{
              my $str = $1;
              $str =~ tr/\xA1-\xFE/\x21-\x7E/;
              "\x0e" . $str . "\x0f";
          }geox;
      $$r_str;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::KR::2022_KR -- internally used by Encode::KR
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_KR_2022_KR

$fatpacked{"x86_64-linux-gnu-thread-multi/Encode/MIME/Header.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_MIME_HEADER';
  package Encode::MIME::Header;
  use strict;
  use warnings;
  
  our $VERSION = do { my @r = ( q$Revision: 2.29 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use Carp ();
  use Encode ();
  use MIME::Base64 ();
  
  my %seed = (
      decode_b => 1,       # decodes 'B' encoding ?
      decode_q => 1,       # decodes 'Q' encoding ?
      encode   => 'B',     # encode with 'B' or 'Q' ?
      charset  => 'UTF-8', # encode charset
      bpl      => 75,      # bytes per line
  );
  
  my @objs;
  
  push @objs, bless {
      %seed,
      Name     => 'MIME-Header',
  } => __PACKAGE__;
  
  push @objs, bless {
      %seed,
      decode_q => 0,
      Name     => 'MIME-B',
  } => __PACKAGE__;
  
  push @objs, bless {
      %seed,
      decode_b => 0,
      encode   => 'Q',
      Name     => 'MIME-Q',
  } => __PACKAGE__;
  
  Encode::define_encoding($_, $_->{Name}) foreach @objs;
  
  use parent qw(Encode::Encoding);
  
  sub needs_lines { 1 }
  sub perlio_ok   { 0 }
  
  # RFC 2047 and RFC 2231 grammar
  my $re_charset = qr/[!"#\$%&'+\-0-9A-Z\\\^_`a-z\{\|\}~]+/;
  my $re_language = qr/[A-Za-z]{1,8}(?:-[0-9A-Za-z]{1,8})*/;
  my $re_encoding = qr/[QqBb]/;
  my $re_encoded_text = qr/[^\?]*/;
  my $re_encoded_word = qr/=\?$re_charset(?:\*$re_language)?\?$re_encoding\?$re_encoded_text\?=/;
  my $re_capture_encoded_word = qr/=\?($re_charset)((?:\*$re_language)?)\?($re_encoding\?$re_encoded_text)\?=/;
  my $re_capture_encoded_word_split = qr/=\?($re_charset)((?:\*$re_language)?)\?($re_encoding)\?($re_encoded_text)\?=/;
  
  # in strict mode check also for valid base64 characters and also for valid quoted printable codes
  my $re_encoding_strict_b = qr/[Bb]/;
  my $re_encoding_strict_q = qr/[Qq]/;
  my $re_encoded_text_strict_b = qr/(?:[0-9A-Za-z\+\/]{4})*(?:[0-9A-Za-z\+\/]{2}==|[0-9A-Za-z\+\/]{3}=|)/;
  my $re_encoded_text_strict_q = qr/(?:[\x21-\x3C\x3E\x40-\x7E]|=[0-9A-Fa-f]{2})*/; # NOTE: first part are printable US-ASCII except ?, =, SPACE and TAB
  my $re_encoded_word_strict = qr/=\?$re_charset(?:\*$re_language)?\?(?:$re_encoding_strict_b\?$re_encoded_text_strict_b|$re_encoding_strict_q\?$re_encoded_text_strict_q)\?=/;
  my $re_capture_encoded_word_strict = qr/=\?($re_charset)((?:\*$re_language)?)\?($re_encoding_strict_b\?$re_encoded_text_strict_b|$re_encoding_strict_q\?$re_encoded_text_strict_q)\?=/;
  
  my $re_newline = qr/(?:\r\n|[\r\n])/;
  
  # in strict mode encoded words must be always separated by spaces or tabs (or folded newline)
  # except in comments when separator between words and comment round brackets can be omitted
  my $re_word_begin_strict = qr/(?:(?:[ \t]|\A)\(?|(?:[^\\]|\A)\)\()/;
  my $re_word_sep_strict = qr/(?:$re_newline?[ \t])+/;
  my $re_word_end_strict = qr/(?:\)\(|\)?(?:$re_newline?[ \t]|\z))/;
  
  my $re_match = qr/()((?:$re_encoded_word\s*)*$re_encoded_word)()/;
  my $re_match_strict = qr/($re_word_begin_strict)((?:$re_encoded_word_strict$re_word_sep_strict)*$re_encoded_word_strict)(?=$re_word_end_strict)/;
  
  my $re_capture = qr/$re_capture_encoded_word(?:\s*)?/;
  my $re_capture_strict = qr/$re_capture_encoded_word_strict$re_word_sep_strict?/;
  
  our $STRICT_DECODE = 0;
  
  sub decode($$;$) {
      my ($obj, $str, $chk) = @_;
      return undef unless defined $str;
  
      my $re_match_decode = $STRICT_DECODE ? $re_match_strict : $re_match;
      my $re_capture_decode = $STRICT_DECODE ? $re_capture_strict : $re_capture;
  
      my $stop = 0;
      my $output = substr($str, 0, 0); # to propagate taintedness
  
      # decode each line separately, match whole continuous folded line at one call
      1 while not $stop and $str =~ s{^((?:[^\r\n]*(?:$re_newline[ \t])?)*)($re_newline)?}{
  
          my $line = $1;
          my $sep = defined $2 ? $2 : '';
  
          $stop = 1 unless length($line) or length($sep);
  
          # in non strict mode append missing '=' padding characters for b words
          # fixes below concatenation of consecutive encoded mime words
          1 while not $STRICT_DECODE and $line =~ s/(=\?$re_charset(?:\*$re_language)?\?[Bb]\?)((?:[^\?]{4})*[^\?]{1,3})(\?=)/$1.$2.('='x(4-length($2)%4)).$3/se;
  
          # NOTE: this code partially could break $chk support
          # in non strict mode concat consecutive encoded mime words with same charset, language and encoding
          # fixes breaking inside multi-byte characters
          1 while not $STRICT_DECODE and $line =~ s/$re_capture_encoded_word_split\s*=\?\1\2\?\3\?($re_encoded_text)\?=/=\?$1$2\?$3\?$4$5\?=/so;
  
          # process sequence of encoded MIME words at once
          1 while not $stop and $line =~ s{^(.*?)$re_match_decode}{
  
              my $begin = $1 . $2;
              my $words = $3;
  
              $begin =~ tr/\r\n//d;
              $output .= $begin;
  
              # decode one MIME word
              1 while not $stop and $words =~ s{^(.*?)($re_capture_decode)}{
  
                  $output .= $1;
                  my $orig = $2;
                  my $charset = $3;
                  my ($mime_enc, $text) = split /\?/, $5;
  
                  $text =~ tr/\r\n//d;
  
                  my $enc = Encode::find_mime_encoding($charset);
  
                  # in non strict mode allow also perl encoding aliases
                  if ( not defined $enc and not $STRICT_DECODE ) {
                      # make sure that decoded string will be always strict UTF-8
                      $charset = 'UTF-8' if lc($charset) eq 'utf8';
                      $enc = Encode::find_encoding($charset);
                  }
  
                  if ( not defined $enc ) {
                      Carp::croak qq(Unknown charset "$charset") if not ref $chk and $chk and $chk & Encode::DIE_ON_ERR;
                      Carp::carp qq(Unknown charset "$charset") if not ref $chk and $chk and $chk & Encode::WARN_ON_ERR;
                      $stop = 1 if not ref $chk and $chk and $chk & Encode::RETURN_ON_ERR;
                      $output .= ($output =~ /(?:\A|[ \t])$/ ? '' : ' ') . $orig unless $stop; # $orig mime word is separated by whitespace
                      $stop ? $orig : '';
                  } else {
                      if ( uc($mime_enc) eq 'B' and $obj->{decode_b} ) {
                          my $decoded = _decode_b($enc, $text, $chk);
                          $stop = 1 if not defined $decoded and not ref $chk and $chk and $chk & Encode::RETURN_ON_ERR;
                          $output .= (defined $decoded ? $decoded : $text) unless $stop;
                          $stop ? $orig : '';
                      } elsif ( uc($mime_enc) eq 'Q' and $obj->{decode_q} ) {
                          my $decoded = _decode_q($enc, $text, $chk);
                          $stop = 1 if not defined $decoded and not ref $chk and $chk and $chk & Encode::RETURN_ON_ERR;
                          $output .= (defined $decoded ? $decoded : $text) unless $stop;
                          $stop ? $orig : '';
                      } else {
                          Carp::croak qq(MIME "$mime_enc" unsupported) if not ref $chk and $chk and $chk & Encode::DIE_ON_ERR;
                          Carp::carp qq(MIME "$mime_enc" unsupported) if not ref $chk and $chk and $chk & Encode::WARN_ON_ERR;
                          $stop = 1 if not ref $chk and $chk and $chk & Encode::RETURN_ON_ERR;
                          $output .= ($output =~ /(?:\A|[ \t])$/ ? '' : ' ') . $orig unless $stop; # $orig mime word is separated by whitespace
                          $stop ? $orig : '';
                      }
                  }
  
              }se;
  
              if ( not $stop ) {
                  $output .= $words;
                  $words = '';
              }
  
              $words;
  
          }se;
  
          if ( not $stop ) {
              $line =~ tr/\r\n//d;
              $output .= $line . $sep;
              $line = '';
              $sep = '';
          }
  
          $line . $sep;
  
      }se;
  
      $_[1] = $str if not ref $chk and $chk and !($chk & Encode::LEAVE_SRC);
      return $output;
  }
  
  sub _decode_b {
      my ($enc, $text, $chk) = @_;
      # MIME::Base64::decode ignores everything after a '=' padding character
      # in non strict mode split string after each sequence of padding characters and decode each substring
      my $octets = $STRICT_DECODE ?
          MIME::Base64::decode($text) :
          join('', map { MIME::Base64::decode($_) } split /(?<==)(?=[^=])/, $text);
      return _decode_octets($enc, $octets, $chk);
  }
  
  sub _decode_q {
      my ($enc, $text, $chk) = @_;
      $text =~ s/_/ /go;
      $text =~ s/=([0-9A-Fa-f]{2})/pack('C', hex($1))/ego;
      return _decode_octets($enc, $text, $chk);
  }
  
  sub _decode_octets {
      my ($enc, $octets, $chk) = @_;
      $chk = 0 unless defined $chk;
      $chk &= ~Encode::LEAVE_SRC if not ref $chk and $chk;
      my $output = $enc->decode($octets, $chk);
      return undef if not ref $chk and $chk and $octets ne '';
      return $output;
  }
  
  sub encode($$;$) {
      my ($obj, $str, $chk) = @_;
      return undef unless defined $str;
      my $output = $obj->_fold_line($obj->_encode_string($str, $chk));
      $_[1] = $str if not ref $chk and $chk and !($chk & Encode::LEAVE_SRC);
      return $output . substr($str, 0, 0); # to propagate taintedness
  }
  
  sub _fold_line {
      my ($obj, $line) = @_;
      my $bpl = $obj->{bpl};
      my $output = '';
  
      while ( length($line) ) {
          if ( $line =~ s/^(.{0,$bpl})(\s|\z)// ) {
              $output .= $1;
              $output .= "\r\n" . $2 if length($line);
          } elsif ( $line =~ s/(\s)(.*)$// ) {
              $output .= $line;
              $line = $2;
              $output .= "\r\n" . $1 if length($line);
          } else {
              $output .= $line;
              last;
          }
      }
  
      return $output;
  }
  
  sub _encode_string {
      my ($obj, $str, $chk) = @_;
      my $wordlen = $obj->{bpl} > 76 ? 76 : $obj->{bpl};
      my $enc = Encode::find_mime_encoding($obj->{charset});
      my $enc_chk = $chk;
      $enc_chk = 0 unless defined $enc_chk;
      $enc_chk |= Encode::LEAVE_SRC if not ref $enc_chk and $enc_chk;
      my @result = ();
      my $octets = '';
      while ( length( my $chr = substr($str, 0, 1, '') ) ) {
          my $seq = $enc->encode($chr, $enc_chk);
          if ( not length($seq) ) {
              substr($str, 0, 0, $chr);
              last;
          }
          if ( $obj->_encoded_word_len($octets . $seq) > $wordlen ) {
              push @result, $obj->_encode_word($octets);
              $octets = '';
          }
          $octets .= $seq;
      }
      length($octets) and push @result, $obj->_encode_word($octets);
      $_[1] = $str if not ref $chk and $chk and !($chk & Encode::LEAVE_SRC);
      return join(' ', @result);
  }
  
  sub _encode_word {
      my ($obj, $octets) = @_;
      my $charset = $obj->{charset};
      my $encode = $obj->{encode};
      my $text = $encode eq 'B' ? _encode_b($octets) : _encode_q($octets);
      return "=?$charset?$encode?$text?=";
  }
  
  sub _encoded_word_len {
      my ($obj, $octets) = @_;
      my $charset = $obj->{charset};
      my $encode = $obj->{encode};
      my $text_len = $encode eq 'B' ? _encoded_b_len($octets) : _encoded_q_len($octets);
      return length("=?$charset?$encode??=") + $text_len;
  }
  
  sub _encode_b {
      my ($octets) = @_;
      return MIME::Base64::encode($octets, '');
  }
  
  sub _encoded_b_len {
      my ($octets) = @_;
      return ( length($octets) + 2 ) / 3 * 4;
  }
  
  my $re_invalid_q_char = qr/[^0-9A-Za-z !*+\-\/]/;
  
  sub _encode_q {
      my ($octets) = @_;
      $octets =~ s{($re_invalid_q_char)}{
          join('', map { sprintf('=%02X', $_) } unpack('C*', $1))
      }egox;
      $octets =~ s/ /_/go;
      return $octets;
  }
  
  sub _encoded_q_len {
      my ($octets) = @_;
      my $invalid_count = () = $octets =~ /$re_invalid_q_char/sgo;
      return ( $invalid_count * 3 ) + ( length($octets) - $invalid_count );
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::MIME::Header -- MIME encoding for an unstructured email header
  
  =head1 SYNOPSIS
  
      use Encode qw(encode decode);
  
      my $mime_str = encode("MIME-Header", "Sample:Text \N{U+263A}");
      # $mime_str is "=?UTF-8?B?U2FtcGxlOlRleHQg4pi6?="
  
      my $mime_q_str = encode("MIME-Q", "Sample:Text \N{U+263A}");
      # $mime_q_str is "=?UTF-8?Q?Sample=3AText_=E2=98=BA?="
  
      my $str = decode("MIME-Header",
          "=?ISO-8859-1?B?SWYgeW91IGNhbiByZWFkIHRoaXMgeW8=?=\r\n " .
          "=?ISO-8859-2?B?dSB1bmRlcnN0YW5kIHRoZSBleGFtcGxlLg==?="
      );
      # $str is "If you can read this you understand the example."
  
      use Encode qw(decode :fallbacks);
      use Encode::MIME::Header;
      local $Encode::MIME::Header::STRICT_DECODE = 1;
      my $strict_string = decode("MIME-Header", $mime_string, FB_CROAK);
      # use strict decoding and croak on errors
  
  =head1 ABSTRACT
  
  This module implements L<RFC 2047|https://tools.ietf.org/html/rfc2047> MIME
  encoding for an unstructured field body of the email header.  It can also be
  used for L<RFC 822|https://tools.ietf.org/html/rfc822> 'text' token.  However,
  it cannot be used directly for the whole header with the field name or for the
  structured header fields like From, To, Cc, Message-Id, etc...  There are 3
  encoding names supported by this module: C<MIME-Header>, C<MIME-B> and
  C<MIME-Q>.
  
  =head1 DESCRIPTION
  
  Decode method takes an unstructured field body of the email header (or
  L<RFC 822|https://tools.ietf.org/html/rfc822> 'text' token) as its input and
  decodes each MIME encoded-word from input string to a sequence of bytes
  according to L<RFC 2047|https://tools.ietf.org/html/rfc2047> and
  L<RFC 2231|https://tools.ietf.org/html/rfc2231>.  Subsequently, each sequence
  of bytes with the corresponding MIME charset is decoded with
  L<the Encode module|Encode> and finally, one output string is returned.  Text
  parts of the input string which do not contain MIME encoded-word stay
  unmodified in the output string.  Folded newlines between two consecutive MIME
  encoded-words are discarded, others are preserved in the output string.
  C<MIME-B> can decode Base64 variant, C<MIME-Q> can decode Quoted-Printable
  variant and C<MIME-Header> can decode both of them.  If L<Encode module|Encode>
  does not support particular MIME charset or chosen variant then an action based
  on L<CHECK flags|Encode/Handling Malformed Data> is performed (by default, the
  MIME encoded-word is not decoded).
  
  Encode method takes a scalar string as its input and uses
  L<strict UTF-8|Encode/UTF-8 vs. utf8 vs. UTF8> encoder for encoding it to UTF-8
  bytes.  Then a sequence of UTF-8 bytes is encoded into MIME encoded-words
  (C<MIME-Header> and C<MIME-B> use a Base64 variant while C<MIME-Q> uses a
  Quoted-Printable variant) where each MIME encoded-word is limited to 75
  characters.  MIME encoded-words are separated by C<CRLF SPACE> and joined to
  one output string.  Output string is suitable for unstructured field body of
  the email header.
  
  Both encode and decode methods propagate
  L<CHECK flags|Encode/Handling Malformed Data> when encoding and decoding the
  MIME charset.
  
  =head1 BUGS
  
  Versions prior to 2.22 (part of Encode 2.83) have a malfunctioning decoder
  and encoder.  The MIME encoder infamously inserted additional spaces or
  discarded white spaces between consecutive MIME encoded-words, which led to
  invalid MIME headers produced by this module.  The MIME decoder had a tendency
  to discard white spaces, incorrectly interpret data or attempt to decode Base64
  MIME encoded-words as Quoted-Printable.  These problems were fixed in version
  2.22.  It is highly recommended not to use any version prior 2.22!
  
  Versions prior to 2.24 (part of Encode 2.87) ignored
  L<CHECK flags|Encode/Handling Malformed Data>.  The MIME encoder used
  L<not strict utf8|Encode/UTF-8 vs. utf8 vs. UTF8> encoder for input Unicode
  strings which could lead to invalid UTF-8 sequences.  MIME decoder used also
  L<not strict utf8|Encode/UTF-8 vs. utf8 vs. UTF8> decoder and additionally
  called the decode method with a C<Encode::FB_PERLQQ> flag (thus user-specified
  L<CHECK flags|Encode/Handling Malformed Data> were ignored).  Moreover, it
  automatically croaked when a MIME encoded-word contained unknown encoding.
  Since version 2.24, this module uses
  L<strict UTF-8|Encode/UTF-8 vs. utf8 vs. UTF8> encoder and decoder.  And
  L<CHECK flags|Encode/Handling Malformed Data> are correctly propagated.
  
  Since version 2.22 (part of Encode 2.83), the MIME encoder should be fully
  compliant to L<RFC 2047|https://tools.ietf.org/html/rfc2047> and
  L<RFC 2231|https://tools.ietf.org/html/rfc2231>.  Due to the aforementioned
  bugs in previous versions of the MIME encoder, there is a I<less strict>
  compatible mode for the MIME decoder which is used by default.  It should be
  able to decode MIME encoded-words encoded by pre 2.22 versions of this module.
  However, note that this is not correct according to
  L<RFC 2047|https://tools.ietf.org/html/rfc2047>.
  
  In default I<not strict> mode the MIME decoder attempts to decode every substring
  which looks like a MIME encoded-word.  Therefore, the MIME encoded-words do not
  need to be separated by white space.  To enforce a correct I<strict> mode, set
  variable C<$Encode::MIME::Header::STRICT_DECODE> to 1 e.g. by localizing:
  
    use Encode::MIME::Header;
    local $Encode::MIME::Header::STRICT_DECODE = 1;
  
  =head1 AUTHORS
  
  Pali E<lt>pali@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<Encode>,
  L<RFC 822|https://tools.ietf.org/html/rfc822>,
  L<RFC 2047|https://tools.ietf.org/html/rfc2047>,
  L<RFC 2231|https://tools.ietf.org/html/rfc2231>
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_MIME_HEADER

$fatpacked{"x86_64-linux-gnu-thread-multi/Encode/MIME/Header/ISO_2022_JP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_MIME_HEADER_ISO_2022_JP';
  package Encode::MIME::Header::ISO_2022_JP;
  
  use strict;
  use warnings;
  
  use parent qw(Encode::MIME::Header);
  
  my $obj =
    bless { decode_b => '1', decode_q => '1', encode => 'B', bpl => 76, Name => 'MIME-Header-ISO_2022_JP' } =>
    __PACKAGE__;
  Encode::define_encoding($obj, 'MIME-Header-ISO_2022_JP');
  
  use constant HEAD => '=?ISO-2022-JP?B?';
  use constant TAIL => '?=';
  
  use Encode::CJKConstants qw(%RE);
  
  our $VERSION = do { my @r = ( q$Revision: 1.9 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  # I owe the below codes totally to
  #   Jcode by Dan Kogai & http://www.din.or.jp/~ohzaki/perl.htm#JP_Base64
  
  sub encode {
      my $self = shift;
      my $str  = shift;
      return undef unless defined $str;
  
      utf8::encode($str) if ( Encode::is_utf8($str) );
      Encode::from_to( $str, 'utf8', 'euc-jp' );
  
      my ($trailing_crlf) = ( $str =~ /(\n|\r|\x0d\x0a)$/o );
  
      $str = _mime_unstructured_header( $str, $self->{bpl} );
  
      not $trailing_crlf and $str =~ s/(\n|\r|\x0d\x0a)$//o;
  
      return $str;
  }
  
  sub _mime_unstructured_header {
      my ( $oldheader, $bpl ) = @_;
      my $crlf = $oldheader =~ /\n$/;
      my ( $header, @words, @wordstmp, $i ) = ('');
  
      $oldheader =~ s/\s+$//;
  
      @wordstmp = split /\s+/, $oldheader;
  
      for ( $i = 0 ; $i < $#wordstmp ; $i++ ) {
          if (    $wordstmp[$i] !~ /^[\x21-\x7E]+$/
              and $wordstmp[ $i + 1 ] !~ /^[\x21-\x7E]+$/ )
          {
              $wordstmp[ $i + 1 ] = "$wordstmp[$i] $wordstmp[$i + 1]";
          }
          else {
              push( @words, $wordstmp[$i] );
          }
      }
  
      push( @words, $wordstmp[-1] );
  
      for my $word (@words) {
          if ( $word =~ /^[\x21-\x7E]+$/ ) {
              $header =~ /(?:.*\n)*(.*)/;
              if ( length($1) + length($word) > $bpl ) {
                  $header .= "\n $word";
              }
              else {
                  $header .= $word;
              }
          }
          else {
              $header = _add_encoded_word( $word, $header, $bpl );
          }
  
          $header =~ /(?:.*\n)*(.*)/;
  
          if ( length($1) == $bpl ) {
              $header .= "\n ";
          }
          else {
              $header .= ' ';
          }
      }
  
      $header =~ s/\n? $//mg;
  
      $crlf ? "$header\n" : $header;
  }
  
  sub _add_encoded_word {
      my ( $str, $line, $bpl ) = @_;
      my $result = '';
  
      while ( length($str) ) {
          my $target = $str;
          $str = '';
  
          if (
              length($line) + 22 +
              ( $target =~ /^(?:$RE{EUC_0212}|$RE{EUC_C})/o ) * 8 > $bpl )
          {
              $line =~ s/[ \t\n\r]*$/\n/;
              $result .= $line;
              $line = ' ';
          }
  
          while (1) {
              my $iso_2022_jp = $target;
              Encode::from_to( $iso_2022_jp, 'euc-jp', 'iso-2022-jp' );
  
              my $encoded =
                HEAD . MIME::Base64::encode_base64( $iso_2022_jp, '' ) . TAIL;
  
              if ( length($encoded) + length($line) > $bpl ) {
                  $target =~
                    s/($RE{EUC_0212}|$RE{EUC_KANA}|$RE{EUC_C}|$RE{ASCII})$//o;
                  $str = $1 . $str;
              }
              else {
                  $line .= $encoded;
                  last;
              }
          }
  
      }
  
      $result . $line;
  }
  
  1;
  __END__
  
X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_MIME_HEADER_ISO_2022_JP

$fatpacked{"x86_64-linux-gnu-thread-multi/Encode/MIME/Name.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_MIME_NAME';
  package Encode::MIME::Name;
  use strict;
  use warnings;
  our $VERSION = do { my @r = ( q$Revision: 1.3 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  # NOTE: This table must be 1:1 mapping
  our %MIME_NAME_OF = (
      'AdobeStandardEncoding' => 'Adobe-Standard-Encoding',
      'AdobeSymbol'           => 'Adobe-Symbol-Encoding',
      'ascii'                 => 'US-ASCII',
      'big5-hkscs'            => 'Big5-HKSCS',
      'cp1026'                => 'IBM1026',
      'cp1047'                => 'IBM1047',
      'cp1250'                => 'windows-1250',
      'cp1251'                => 'windows-1251',
      'cp1252'                => 'windows-1252',
      'cp1253'                => 'windows-1253',
      'cp1254'                => 'windows-1254',
      'cp1255'                => 'windows-1255',
      'cp1256'                => 'windows-1256',
      'cp1257'                => 'windows-1257',
      'cp1258'                => 'windows-1258',
      'cp37'                  => 'IBM037',
      'cp424'                 => 'IBM424',
      'cp437'                 => 'IBM437',
      'cp500'                 => 'IBM500',
      'cp775'                 => 'IBM775',
      'cp850'                 => 'IBM850',
      'cp852'                 => 'IBM852',
      'cp855'                 => 'IBM855',
      'cp857'                 => 'IBM857',
      'cp860'                 => 'IBM860',
      'cp861'                 => 'IBM861',
      'cp862'                 => 'IBM862',
      'cp863'                 => 'IBM863',
      'cp864'                 => 'IBM864',
      'cp865'                 => 'IBM865',
      'cp866'                 => 'IBM866',
      'cp869'                 => 'IBM869',
      'cp936'                 => 'GBK',
      'euc-cn'                => 'EUC-CN',
      'euc-jp'                => 'EUC-JP',
      'euc-kr'                => 'EUC-KR',
      #'gb2312-raw'            => 'GB2312', # no, you're wrong, I18N::Charset
      'hp-roman8'             => 'hp-roman8',
      'hz'                    => 'HZ-GB-2312',
      'iso-2022-jp'           => 'ISO-2022-JP',
      'iso-2022-jp-1'         => 'ISO-2022-JP-1',
      'iso-2022-kr'           => 'ISO-2022-KR',
      'iso-8859-1'            => 'ISO-8859-1',
      'iso-8859-10'           => 'ISO-8859-10',
      'iso-8859-13'           => 'ISO-8859-13',
      'iso-8859-14'           => 'ISO-8859-14',
      'iso-8859-15'           => 'ISO-8859-15',
      'iso-8859-16'           => 'ISO-8859-16',
      'iso-8859-2'            => 'ISO-8859-2',
      'iso-8859-3'            => 'ISO-8859-3',
      'iso-8859-4'            => 'ISO-8859-4',
      'iso-8859-5'            => 'ISO-8859-5',
      'iso-8859-6'            => 'ISO-8859-6',
      'iso-8859-7'            => 'ISO-8859-7',
      'iso-8859-8'            => 'ISO-8859-8',
      'iso-8859-9'            => 'ISO-8859-9',
      #'jis0201-raw'           => 'JIS_X0201',
      #'jis0208-raw'           => 'JIS_C6226-1983',
      #'jis0212-raw'           => 'JIS_X0212-1990',
      'koi8-r'                => 'KOI8-R',
      'koi8-u'                => 'KOI8-U',
      #'ksc5601-raw'           => 'KS_C_5601-1987',
      'shiftjis'              => 'Shift_JIS',
      'UTF-16'                => 'UTF-16',
      'UTF-16BE'              => 'UTF-16BE',
      'UTF-16LE'              => 'UTF-16LE',
      'UTF-32'                => 'UTF-32',
      'UTF-32BE'              => 'UTF-32BE',
      'UTF-32LE'              => 'UTF-32LE',
      'UTF-7'                 => 'UTF-7',
      'utf-8-strict'          => 'UTF-8',
      'viscii'                => 'VISCII',
  );
  
  # NOTE: %MIME_NAME_OF is still 1:1 mapping
  our %ENCODE_NAME_OF = map { uc $MIME_NAME_OF{$_} => $_ } keys %MIME_NAME_OF;
  
  # Add additional 1:N mapping
  $MIME_NAME_OF{'utf8'} = 'UTF-8';
  
  sub get_mime_name($) { $MIME_NAME_OF{$_[0]} };
  
  sub get_encode_name($) { $ENCODE_NAME_OF{uc $_[0]} };
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::MIME::NAME -- internally used by Encode
  
  =head1 SEE ALSO
  
  L<I18N::Charset>
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_MIME_NAME

$fatpacked{"x86_64-linux-gnu-thread-multi/Encode/Symbol.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_SYMBOL';
  package Encode::Symbol;
  use strict;
  use warnings;
  use Encode;
  our $VERSION = do { my @r = ( q$Revision: 2.2 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use XSLoader;
  XSLoader::load( __PACKAGE__, $VERSION );
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::Symbol - Symbol Encodings
  
  =head1 SYNOPSIS
  
      use Encode qw/encode decode/; 
      $symbol  = encode("symbol", $utf8); # loads Encode::Symbol implicitly
      $utf8 = decode("", $symbol);        # ditto
  
  =head1 ABSTRACT
  
  This module implements symbol and dingbats encodings.  Encodings
  supported are as follows.   
  
    Canonical   Alias		Description
    --------------------------------------------------------------------
    symbol
    dingbats
    AdobeZDingbat
    AdobeSymbol
    MacDingbats
  
  =head1 DESCRIPTION
  
  To find out how to use this module in detail, see L<Encode>.
  
  =head1 SEE ALSO
  
  L<Encode>
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_SYMBOL

$fatpacked{"x86_64-linux-gnu-thread-multi/Encode/TW.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_TW';
  package Encode::TW;
  BEGIN {
      if ( ord("A") == 193 ) {
          die "Encode::TW not supported on EBCDIC\n";
      }
  }
  use strict;
  use warnings;
  use Encode;
  our $VERSION = do { my @r = ( q$Revision: 2.3 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  use XSLoader;
  XSLoader::load( __PACKAGE__, $VERSION );
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::TW - Taiwan-based Chinese Encodings
  
  =head1 SYNOPSIS
  
      use Encode qw/encode decode/; 
      $big5 = encode("big5", $utf8); # loads Encode::TW implicitly
      $utf8 = decode("big5", $big5); # ditto
  
  =head1 DESCRIPTION
  
  This module implements tradition Chinese charset encodings as used
  in Taiwan and Hong Kong.
  Encodings supported are as follows.
  
    Canonical   Alias		Description
    --------------------------------------------------------------------
    big5-eten   /\bbig-?5$/i	Big5 encoding (with ETen extensions)
            /\bbig5-?et(en)?$/i
            /\btca-?big5$/i
    big5-hkscs  /\bbig5-?hk(scs)?$/i
                /\bhk(scs)?-?big5$/i
                                  Big5 + Cantonese characters in Hong Kong
    MacChineseTrad		Big5 + Apple Vendor Mappings
    cp950		                Code Page 950 
                                  = Big5 + Microsoft vendor mappings
    --------------------------------------------------------------------
  
  To find out how to use this module in detail, see L<Encode>.
  
  =head1 NOTES
  
  Due to size concerns, C<EUC-TW> (Extended Unix Character), C<CCCII>
  (Chinese Character Code for Information Interchange), C<BIG5PLUS>
  (CMEX's Big5+) and C<BIG5EXT> (CMEX's Big5e) are distributed separately
  on CPAN, under the name L<Encode::HanExtra>. That module also contains
  extra China-based encodings.
  
  =head1 BUGS
  
  Since the original C<big5> encoding (1984) is not supported anywhere
  (glibc and DOS-based systems uses C<big5> to mean C<big5-eten>; Microsoft
  uses C<big5> to mean C<cp950>), a conscious decision was made to alias
  C<big5> to C<big5-eten>, which is the de facto superset of the original
  big5.
  
  The C<CNS11643> encoding files are not complete. For common C<CNS11643>
  manipulation, please use C<EUC-TW> in L<Encode::HanExtra>, which contains
  planes 1-7.
  
  The ASCII region (0x00-0x7f) is preserved for all encodings, even
  though this conflicts with mappings by the Unicode Consortium.
  
  =head1 SEE ALSO
  
  L<Encode>
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_TW

$fatpacked{"x86_64-linux-gnu-thread-multi/Encode/Unicode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_UNICODE';
  package Encode::Unicode;
  
  use strict;
  use warnings;
  
  our $VERSION = do { my @r = ( q$Revision: 2.20 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  
  use XSLoader;
  XSLoader::load( __PACKAGE__, $VERSION );
  
  #
  # Object Generator 8 transcoders all at once!
  #
  
  use Encode ();
  
  our %BOM_Unknown = map { $_ => 1 } qw(UTF-16 UTF-32);
  
  for my $name (
      qw(UTF-16 UTF-16BE UTF-16LE
      UTF-32 UTF-32BE UTF-32LE
      UCS-2BE  UCS-2LE)
    )
  {
      my ( $size, $endian, $ucs2, $mask );
      $name =~ /^(\w+)-(\d+)(\w*)$/o;
      if ( $ucs2 = ( $1 eq 'UCS' ) ) {
          $size = 2;
      }
      else {
          $size = $2 / 8;
      }
      $endian = ( $3 eq 'BE' ) ? 'n' : ( $3 eq 'LE' ) ? 'v' : '';
      $size == 4 and $endian = uc($endian);
  
      my $obj = bless {
          Name   => $name,
          size   => $size,
          endian => $endian,
          ucs2   => $ucs2,
      } => __PACKAGE__;
      Encode::define_encoding($obj, $name);
  }
  
  use parent qw(Encode::Encoding);
  
  sub renew {
      my $self = shift;
      $BOM_Unknown{ $self->name } or return $self;
      my $clone = bless {%$self} => ref($self);
      $clone->{renewed}++;    # so the caller knows it is renewed.
      return $clone;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Encode::Unicode -- Various Unicode Transformation Formats
  
  =cut
  
  =head1 SYNOPSIS
  
      use Encode qw/encode decode/;
      $ucs2 = encode("UCS-2BE", $utf8);
      $utf8 = decode("UCS-2BE", $ucs2);
  
  =head1 ABSTRACT
  
  This module implements all Character Encoding Schemes of Unicode that
  are officially documented by Unicode Consortium (except, of course,
  for UTF-8, which is a native format in perl).
  
  =over 4
  
  =item L<http://www.unicode.org/glossary/> says:
  
  I<Character Encoding Scheme> A character encoding form plus byte
  serialization. There are Seven character encoding schemes in Unicode:
  UTF-8, UTF-16, UTF-16BE, UTF-16LE, UTF-32 (UCS-4), UTF-32BE (UCS-4BE) and
  UTF-32LE (UCS-4LE), and UTF-7.
  
  Since UTF-7 is a 7-bit (re)encoded version of UTF-16BE, It is not part of
  Unicode's Character Encoding Scheme.  It is separately implemented in
  Encode::Unicode::UTF7.  For details see L<Encode::Unicode::UTF7>.
  
  =item Quick Reference
  
                  Decodes from ord(N)           Encodes chr(N) to...
         octet/char BOM S.P d800-dfff  ord > 0xffff     \x{1abcd} ==
    ---------------+-----------------+------------------------------
    UCS-2BE       2   N   N  is bogus                  Not Available
    UCS-2LE       2   N   N     bogus                  Not Available
    UTF-16      2/4   Y   Y  is   S.P           S.P            BE/LE
    UTF-16BE    2/4   N   Y       S.P           S.P    0xd82a,0xdfcd
    UTF-16LE    2/4   N   Y       S.P           S.P    0x2ad8,0xcddf
    UTF-32        4   Y   -  is bogus         As is            BE/LE
    UTF-32BE      4   N   -     bogus         As is       0x0001abcd
    UTF-32LE      4   N   -     bogus         As is       0xcdab0100
    UTF-8       1-4   -   -     bogus   >= 4 octets   \xf0\x9a\af\8d
    ---------------+-----------------+------------------------------
  
  =back
  
  =head1 Size, Endianness, and BOM
  
  You can categorize these CES by 3 criteria:  size of each character,
  endianness, and Byte Order Mark.
  
  =head2 by size
  
  UCS-2 is a fixed-length encoding with each character taking 16 bits.
  It B<does not> support I<surrogate pairs>.  When a surrogate pair
  is encountered during decode(), its place is filled with \x{FFFD}
  if I<CHECK> is 0, or the routine croaks if I<CHECK> is 1.  When a
  character whose ord value is larger than 0xFFFF is encountered,
  its place is filled with \x{FFFD} if I<CHECK> is 0, or the routine
  croaks if I<CHECK> is 1.
  
  UTF-16 is almost the same as UCS-2 but it supports I<surrogate pairs>.
  When it encounters a high surrogate (0xD800-0xDBFF), it fetches the
  following low surrogate (0xDC00-0xDFFF) and C<desurrogate>s them to
  form a character.  Bogus surrogates result in death.  When \x{10000}
  or above is encountered during encode(), it C<ensurrogate>s them and
  pushes the surrogate pair to the output stream.
  
  UTF-32 (UCS-4) is a fixed-length encoding with each character taking 32 bits.
  Since it is 32-bit, there is no need for I<surrogate pairs>.
  
  =head2 by endianness
  
  The first (and now failed) goal of Unicode was to map all character
  repertoires into a fixed-length integer so that programmers are happy.
  Since each character is either a I<short> or I<long> in C, you have to
  pay attention to the endianness of each platform when you pass data
  to one another.
  
  Anything marked as BE is Big Endian (or network byte order) and LE is
  Little Endian (aka VAX byte order).  For anything not marked either
  BE or LE, a character called Byte Order Mark (BOM) indicating the
  endianness is prepended to the string.
  
  CAVEAT: Though BOM in utf8 (\xEF\xBB\xBF) is valid, it is meaningless
  and as of this writing Encode suite just leave it as is (\x{FeFF}).
  
  =over 4
  
  =item BOM as integer when fetched in network byte order
  
                16         32 bits/char
    -------------------------
    BE      0xFeFF 0x0000FeFF
    LE      0xFFFe 0xFFFe0000
    -------------------------
  
  =back
  
  This modules handles the BOM as follows.
  
  =over 4
  
  =item *
  
  When BE or LE is explicitly stated as the name of encoding, BOM is
  simply treated as a normal character (ZERO WIDTH NO-BREAK SPACE).
  
  =item *
  
  When BE or LE is omitted during decode(), it checks if BOM is at the
  beginning of the string; if one is found, the endianness is set to
  what the BOM says.
  
  =item *
  
  Default Byte Order
  
  When no BOM is found, Encode 2.76 and blow croaked.  Since Encode
  2.77, it falls back to BE accordingly to RFC2781 and the Unicode
  Standard version 8.0
  
  =item *
  
  When BE or LE is omitted during encode(), it returns a BE-encoded
  string with BOM prepended.  So when you want to encode a whole text
  file, make sure you encode() the whole text at once, not line by line
  or each line, not file, will have a BOM prepended.
  
  =item *
  
  C<UCS-2> is an exception.  Unlike others, this is an alias of UCS-2BE.
  UCS-2 is already registered by IANA and others that way.
  
  =back
  
  =head1 Surrogate Pairs
  
  To say the least, surrogate pairs were the biggest mistake of the
  Unicode Consortium.  But according to the late Douglas Adams in I<The
  Hitchhiker's Guide to the Galaxy> Trilogy, C<In the beginning the
  Universe was created. This has made a lot of people very angry and
  been widely regarded as a bad move>.  Their mistake was not of this
  magnitude so let's forgive them.
  
  (I don't dare make any comparison with Unicode Consortium and the
  Vogons here ;)  Or, comparing Encode to Babel Fish is completely
  appropriate -- if you can only stick this into your ear :)
  
  Surrogate pairs were born when the Unicode Consortium finally
  admitted that 16 bits were not big enough to hold all the world's
  character repertoires.  But they already made UCS-2 16-bit.  What
  do we do?
  
  Back then, the range 0xD800-0xDFFF was not allocated.  Let's split
  that range in half and use the first half to represent the C<upper
  half of a character> and the second half to represent the C<lower
  half of a character>.  That way, you can represent 1024 * 1024 =
  1048576 more characters.  Now we can store character ranges up to
  \x{10ffff} even with 16-bit encodings.  This pair of half-character is
  now called a I<surrogate pair> and UTF-16 is the name of the encoding
  that embraces them.
  
  Here is a formula to ensurrogate a Unicode character \x{10000} and
  above;
  
    $hi = ($uni - 0x10000) / 0x400 + 0xD800;
    $lo = ($uni - 0x10000) % 0x400 + 0xDC00;
  
  And to desurrogate;
  
   $uni = 0x10000 + ($hi - 0xD800) * 0x400 + ($lo - 0xDC00);
  
  Note this move has made \x{D800}-\x{DFFF} into a forbidden zone but
  perl does not prohibit the use of characters within this range.  To perl,
  every one of \x{0000_0000} up to \x{ffff_ffff} (*) is I<a character>.
  
    (*) or \x{ffff_ffff_ffff_ffff} if your perl is compiled with 64-bit
    integer support!
  
  =head1 Error Checking
  
  Unlike most encodings which accept various ways to handle errors,
  Unicode encodings simply croaks.
  
    % perl -MEncode -e'$_ = "\xfe\xff\xd8\xd9\xda\xdb\0\n"' \
           -e'Encode::from_to($_, "utf16","shift_jis", 0); print'
    UTF-16:Malformed LO surrogate d8d9 at /path/to/Encode.pm line 184.
    % perl -MEncode -e'$a = "BOM missing"' \
           -e' Encode::from_to($a, "utf16", "shift_jis", 0); print'
    UTF-16:Unrecognised BOM 424f at /path/to/Encode.pm line 184.
  
  Unlike other encodings where mappings are not one-to-one against
  Unicode, UTFs are supposed to map 100% against one another.  So Encode
  is more strict on UTFs.
  
  Consider that "division by zero" of Encode :)
  
  =head1 SEE ALSO
  
  L<Encode>, L<Encode::Unicode::UTF7>, L<https://www.unicode.org/glossary/>,
  L<https://www.unicode.org/faq/utf_bom.html>,
  
  RFC 2781 L<http://www.ietf.org/rfc/rfc2781.txt>,
  
  The whole Unicode standard L<https://www.unicode.org/standard/standard.html>
  
  Ch. 6 pp. 275 of C<Programming Perl (3rd Edition)>
  by Tom Christiansen, brian d foy & Larry Wall;
  O'Reilly & Associates; ISBN 978-0-596-00492-7
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_UNICODE

$fatpacked{"x86_64-linux-gnu-thread-multi/Encode/Unicode/UTF7.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_UNICODE_UTF7';
  #
  # $Id: UTF7.pm,v 2.10 2017/06/10 17:23:50 dankogai Exp $
  #
  package Encode::Unicode::UTF7;
  use strict;
  use warnings;
  use parent qw(Encode::Encoding);
  __PACKAGE__->Define('UTF-7');
  our $VERSION = do { my @r = ( q$Revision: 2.10 $ =~ /\d+/g ); sprintf "%d." . "%02d" x $#r, @r };
  use MIME::Base64;
  use Encode qw(find_encoding);
  
  #
  # Algorithms taken from Unicode::String by Gisle Aas
  #
  
  our $OPTIONAL_DIRECT_CHARS = 1;
  my $specials = quotemeta "\'(),-./:?";
  $OPTIONAL_DIRECT_CHARS
    and $specials .= quotemeta "!\"#$%&*;<=>@[]^_`{|}";
  
  # \s will not work because it matches U+3000 DEOGRAPHIC SPACE
  # We use qr/[\n\r\t\ ] instead
  my $re_asis    = qr/(?:[\n\r\t\ A-Za-z0-9$specials])/;
  my $re_encoded = qr/(?:[^\n\r\t\ A-Za-z0-9$specials])/;
  my $e_utf16    = find_encoding("UTF-16BE");
  
  sub needs_lines { 1 }
  
  sub encode($$;$) {
      my ( $obj, $str, $chk ) = @_;
      return undef unless defined $str;
      my $len = length($str);
      pos($str) = 0;
      my $bytes = substr($str, 0, 0); # to propagate taintedness
      while ( pos($str) < $len ) {
          if ( $str =~ /\G($re_asis+)/ogc ) {
  	    my $octets = $1;
  	    utf8::downgrade($octets);
  	    $bytes .= $octets;
          }
          elsif ( $str =~ /\G($re_encoded+)/ogsc ) {
              if ( $1 eq "+" ) {
                  $bytes .= "+-";
              }
              else {
                  my $s = $1;
                  my $base64 = encode_base64( $e_utf16->encode($s), '' );
                  $base64 =~ s/=+$//;
                  $bytes .= "+$base64-";
              }
          }
          else {
              die "This should not happen! (pos=" . pos($str) . ")";
          }
      }
      $_[1] = '' if $chk;
      return $bytes;
  }
  
  sub decode($$;$) {
      use re 'taint';
      my ( $obj, $bytes, $chk ) = @_;
      return undef unless defined $bytes;
      my $len = length($bytes);
      my $str = substr($bytes, 0, 0); # to propagate taintedness;
      pos($bytes) = 0;
      no warnings 'uninitialized';
      while ( pos($bytes) < $len ) {
          if ( $bytes =~ /\G([^+]+)/ogc ) {
              $str .= $1;
          }
          elsif ( $bytes =~ /\G\+-/ogc ) {
              $str .= "+";
          }
          elsif ( $bytes =~ /\G\+([A-Za-z0-9+\/]+)-?/ogsc ) {
              my $base64 = $1;
              my $pad    = length($base64) % 4;
              $base64 .= "=" x ( 4 - $pad ) if $pad;
              $str .= $e_utf16->decode( decode_base64($base64) );
          }
          elsif ( $bytes =~ /\G\+/ogc ) {
              $^W and warn "Bad UTF7 data escape";
              $str .= "+";
          }
          else {
              die "This should not happen " . pos($bytes);
          }
      }
      $_[1] = '' if $chk;
      return $str;
  }
  1;
  __END__
  
  =head1 NAME
  
  Encode::Unicode::UTF7 -- UTF-7 encoding
  
  =head1 SYNOPSIS
  
      use Encode qw/encode decode/; 
      $utf7 = encode("UTF-7", $utf8);
      $utf8 = decode("UTF-7", $ucs2);
  
  =head1 ABSTRACT
  
  This module implements UTF-7 encoding documented in RFC 2152.  UTF-7,
  as its name suggests, is a 7-bit re-encoded version of UTF-16BE.  It
  is designed to be MTA-safe and expected to be a standard way to
  exchange Unicoded mails via mails.  But with the advent of UTF-8 and
  8-bit compliant MTAs, UTF-7 is hardly ever used.
  
  UTF-7 was not supported by Encode until version 1.95 because of that.
  But Unicode::String, a module by Gisle Aas which adds Unicode supports
  to non-utf8-savvy perl did support UTF-7, the UTF-7 support was added
  so Encode can supersede Unicode::String 100%.
  
  =head1 In Practice
  
  When you want to encode Unicode for mails and web pages, however, do
  not use UTF-7 unless you are sure your recipients and readers can
  handle it.  Very few MUAs and WWW Browsers support these days (only
  Mozilla seems to support one).  For general cases, use UTF-8 for
  message body and MIME-Header for header instead.
  
  =head1 SEE ALSO
  
  L<Encode>, L<Encode::Unicode>, L<Unicode::String>
  
  RFC 2781 L<http://www.ietf.org/rfc/rfc2152.txt>
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_ENCODE_UNICODE_UTF7

$fatpacked{"x86_64-linux-gnu-thread-multi/File/Spec.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_FILE_SPEC';
  package File::Spec;
  
  use strict;
  
  our $VERSION = '3.75';
  $VERSION =~ tr/_//d;
  
  my %module = (
  	      MSWin32 => 'Win32',
  	      os2     => 'OS2',
  	      VMS     => 'VMS',
  	      NetWare => 'Win32', # Yes, File::Spec::Win32 works on NetWare.
  	      symbian => 'Win32', # Yes, File::Spec::Win32 works on symbian.
  	      dos     => 'OS2',   # Yes, File::Spec::OS2 works on DJGPP.
  	      cygwin  => 'Cygwin',
  	      amigaos => 'AmigaOS');
  
  
  my $module = $module{$^O} || 'Unix';
  
  require "File/Spec/$module.pm";
  our @ISA = ("File::Spec::$module");
  
  1;
  
  __END__
  
  =head1 NAME
  
  File::Spec - portably perform operations on file names
  
  =head1 SYNOPSIS
  
  	use File::Spec;
  
  	$x=File::Spec->catfile('a', 'b', 'c');
  
  which returns 'a/b/c' under Unix. Or:
  
  	use File::Spec::Functions;
  
  	$x = catfile('a', 'b', 'c');
  
  =head1 DESCRIPTION
  
  This module is designed to support operations commonly performed on file
  specifications (usually called "file names", but not to be confused with the
  contents of a file, or Perl's file handles), such as concatenating several
  directory and file names into a single path, or determining whether a path
  is rooted. It is based on code directly taken from MakeMaker 5.17, code
  written by Andreas KE<ouml>nig, Andy Dougherty, Charles Bailey, Ilya
  Zakharevich, Paul Schinder, and others.
  
  Since these functions are different for most operating systems, each set of
  OS specific routines is available in a separate module, including:
  
  	File::Spec::Unix
  	File::Spec::Mac
  	File::Spec::OS2
  	File::Spec::Win32
  	File::Spec::VMS
  
  The module appropriate for the current OS is automatically loaded by
  File::Spec. Since some modules (like VMS) make use of facilities available
  only under that OS, it may not be possible to load all modules under all
  operating systems.
  
  Since File::Spec is object oriented, subroutines should not be called directly,
  as in:
  
  	File::Spec::catfile('a','b');
  
  but rather as class methods:
  
  	File::Spec->catfile('a','b');
  
  For simple uses, L<File::Spec::Functions> provides convenient functional
  forms of these methods.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath
  X<canonpath>
  
  No physical check on the filesystem, but a logical cleanup of a
  path.
  
      $cpath = File::Spec->canonpath( $path ) ;
  
  Note that this does *not* collapse F<x/../y> sections into F<y>.  This
  is by design.  If F</foo> on your system is a symlink to F</bar/baz>,
  then F</foo/../quux> is actually F</bar/quux>, not F</quux> as a naive
  F<../>-removal would give you.  If you want to do this kind of
  processing, you probably want C<Cwd>'s C<realpath()> function to
  actually traverse the filesystem cleaning up paths like this.
  
  =item catdir
  X<catdir>
  
  Concatenate two or more directory names to form a complete path ending
  with a directory. But remove the trailing slash from the resulting
  string, because it doesn't look good, isn't necessary and confuses
  OS/2. Of course, if this is the root directory, don't cut off the
  trailing slash :-)
  
      $path = File::Spec->catdir( @directories );
  
  =item catfile
  X<catfile>
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
      $path = File::Spec->catfile( @directories, $filename );
  
  =item curdir
  X<curdir>
  
  Returns a string representation of the current directory.
  
      $curdir = File::Spec->curdir();
  
  =item devnull
  X<devnull>
  
  Returns a string representation of the null device.
  
      $devnull = File::Spec->devnull();
  
  =item rootdir
  X<rootdir>
  
  Returns a string representation of the root directory.
  
      $rootdir = File::Spec->rootdir();
  
  =item tmpdir
  X<tmpdir>
  
  Returns a string representation of the first writable directory from a
  list of possible temporary directories.  Returns the current directory
  if no writable temporary directories are found.  The list of directories
  checked depends on the platform; e.g. File::Spec::Unix checks C<$ENV{TMPDIR}>
  (unless taint is on) and F</tmp>.
  
      $tmpdir = File::Spec->tmpdir();
  
  =item updir
  X<updir>
  
  Returns a string representation of the parent directory.
  
      $updir = File::Spec->updir();
  
  =item no_upwards
  
  Given a list of files in a directory (such as from C<readdir()>),
  strip out C<'.'> and C<'..'>.
  
  B<SECURITY NOTE:> This does NOT filter paths containing C<'..'>, like
  C<'../../../../etc/passwd'>, only literal matches to C<'.'> and C<'..'>.
  
      @paths = File::Spec->no_upwards( readdir $dirhandle );
  
  =item case_tolerant
  
  Returns a true or false value indicating, respectively, that alphabetic
  case is not or is significant when comparing file specifications.
  Cygwin and Win32 accept an optional drive argument.
  
      $is_case_tolerant = File::Spec->case_tolerant();
  
  =item file_name_is_absolute
  
  Takes as its argument a path, and returns true if it is an absolute path.
  
      $is_absolute = File::Spec->file_name_is_absolute( $path );
  
  This does not consult the local filesystem on Unix, Win32, OS/2, or
  Mac OS (Classic).  It does consult the working environment for VMS
  (see L<File::Spec::VMS/file_name_is_absolute>).
  
  =item path
  X<path>
  
  Takes no argument.  Returns the environment variable C<PATH> (or the local
  platform's equivalent) as a list.
  
      @PATH = File::Spec->path();
  
  =item join
  X<join, path>
  
  join is the same as catfile.
  
  =item splitpath
  X<splitpath> X<split, path>
  
  Splits a path in to volume, directory, and filename portions. On systems
  with no concept of volume, returns '' for volume. 
  
      ($volume,$directories,$file) =
                         File::Spec->splitpath( $path );
      ($volume,$directories,$file) =
                         File::Spec->splitpath( $path, $no_file );
  
  For systems with no syntax differentiating filenames from directories, 
  assumes that the last file is a path unless C<$no_file> is true or a
  trailing separator or F</.> or F</..> is present. On Unix, this means that C<$no_file>
  true makes this return ( '', $path, '' ).
  
  The directory portion may or may not be returned with a trailing '/'.
  
  The results can be passed to L</catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  =item splitdir
  X<splitdir> X<split, dir>
  
  The opposite of L</catdir>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  C<$directories> must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, empty
  directory names (C<''>) can be returned, because these are significant
  on some OSes.
  
  =item catpath()
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, C<$volume> is ignored, and directory and file are concatenated.  A '/' is
  inserted if need be.  On other OSes, C<$volume> is significant.
  
      $full_path = File::Spec->catpath( $volume, $directory, $file );
  
  =item abs2rel
  X<abs2rel> X<absolute, path> X<relative, path>
  
  Takes a destination path and an optional base path returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  If C<$base> is not present or '', then L<Cwd::cwd()|Cwd> is used. If C<$base> is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<Cwd::cwd()|Cwd>.
  
  On systems with the concept of volume, if C<$path> and C<$base> appear to be
  on two different volumes, we will not attempt to resolve the two
  paths, and we will instead simply return C<$path>.  Note that previous
  versions of this module ignored the volume of C<$base>, which resulted in
  garbage results part of the time.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  C<$base> filename as well. Otherwise all path components are assumed to be
  directories.
  
  If C<$path> is relative, it is converted to absolute form using L</rel2abs()>.
  This means that it is taken to be relative to L<Cwd::cwd()|Cwd>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =item rel2abs()
  X<rel2abs> X<absolute, path> X<relative, path>
  
  Converts a relative path to an absolute path. 
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  If C<$base> is not present or '', then L<Cwd::cwd()|Cwd> is used. If C<$base> is relative,
  then it is converted to absolute form using L</rel2abs()>. This means that it
  is taken to be relative to L<Cwd::cwd()|Cwd>.
  
  On systems with the concept of volume, if C<$path> and C<$base> appear to be
  on two different volumes, we will not attempt to resolve the two
  paths, and we will instead simply return C<$path>.  Note that previous
  versions of this module ignored the volume of C<$base>, which resulted in
  garbage results part of the time.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  C<$base> filename as well. Otherwise all path components are assumed to be
  directories.
  
  If C<$path> is absolute, it is cleaned up and returned using L</canonpath>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =back
  
  For further information, please see L<File::Spec::Unix>,
  L<File::Spec::Mac>, L<File::Spec::OS2>, L<File::Spec::Win32>, or
  L<File::Spec::VMS>.
  
  =head1 SEE ALSO
  
  L<File::Spec::Unix>, L<File::Spec::Mac>, L<File::Spec::OS2>,
  L<File::Spec::Win32>, L<File::Spec::VMS>, L<File::Spec::Functions>,
  L<ExtUtils::MakeMaker>
  
  =head1 AUTHOR
  
  Currently maintained by Ken Williams C<< <KWILLIAMS@cpan.org> >>.
  
  The vast majority of the code was written by
  Kenneth Albanowski C<< <kjahds@kjahds.com> >>,
  Andy Dougherty C<< <doughera@lafayette.edu> >>,
  Andreas KE<ouml>nig C<< <A.Koenig@franz.ww.TU-Berlin.DE> >>,
  Tim Bunce C<< <Tim.Bunce@ig.co.uk> >>.
  VMS support by Charles Bailey C<< <bailey@newman.upenn.edu> >>.
  OS/2 support by Ilya Zakharevich C<< <ilya@math.ohio-state.edu> >>.
  Mac support by Paul Schinder C<< <schinder@pobox.com> >>, and
  Thomas Wegner C<< <wegner_thomas@yahoo.com> >>.
  abs2rel() and rel2abs() written by Shigio Yamaguchi C<< <shigio@tamacom.com> >>,
  modified by Barrie Slaymaker C<< <barries@slaysys.com> >>.
  splitpath(), splitdir(), catpath() and catdir() by Barrie Slaymaker.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004-2013 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_FILE_SPEC

$fatpacked{"x86_64-linux-gnu-thread-multi/File/Spec/AmigaOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_FILE_SPEC_AMIGAOS';
  package File::Spec::AmigaOS;
  
  use strict;
  require File::Spec::Unix;
  
  our $VERSION = '3.75';
  $VERSION =~ tr/_//d;
  
  our @ISA = qw(File::Spec::Unix);
  
  =head1 NAME
  
  File::Spec::AmigaOS - File::Spec for AmigaOS
  
  =head1 SYNOPSIS
  
   require File::Spec::AmigaOS; # Done automatically by File::Spec
                                # if needed
  
  =head1 DESCRIPTION
  
  Methods for manipulating file specifications.
  
  =head1 METHODS
  
  =over 2
  
  =item tmpdir
  
  Returns $ENV{TMPDIR} or if that is unset, "/t".
  
  =cut
  
  my $tmpdir;
  sub tmpdir {
    return $tmpdir if defined $tmpdir;
    $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, "/t" );
  }
  
  =item file_name_is_absolute
  
  Returns true if there's a colon in the file name,
  or if it begins with a slash.
  
  =cut
  
  sub file_name_is_absolute {
    my ($self, $file) = @_;
  
    # Not 100% robust as a "/" must not preceded a ":"
    # but this cannot happen in a well formed path.
    return $file =~ m{^/|:}s;
  }
  
  =back
  
  All the other methods are from L<File::Spec::Unix>.
  
  =cut
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_FILE_SPEC_AMIGAOS

$fatpacked{"x86_64-linux-gnu-thread-multi/File/Spec/Cygwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_FILE_SPEC_CYGWIN';
  package File::Spec::Cygwin;
  
  use strict;
  require File::Spec::Unix;
  
  our $VERSION = '3.75';
  $VERSION =~ tr/_//d;
  
  our @ISA = qw(File::Spec::Unix);
  
  =head1 NAME
  
  File::Spec::Cygwin - methods for Cygwin file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Cygwin; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  This module is still in beta.  Cygwin-knowledgeable folks are invited
  to offer patches and suggestions.
  
  =cut
  
  =pod
  
  =over 4
  
  =item canonpath
  
  Any C<\> (backslashes) are converted to C</> (forward slashes),
  and then File::Spec::Unix canonpath() is called on the result.
  
  =cut
  
  sub canonpath {
      my($self,$path) = @_;
      return unless defined $path;
  
      $path =~ s|\\|/|g;
  
      # Handle network path names beginning with double slash
      my $node = '';
      if ( $path =~ s@^(//[^/]+)(?:/|\z)@/@s ) {
          $node = $1;
      }
      return $node . $self->SUPER::canonpath($path);
  }
  
  sub catdir {
      my $self = shift;
      return unless @_;
  
      # Don't create something that looks like a //network/path
      if ($_[0] and ($_[0] eq '/' or $_[0] eq '\\')) {
          shift;
          return $self->SUPER::catdir('', @_);
      }
  
      $self->SUPER::catdir(@_);
  }
  
  =pod
  
  =item file_name_is_absolute
  
  True is returned if the file name begins with C<drive_letter:>,
  and if not, File::Spec::Unix file_name_is_absolute() is called.
  
  =cut
  
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return 1 if $file =~ m{^([a-z]:)?[\\/]}is; # C:/test
      return $self->SUPER::file_name_is_absolute($file);
  }
  
  =item tmpdir (override)
  
  Returns a string representation of the first existing directory
  from the following list:
  
      $ENV{TMPDIR}
      /tmp
      $ENV{'TMP'}
      $ENV{'TEMP'}
      C:/temp
  
  If running under taint mode, and if the environment
  variables are tainted, they are not used.
  
  =cut
  
  sub tmpdir {
      my $cached = $_[0]->_cached_tmpdir(qw 'TMPDIR TMP TEMP');
      return $cached if defined $cached;
      $_[0]->_cache_tmpdir(
          $_[0]->_tmpdir(
              $ENV{TMPDIR}, "/tmp", $ENV{'TMP'}, $ENV{'TEMP'}, 'C:/temp'
          ),
          qw 'TMPDIR TMP TEMP'
      );
  }
  
  =item case_tolerant
  
  Override Unix. Cygwin case-tolerance depends on managed mount settings and
  as with MsWin32 on GetVolumeInformation() $ouFsFlags == FS_CASE_SENSITIVE,
  indicating the case significance when comparing file specifications.
  Default: 1
  
  =cut
  
  sub case_tolerant {
    return 1 unless $^O eq 'cygwin'
      and defined &Cygwin::mount_flags;
  
    my $drive = shift;
    if (! $drive) {
        my @flags = split(/,/, Cygwin::mount_flags('/cygwin'));
        my $prefix = pop(@flags);
        if (! $prefix || $prefix eq 'cygdrive') {
            $drive = '/cygdrive/c';
        } elsif ($prefix eq '/') {
            $drive = '/c';
        } else {
            $drive = "$prefix/c";
        }
    }
    my $mntopts = Cygwin::mount_flags($drive);
    if ($mntopts and ($mntopts =~ /,managed/)) {
      return 0;
    }
    eval {
        local @INC = @INC;
        pop @INC if $INC[-1] eq '.';
        require Win32API::File;
    } or return 1;
    my $osFsType = "\0"x256;
    my $osVolName = "\0"x256;
    my $ouFsFlags = 0;
    Win32API::File::GetVolumeInformation($drive, $osVolName, 256, [], [], $ouFsFlags, $osFsType, 256 );
    if ($ouFsFlags & Win32API::File::FS_CASE_SENSITIVE()) { return 0; }
    else { return 1; }
  }
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004,2007 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_FILE_SPEC_CYGWIN

$fatpacked{"x86_64-linux-gnu-thread-multi/File/Spec/Epoc.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_FILE_SPEC_EPOC';
  package File::Spec::Epoc;
  
  use strict;
  
  our $VERSION = '3.75';
  $VERSION =~ tr/_//d;
  
  require File::Spec::Unix;
  our @ISA = qw(File::Spec::Unix);
  
  =head1 NAME
  
  File::Spec::Epoc - methods for Epoc file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Epoc; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there.  This package overrides the implementation of these methods, not
  the semantics.
  
  This package is still a work in progress. ;-)
  
  =cut
  
  sub case_tolerant {
      return 1;
  }
  
  =pod
  
  =over 4
  
  =item canonpath()
  
  No physical check on the filesystem, but a logical cleanup of a
  path.  On UNIX eliminated successive slashes and successive "/.".
  
  =back
  
  =cut
  
  sub canonpath {
      my ($self,$path) = @_;
      return unless defined $path;
  
      $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx
      $path =~ s|(/\.)+/|/|g;                        # xx/././xx -> xx/xx
      $path =~ s|^(\./)+||s unless $path eq "./";    # ./xx      -> xx
      $path =~ s|^/(\.\./)+|/|s;                     # /../../xx -> xx
      $path =~  s|/\Z(?!\n)|| unless $path eq "/";          # xx/       -> xx
      return $path;
  }
  
  =pod
  
  =head1 AUTHOR
  
  o.flebbe@gmx.de
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_FILE_SPEC_EPOC

$fatpacked{"x86_64-linux-gnu-thread-multi/File/Spec/Functions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_FILE_SPEC_FUNCTIONS';
  package File::Spec::Functions;
  
  use File::Spec;
  use strict;
  
  our $VERSION = '3.75';
  $VERSION =~ tr/_//d;
  
  require Exporter;
  
  our @ISA = qw(Exporter);
  
  our @EXPORT = qw(
  	canonpath
  	catdir
  	catfile
  	curdir
  	rootdir
  	updir
  	no_upwards
  	file_name_is_absolute
  	path
  );
  
  our @EXPORT_OK = qw(
  	devnull
  	tmpdir
  	splitpath
  	splitdir
  	catpath
  	abs2rel
  	rel2abs
  	case_tolerant
  );
  
  our %EXPORT_TAGS = ( ALL => [ @EXPORT_OK, @EXPORT ] );
  
  require File::Spec::Unix;
  my %udeps = (
      canonpath => [],
      catdir => [qw(canonpath)],
      catfile => [qw(canonpath catdir)],
      case_tolerant => [],
      curdir => [],
      devnull => [],
      rootdir => [],
      updir => [],
  );
  
  foreach my $meth (@EXPORT, @EXPORT_OK) {
      my $sub = File::Spec->can($meth);
      no strict 'refs';
      if (exists($udeps{$meth}) && $sub == File::Spec::Unix->can($meth) &&
  	    !(grep {
  		File::Spec->can($_) != File::Spec::Unix->can($_)
  	    } @{$udeps{$meth}}) &&
  	    defined(&{"File::Spec::Unix::_fn_$meth"})) {
  	*{$meth} = \&{"File::Spec::Unix::_fn_$meth"};
      } else {
  	*{$meth} = sub {&$sub('File::Spec', @_)};
      }
  }
  
  
  1;
  __END__
  
  =head1 NAME
  
  File::Spec::Functions - portably perform operations on file names
  
  =head1 SYNOPSIS
  
  	use File::Spec::Functions;
  	$x = catfile('a','b');
  
  =head1 DESCRIPTION
  
  This module exports convenience functions for all of the class methods
  provided by File::Spec.
  
  For a reference of available functions, please consult L<File::Spec::Unix>,
  which contains the entire set, and which is inherited by the modules for
  other platforms. For further information, please see L<File::Spec::Mac>,
  L<File::Spec::OS2>, L<File::Spec::Win32>, or L<File::Spec::VMS>.
  
  =head2 Exports
  
  The following functions are exported by default.
  
  	canonpath
  	catdir
  	catfile
  	curdir
  	rootdir
  	updir
  	no_upwards
  	file_name_is_absolute
  	path
  
  
  The following functions are exported only by request.
  
  	devnull
  	tmpdir
  	splitpath
  	splitdir
  	catpath
  	abs2rel
  	rel2abs
  	case_tolerant
  
  All the functions may be imported using the C<:ALL> tag.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  File::Spec, File::Spec::Unix, File::Spec::Mac, File::Spec::OS2,
  File::Spec::Win32, File::Spec::VMS, ExtUtils::MakeMaker
  
  =cut
  
X86_64-LINUX-GNU-THREAD-MULTI_FILE_SPEC_FUNCTIONS

$fatpacked{"x86_64-linux-gnu-thread-multi/File/Spec/Mac.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_FILE_SPEC_MAC';
  package File::Spec::Mac;
  
  use strict;
  use Cwd ();
  require File::Spec::Unix;
  
  our $VERSION = '3.75';
  $VERSION =~ tr/_//d;
  
  our @ISA = qw(File::Spec::Unix);
  
  sub case_tolerant { 1 }
  
  
  =head1 NAME
  
  File::Spec::Mac - File::Spec for Mac OS (Classic)
  
  =head1 SYNOPSIS
  
   require File::Spec::Mac; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  Methods for manipulating file specifications.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath
  
  On Mac OS, there's nothing to be done. Returns what it's given.
  
  =cut
  
  sub canonpath {
      my ($self,$path) = @_;
      return $path;
  }
  
  =item catdir()
  
  Concatenate two or more directory names to form a path separated by colons
  (":") ending with a directory. Resulting paths are B<relative> by default,
  but can be forced to be absolute (but avoid this, see below). Automatically
  puts a trailing ":" on the end of the complete path, because that's what's
  done in MacPerl's environment and helps to distinguish a file path from a
  directory path.
  
  B<IMPORTANT NOTE:> Beginning with version 1.3 of this module, the resulting
  path is relative by default and I<not> absolute. This decision was made due
  to portability reasons. Since C<File::Spec-E<gt>catdir()> returns relative paths
  on all other operating systems, it will now also follow this convention on Mac
  OS. Note that this may break some existing scripts.
  
  The intended purpose of this routine is to concatenate I<directory names>.
  But because of the nature of Macintosh paths, some additional possibilities
  are allowed to make using this routine give reasonable results for some
  common situations. In other words, you are also allowed to concatenate
  I<paths> instead of directory names (strictly speaking, a string like ":a"
  is a path, but not a name, since it contains a punctuation character ":").
  
  So, beside calls like
  
      catdir("a") = ":a:"
      catdir("a","b") = ":a:b:"
      catdir() = ""                    (special case)
  
  calls like the following
  
      catdir(":a:") = ":a:"
      catdir(":a","b") = ":a:b:"
      catdir(":a:","b") = ":a:b:"
      catdir(":a:",":b:") = ":a:b:"
      catdir(":") = ":"
  
  are allowed.
  
  Here are the rules that are used in C<catdir()>; note that we try to be as
  compatible as possible to Unix:
  
  =over 2
  
  =item 1.
  
  The resulting path is relative by default, i.e. the resulting path will have a
  leading colon.
  
  =item 2.
  
  A trailing colon is added automatically to the resulting path, to denote a
  directory.
  
  =item 3.
  
  Generally, each argument has one leading ":" and one trailing ":"
  removed (if any). They are then joined together by a ":". Special
  treatment applies for arguments denoting updir paths like "::lib:",
  see (4), or arguments consisting solely of colons ("colon paths"),
  see (5).
  
  =item 4.
  
  When an updir path like ":::lib::" is passed as argument, the number
  of directories to climb up is handled correctly, not removing leading
  or trailing colons when necessary. E.g.
  
      catdir(":::a","::b","c")    = ":::a::b:c:"
      catdir(":::a::","::b","c")  = ":::a:::b:c:"
  
  =item 5.
  
  Adding a colon ":" or empty string "" to a path at I<any> position
  doesn't alter the path, i.e. these arguments are ignored. (When a ""
  is passed as the first argument, it has a special meaning, see
  (6)). This way, a colon ":" is handled like a "." (curdir) on Unix,
  while an empty string "" is generally ignored (see
  L<File::Spec::Unix/canonpath()> ). Likewise, a "::" is handled like a ".."
  (updir), and a ":::" is handled like a "../.." etc.  E.g.
  
      catdir("a",":",":","b")   = ":a:b:"
      catdir("a",":","::",":b") = ":a::b:"
  
  =item 6.
  
  If the first argument is an empty string "" or is a volume name, i.e. matches
  the pattern /^[^:]+:/, the resulting path is B<absolute>.
  
  =item 7.
  
  Passing an empty string "" as the first argument to C<catdir()> is
  like passingC<File::Spec-E<gt>rootdir()> as the first argument, i.e.
  
      catdir("","a","b")          is the same as
  
      catdir(rootdir(),"a","b").
  
  This is true on Unix, where C<catdir("","a","b")> yields "/a/b" and
  C<rootdir()> is "/". Note that C<rootdir()> on Mac OS is the startup
  volume, which is the closest in concept to Unix' "/". This should help
  to run existing scripts originally written for Unix.
  
  =item 8.
  
  For absolute paths, some cleanup is done, to ensure that the volume
  name isn't immediately followed by updirs. This is invalid, because
  this would go beyond "root". Generally, these cases are handled like
  their Unix counterparts:
  
   Unix:
      Unix->catdir("","")                 =  "/"
      Unix->catdir("",".")                =  "/"
      Unix->catdir("","..")               =  "/"        # can't go
                                                        # beyond root
      Unix->catdir("",".","..","..","a")  =  "/a"
   Mac:
      Mac->catdir("","")                  =  rootdir()  # (e.g. "HD:")
      Mac->catdir("",":")                 =  rootdir()
      Mac->catdir("","::")                =  rootdir()  # can't go
                                                        # beyond root
      Mac->catdir("",":","::","::","a")   =  rootdir() . "a:"
                                                      # (e.g. "HD:a:")
  
  However, this approach is limited to the first arguments following
  "root" (again, see L<File::Spec::Unix/canonpath()>. If there are more
  arguments that move up the directory tree, an invalid path going
  beyond root can be created.
  
  =back
  
  As you've seen, you can force C<catdir()> to create an absolute path
  by passing either an empty string or a path that begins with a volume
  name as the first argument. However, you are strongly encouraged not
  to do so, since this is done only for backward compatibility. Newer
  versions of File::Spec come with a method called C<catpath()> (see
  below), that is designed to offer a portable solution for the creation
  of absolute paths.  It takes volume, directory and file portions and
  returns an entire path. While C<catdir()> is still suitable for the
  concatenation of I<directory names>, you are encouraged to use
  C<catpath()> to concatenate I<volume names> and I<directory
  paths>. E.g.
  
      $dir      = File::Spec->catdir("tmp","sources");
      $abs_path = File::Spec->catpath("MacintoshHD:", $dir,"");
  
  yields
  
      "MacintoshHD:tmp:sources:" .
  
  =cut
  
  sub catdir {
  	my $self = shift;
  	return '' unless @_;
  	my @args = @_;
  	my $first_arg;
  	my $relative;
  
  	# take care of the first argument
  
  	if ($args[0] eq '')  { # absolute path, rootdir
  		shift @args;
  		$relative = 0;
  		$first_arg = $self->rootdir;
  
  	} elsif ($args[0] =~ /^[^:]+:/) { # absolute path, volume name
  		$relative = 0;
  		$first_arg = shift @args;
  		# add a trailing ':' if need be (may be it's a path like HD:dir)
  		$first_arg = "$first_arg:" unless ($first_arg =~ /:\Z(?!\n)/);
  
  	} else { # relative path
  		$relative = 1;
  		if ( $args[0] =~ /^::+\Z(?!\n)/ ) {
  			# updir colon path ('::', ':::' etc.), don't shift
  			$first_arg = ':';
  		} elsif ($args[0] eq ':') {
  			$first_arg = shift @args;
  		} else {
  			# add a trailing ':' if need be
  			$first_arg = shift @args;
  			$first_arg = "$first_arg:" unless ($first_arg =~ /:\Z(?!\n)/);
  		}
  	}
  
  	# For all other arguments,
  	# (a) ignore arguments that equal ':' or '',
  	# (b) handle updir paths specially:
  	#     '::' 			-> concatenate '::'
  	#     '::' . '::' 	-> concatenate ':::' etc.
  	# (c) add a trailing ':' if need be
  
  	my $result = $first_arg;
  	while (@args) {
  		my $arg = shift @args;
  		unless (($arg eq '') || ($arg eq ':')) {
  			if ($arg =~ /^::+\Z(?!\n)/ ) { # updir colon path like ':::'
  				my $updir_count = length($arg) - 1;
  				while ((@args) && ($args[0] =~ /^::+\Z(?!\n)/) ) { # while updir colon path
  					$arg = shift @args;
  					$updir_count += (length($arg) - 1);
  				}
  				$arg = (':' x $updir_count);
  			} else {
  				$arg =~ s/^://s; # remove a leading ':' if any
  				$arg = "$arg:" unless ($arg =~ /:\Z(?!\n)/); # ensure trailing ':'
  			}
  			$result .= $arg;
  		}#unless
  	}
  
  	if ( ($relative) && ($result !~ /^:/) ) {
  		# add a leading colon if need be
  		$result = ":$result";
  	}
  
  	unless ($relative) {
  		# remove updirs immediately following the volume name
  		$result =~ s/([^:]+:)(:*)(.*)\Z(?!\n)/$1$3/;
  	}
  
  	return $result;
  }
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename. Resulting paths are B<relative>
  by default, but can be forced to be absolute (but avoid this).
  
  B<IMPORTANT NOTE:> Beginning with version 1.3 of this module, the
  resulting path is relative by default and I<not> absolute. This
  decision was made due to portability reasons. Since
  C<File::Spec-E<gt>catfile()> returns relative paths on all other
  operating systems, it will now also follow this convention on Mac OS.
  Note that this may break some existing scripts.
  
  The last argument is always considered to be the file portion. Since
  C<catfile()> uses C<catdir()> (see above) for the concatenation of the
  directory portions (if any), the following with regard to relative and
  absolute paths is true:
  
      catfile("")     = ""
      catfile("file") = "file"
  
  but
  
      catfile("","")        = rootdir()         # (e.g. "HD:")
      catfile("","file")    = rootdir() . file  # (e.g. "HD:file")
      catfile("HD:","file") = "HD:file"
  
  This means that C<catdir()> is called only when there are two or more
  arguments, as one might expect.
  
  Note that the leading ":" is removed from the filename, so that
  
      catfile("a","b","file")  = ":a:b:file"    and
  
      catfile("a","b",":file") = ":a:b:file"
  
  give the same answer.
  
  To concatenate I<volume names>, I<directory paths> and I<filenames>,
  you are encouraged to use C<catpath()> (see below).
  
  =cut
  
  sub catfile {
      my $self = shift;
      return '' unless @_;
      my $file = pop @_;
      return $file unless @_;
      my $dir = $self->catdir(@_);
      $file =~ s/^://s;
      return $dir.$file;
  }
  
  =item curdir
  
  Returns a string representing the current directory. On Mac OS, this is ":".
  
  =cut
  
  sub curdir {
      return ":";
  }
  
  =item devnull
  
  Returns a string representing the null device. On Mac OS, this is "Dev:Null".
  
  =cut
  
  sub devnull {
      return "Dev:Null";
  }
  
  =item rootdir
  
  Returns the empty string.  Mac OS has no real root directory.
  
  =cut
  
  sub rootdir { '' }
  
  =item tmpdir
  
  Returns the contents of $ENV{TMPDIR}, if that directory exits or the
  current working directory otherwise. Under MacPerl, $ENV{TMPDIR} will
  contain a path like "MacintoshHD:Temporary Items:", which is a hidden
  directory on your startup volume.
  
  =cut
  
  sub tmpdir {
      my $cached = $_[0]->_cached_tmpdir('TMPDIR');
      return $cached if defined $cached;
      $_[0]->_cache_tmpdir($_[0]->_tmpdir( $ENV{TMPDIR} ), 'TMPDIR');
  }
  
  =item updir
  
  Returns a string representing the parent directory. On Mac OS, this is "::".
  
  =cut
  
  sub updir {
      return "::";
  }
  
  =item file_name_is_absolute
  
  Takes as argument a path and returns true, if it is an absolute path.
  If the path has a leading ":", it's a relative path. Otherwise, it's an
  absolute path, unless the path doesn't contain any colons, i.e. it's a name
  like "a". In this particular case, the path is considered to be relative
  (i.e. it is considered to be a filename). Use ":" in the appropriate place
  in the path if you want to distinguish unambiguously. As a special case,
  the filename '' is always considered to be absolute. Note that with version
  1.2 of File::Spec::Mac, this does no longer consult the local filesystem.
  
  E.g.
  
      File::Spec->file_name_is_absolute("a");         # false (relative)
      File::Spec->file_name_is_absolute(":a:b:");     # false (relative)
      File::Spec->file_name_is_absolute("MacintoshHD:");
                                                      # true (absolute)
      File::Spec->file_name_is_absolute("");          # true (absolute)
  
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      if ($file =~ /:/) {
  	return (! ($file =~ m/^:/s) );
      } elsif ( $file eq '' ) {
          return 1 ;
      } else {
  	return 0; # i.e. a file like "a"
      }
  }
  
  =item path
  
  Returns the null list for the MacPerl application, since the concept is
  usually meaningless under Mac OS. But if you're using the MacPerl tool under
  MPW, it gives back $ENV{Commands} suitably split, as is done in
  :lib:ExtUtils:MM_Mac.pm.
  
  =cut
  
  sub path {
  #
  #  The concept is meaningless under the MacPerl application.
  #  Under MPW, it has a meaning.
  #
      return unless exists $ENV{Commands};
      return split(/,/, $ENV{Commands});
  }
  
  =item splitpath
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                            $no_file );
  
  Splits a path into volume, directory, and filename portions.
  
  On Mac OS, assumes that the last part of the path is a filename unless
  $no_file is true or a trailing separator ":" is present.
  
  The volume portion is always returned with a trailing ":". The directory portion
  is always returned with a leading (to denote a relative path) and a trailing ":"
  (to denote a directory). The file portion is always returned I<without> a leading ":".
  Empty portions are returned as empty string ''.
  
  The results can be passed to C<catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file);
  
      if ( $nofile ) {
          ( $volume, $directory ) = $path =~ m|^((?:[^:]+:)?)(.*)|s;
      }
      else {
          $path =~
              m|^( (?: [^:]+: )? )
                 ( (?: .*: )? )
                 ( .* )
               |xs;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      $volume = '' unless defined($volume);
  	$directory = ":$directory" if ( $volume && $directory ); # take care of "HD::dir"
      if ($directory) {
          # Make sure non-empty directories begin and end in ':'
          $directory .= ':' unless (substr($directory,-1) eq ':');
          $directory = ":$directory" unless (substr($directory,0,1) eq ':');
      } else {
  	$directory = '';
      }
      $file = '' unless defined($file);
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of C<catdir()>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories should be only the directory portion of the path on systems
  that have the concept of a volume or that have path syntax that differentiates
  files from directories. Consider using C<splitpath()> otherwise.
  
  Unlike just splitting the directories on the separator, empty directory names
  (C<"">) can be returned. Since C<catdir()> on Mac OS always appends a trailing
  colon to distinguish a directory path from a file path, a single trailing colon
  will be ignored, i.e. there's no empty directory name after it.
  
  Hence, on Mac OS, both
  
      File::Spec->splitdir( ":a:b::c:" );    and
      File::Spec->splitdir( ":a:b::c" );
  
  yield:
  
      ( "a", "b", "::", "c")
  
  while
  
      File::Spec->splitdir( ":a:b::c::" );
  
  yields:
  
      ( "a", "b", "::", "c", "::")
  
  
  =cut
  
  sub splitdir {
  	my ($self, $path) = @_;
  	my @result = ();
  	my ($head, $sep, $tail, $volume, $directories);
  
  	return @result if ( (!defined($path)) || ($path eq '') );
  	return (':') if ($path eq ':');
  
  	( $volume, $sep, $directories ) = $path =~ m|^((?:[^:]+:)?)(:*)(.*)|s;
  
  	# deprecated, but handle it correctly
  	if ($volume) {
  		push (@result, $volume);
  		$sep .= ':';
  	}
  
  	while ($sep || $directories) {
  		if (length($sep) > 1) {
  			my $updir_count = length($sep) - 1;
  			for (my $i=0; $i<$updir_count; $i++) {
  				# push '::' updir_count times;
  				# simulate Unix '..' updirs
  				push (@result, '::');
  			}
  		}
  		$sep = '';
  		if ($directories) {
  			( $head, $sep, $tail ) = $directories =~ m|^((?:[^:]+)?)(:*)(.*)|s;
  			push (@result, $head);
  			$directories = $tail;
  		}
  	}
  	return @result;
  }
  
  
  =item catpath
  
      $path = File::Spec->catpath($volume,$directory,$file);
  
  Takes volume, directory and file portions and returns an entire path. On Mac OS,
  $volume, $directory and $file are concatenated.  A ':' is inserted if need be. You
  may pass an empty string for each portion. If all portions are empty, the empty
  string is returned. If $volume is empty, the result will be a relative path,
  beginning with a ':'. If $volume and $directory are empty, a leading ":" (if any)
  is removed form $file and the remainder is returned. If $file is empty, the
  resulting path will have a trailing ':'.
  
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      if ( (! $volume) && (! $directory) ) {
  	$file =~ s/^:// if $file;
  	return $file ;
      }
  
      # We look for a volume in $volume, then in $directory, but not both
  
      my ($dir_volume, $dir_dirs) = $self->splitpath($directory, 1);
  
      $volume = $dir_volume unless length $volume;
      my $path = $volume; # may be ''
      $path .= ':' unless (substr($path, -1) eq ':'); # ensure trailing ':'
  
      if ($directory) {
  	$directory = $dir_dirs if $volume;
  	$directory =~ s/^://; # remove leading ':' if any
  	$path .= $directory;
  	$path .= ':' unless (substr($path, -1) eq ':'); # ensure trailing ':'
      }
  
      if ($file) {
  	$file =~ s/^://; # remove leading ':' if any
  	$path .= $file;
      }
  
      return $path;
  }
  
  =item abs2rel
  
  Takes a destination path and an optional base path and returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  Note that both paths are assumed to have a notation that distinguishes a
  directory path (with trailing ':') from a file path (without trailing ':').
  
  If $base is not present or '', then the current working directory is used.
  If $base is relative, then it is converted to absolute form using C<rel2abs()>.
  This means that it is taken to be relative to the current working directory.
  
  If $path and $base appear to be on two different volumes, we will not
  attempt to resolve the two paths, and we will instead simply return
  $path.  Note that previous versions of this module ignored the volume
  of $base, which resulted in garbage results part of the time.
  
  If $base doesn't have a trailing colon, the last element of $base is
  assumed to be a filename.  This filename is ignored.  Otherwise all path
  components are assumed to be directories.
  
  If $path is relative, it is converted to absolute form using C<rel2abs()>.
  This means that it is taken to be relative to the current working directory.
  
  Based on code written by Shigio Yamaguchi.
  
  
  =cut
  
  # maybe this should be done in canonpath() ?
  sub _resolve_updirs {
  	my $path = shift @_;
  	my $proceed;
  
  	# resolve any updirs, e.g. "HD:tmp::file" -> "HD:file"
  	do {
  		$proceed = ($path =~ s/^(.*):[^:]+::(.*?)\z/$1:$2/);
  	} while ($proceed);
  
  	return $path;
  }
  
  
  sub abs2rel {
      my($self,$path,$base) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          $path = $self->rel2abs( $path ) ;
      }
  
      # Figure out the effective $base and clean it up.
      if ( !defined( $base ) || $base eq '' ) {
  	$base = Cwd::getcwd();
      }
      elsif ( ! $self->file_name_is_absolute( $base ) ) {
          $base = $self->rel2abs( $base ) ;
  	$base = _resolve_updirs( $base ); # resolve updirs in $base
      }
      else {
  	$base = _resolve_updirs( $base );
      }
  
      # Split up paths - ignore $base's file
      my ( $path_vol, $path_dirs, $path_file ) =  $self->splitpath( $path );
      my ( $base_vol, $base_dirs )             =  $self->splitpath( $base );
  
      return $path unless lc( $path_vol ) eq lc( $base_vol );
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_dirs );
      my @basechunks = $self->splitdir( $base_dirs );
  	
      while ( @pathchunks &&
  	    @basechunks &&
  	    lc( $pathchunks[0] ) eq lc( $basechunks[0] ) ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # @pathchunks now has the directories to descend in to.
      # ensure relative path, even if @pathchunks is empty
      $path_dirs = $self->catdir( ':', @pathchunks );
  
      # @basechunks now contains the number of directories to climb out of.
      $base_dirs = (':' x @basechunks) . ':' ;
  
      return $self->catpath( '', $self->catdir( $base_dirs, $path_dirs ), $path_file ) ;
  }
  
  =item rel2abs
  
  Converts a relative path to an absolute path:
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  Note that both paths are assumed to have a notation that distinguishes a
  directory path (with trailing ':') from a file path (without trailing ':').
  
  If $base is not present or '', then $base is set to the current working
  directory. If $base is relative, then it is converted to absolute form
  using C<rel2abs()>. This means that it is taken to be relative to the
  current working directory.
  
  If $base doesn't have a trailing colon, the last element of $base is
  assumed to be a filename.  This filename is ignored.  Otherwise all path
  components are assumed to be directories.
  
  If $path is already absolute, it is returned and $base is ignored.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub rel2abs {
      my ($self,$path,$base) = @_;
  
      if ( ! $self->file_name_is_absolute($path) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = Cwd::getcwd();
          }
          elsif ( ! $self->file_name_is_absolute($base) ) {
              $base = $self->rel2abs($base) ;
          }
  
  	# Split up paths
  
  	# ignore $path's volume
          my ( $path_dirs, $path_file ) = ($self->splitpath($path))[1,2] ;
  
          # ignore $base's file part
  	my ( $base_vol, $base_dirs ) = $self->splitpath($base) ;
  
  	# Glom them together
  	$path_dirs = ':' if ($path_dirs eq '');
  	$base_dirs =~ s/:$//; # remove trailing ':', if any
  	$base_dirs = $base_dirs . $path_dirs;
  
          $path = $self->catpath( $base_vol, $base_dirs, $path_file );
      }
      return $path;
  }
  
  
  =back
  
  =head1 AUTHORS
  
  See the authors list in I<File::Spec>. Mac OS support by Paul Schinder
  <schinder@pobox.com> and Thomas Wegner <wegner_thomas@yahoo.com>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_FILE_SPEC_MAC

$fatpacked{"x86_64-linux-gnu-thread-multi/File/Spec/OS2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_FILE_SPEC_OS2';
  package File::Spec::OS2;
  
  use strict;
  use Cwd ();
  require File::Spec::Unix;
  
  our $VERSION = '3.75';
  $VERSION =~ tr/_//d;
  
  our @ISA = qw(File::Spec::Unix);
  
  sub devnull {
      return "/dev/nul";
  }
  
  sub case_tolerant {
      return 1;
  }
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return scalar($file =~ m{^([a-z]:)?[\\/]}is);
  }
  
  sub path {
      my $path = $ENV{PATH};
      $path =~ s:\\:/:g;
      my @path = split(';',$path);
      foreach (@path) { $_ = '.' if $_ eq '' }
      return @path;
  }
  
  sub tmpdir {
      my $cached = $_[0]->_cached_tmpdir(qw 'TMPDIR TEMP TMP');
      return $cached if defined $cached;
      my @d = @ENV{qw(TMPDIR TEMP TMP)};	# function call could autovivivy
      $_[0]->_cache_tmpdir(
  	$_[0]->_tmpdir( @d, '/tmp', '/' ), qw 'TMPDIR TEMP TMP'
      );
  }
  
  sub catdir {
      my $self = shift;
      my @args = @_;
      foreach (@args) {
  	tr[\\][/];
          # append a backslash to each argument unless it has one there
          $_ .= "/" unless m{/$};
      }
      return $self->canonpath(join('', @args));
  }
  
  sub canonpath {
      my ($self,$path) = @_;
      return unless defined $path;
  
      $path =~ s/^([a-z]:)/\l$1/s;
      $path =~ s|\\|/|g;
      $path =~ s|([^/])/+|$1/|g;                  # xx////xx  -> xx/xx
      $path =~ s|(/\.)+/|/|g;                     # xx/././xx -> xx/xx
      $path =~ s|^(\./)+(?=[^/])||s;		# ./xx      -> xx
      $path =~ s|/\Z(?!\n)||
               unless $path =~ m#^([a-z]:)?/\Z(?!\n)#si;# xx/       -> xx
      $path =~ s{^/\.\.$}{/};                     # /..    -> /
      1 while $path =~ s{^/\.\.}{};               # /../xx -> /xx
      return $path;
  }
  
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file) = ('','','');
      if ( $nofile ) {
          $path =~ 
              m{^( (?:[a-zA-Z]:|(?:\\\\|//)[^\\/]+[\\/][^\\/]+)? ) 
                   (.*)
               }xs;
          $volume    = $1;
          $directory = $2;
      }
      else {
          $path =~ 
              m{^ ( (?: [a-zA-Z]: |
                        (?:\\\\|//)[^\\/]+[\\/][^\\/]+
                    )?
                  )
                  ( (?:.*[\\\\/](?:\.\.?\Z(?!\n))?)? )
                  (.*)
               }xs;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  sub splitdir {
      my ($self,$directories) = @_ ;
      split m|[\\/]|, $directories, -1;
  }
  
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      # If it's UNC, make sure the glue separator is there, reusing
      # whatever separator is first in the $volume
      $volume .= $1
          if ( $volume =~ m@^([\\/])[\\/][^\\/]+[\\/][^\\/]+\Z(?!\n)@s &&
               $directory =~ m@^[^\\/]@s
             ) ;
  
      $volume .= $directory ;
  
      # If the volume is not just A:, make sure the glue separator is 
      # there, reusing whatever separator is first in the $volume if possible.
      if ( $volume !~ m@^[a-zA-Z]:\Z(?!\n)@s &&
           $volume =~ m@[^\\/]\Z(?!\n)@      &&
           $file   =~ m@[^\\/]@
         ) {
          $volume =~ m@([\\/])@ ;
          my $sep = $1 ? $1 : '/' ;
          $volume .= $sep ;
      }
  
      $volume .= $file ;
  
      return $volume ;
  }
  
  
  sub abs2rel {
      my($self,$path,$base) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          $path = $self->rel2abs( $path ) ;
      } else {
          $path = $self->canonpath( $path ) ;
      }
  
      # Figure out the effective $base and clean it up.
      if ( !defined( $base ) || $base eq '' ) {
  	$base = Cwd::getcwd();
      } elsif ( ! $self->file_name_is_absolute( $base ) ) {
          $base = $self->rel2abs( $base ) ;
      } else {
          $base = $self->canonpath( $base ) ;
      }
  
      # Split up paths
      my ( $path_volume, $path_directories, $path_file ) = $self->splitpath( $path, 1 ) ;
      my ( $base_volume, $base_directories ) = $self->splitpath( $base, 1 ) ;
      return $path unless $path_volume eq $base_volume;
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my @basechunks = $self->splitdir( $base_directories );
  
      while ( @pathchunks && 
              @basechunks && 
              lc( $pathchunks[0] ) eq lc( $basechunks[0] ) 
            ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # No need to catdir, we know these are well formed.
      $path_directories = CORE::join( '/', @pathchunks );
      $base_directories = CORE::join( '/', @basechunks );
  
      # $base_directories now contains the directories the resulting relative
      # path must ascend out of before it can descend to $path_directory.  So, 
      # replace all names with $parentDir
  
      #FA Need to replace between backslashes...
      $base_directories =~ s|[^\\/]+|..|g ;
  
      # Glue the two together, using a separator if necessary, and preventing an
      # empty result.
  
      #FA Must check that new directories are not empty.
      if ( $path_directories ne '' && $base_directories ne '' ) {
          $path_directories = "$base_directories/$path_directories" ;
      } else {
          $path_directories = "$base_directories$path_directories" ;
      }
  
      return $self->canonpath( 
          $self->catpath( "", $path_directories, $path_file ) 
      ) ;
  }
  
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      if ( ! $self->file_name_is_absolute( $path ) ) {
  
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = Cwd::getcwd();
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          my ( $path_directories, $path_file ) =
              ($self->splitpath( $path, 1 ))[1,2] ;
  
          my ( $base_volume, $base_directories ) =
              $self->splitpath( $base, 1 ) ;
  
          $path = $self->catpath( 
              $base_volume, 
              $self->catdir( $base_directories, $path_directories ), 
              $path_file
          ) ;
      }
  
      return $self->canonpath( $path ) ;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  File::Spec::OS2 - methods for OS/2 file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::OS2; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  Amongst the changes made for OS/2 are...
  
  =over 4
  
  =item tmpdir
  
  Modifies the list of places temp directory information is looked for.
  
      $ENV{TMPDIR}
      $ENV{TEMP}
      $ENV{TMP}
      /tmp
      /
  
  =item splitpath
  
  Volumes can be drive letters or UNC sharenames (\\server\share).
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_FILE_SPEC_OS2

$fatpacked{"x86_64-linux-gnu-thread-multi/File/Spec/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_FILE_SPEC_UNIX';
  package File::Spec::Unix;
  
  use strict;
  use Cwd ();
  
  our $VERSION = '3.75';
  $VERSION =~ tr/_//d;
  
  =head1 NAME
  
  File::Spec::Unix - File::Spec for Unix, base for other File::Spec modules
  
  =head1 SYNOPSIS
  
   require File::Spec::Unix; # Done automatically by File::Spec
  
  =head1 DESCRIPTION
  
  Methods for manipulating file specifications.  Other File::Spec
  modules, such as File::Spec::Mac, inherit from File::Spec::Unix and
  override specific methods.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath()
  
  No physical check on the filesystem, but a logical cleanup of a
  path. On UNIX eliminates successive slashes and successive "/.".
  
      $cpath = File::Spec->canonpath( $path ) ;
  
  Note that this does *not* collapse F<x/../y> sections into F<y>.  This
  is by design.  If F</foo> on your system is a symlink to F</bar/baz>,
  then F</foo/../quux> is actually F</bar/quux>, not F</quux> as a naive
  F<../>-removal would give you.  If you want to do this kind of
  processing, you probably want C<Cwd>'s C<realpath()> function to
  actually traverse the filesystem cleaning up paths like this.
  
  =cut
  
  sub _pp_canonpath {
      my ($self,$path) = @_;
      return unless defined $path;
      
      # Handle POSIX-style node names beginning with double slash (qnx, nto)
      # (POSIX says: "a pathname that begins with two successive slashes
      # may be interpreted in an implementation-defined manner, although
      # more than two leading slashes shall be treated as a single slash.")
      my $node = '';
      my $double_slashes_special = $^O eq 'qnx' || $^O eq 'nto';
  
  
      if ( $double_slashes_special
           && ( $path =~ s{^(//[^/]+)/?\z}{}s || $path =~ s{^(//[^/]+)/}{/}s ) ) {
        $node = $1;
      }
      # This used to be
      # $path =~ s|/+|/|g unless ($^O eq 'cygwin');
      # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail
      # (Mainly because trailing "" directories didn't get stripped).
      # Why would cygwin avoid collapsing multiple slashes into one? --jhi
      $path =~ s|/{2,}|/|g;                            # xx////xx  -> xx/xx
      $path =~ s{(?:/\.)+(?:/|\z)}{/}g;                # xx/././xx -> xx/xx
      $path =~ s|^(?:\./)+||s unless $path eq "./";    # ./xx      -> xx
      $path =~ s|^/(?:\.\./)+|/|;                      # /../../xx -> xx
      $path =~ s|^/\.\.$|/|;                         # /..       -> /
      $path =~ s|/\z|| unless $path eq "/";          # xx/       -> xx
      return "$node$path";
  }
  *canonpath = \&_pp_canonpath unless defined &canonpath;
  
  =item catdir()
  
  Concatenate two or more directory names to form a complete path ending
  with a directory. But remove the trailing slash from the resulting
  string, because it doesn't look good, isn't necessary and confuses
  OS2. Of course, if this is the root directory, don't cut off the
  trailing slash :-)
  
  =cut
  
  sub _pp_catdir {
      my $self = shift;
  
      $self->canonpath(join('/', @_, '')); # '' because need a trailing '/'
  }
  *catdir = \&_pp_catdir unless defined &catdir;
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
  =cut
  
  sub _pp_catfile {
      my $self = shift;
      my $file = $self->canonpath(pop @_);
      return $file unless @_;
      my $dir = $self->catdir(@_);
      $dir .= "/" unless substr($dir,-1) eq "/";
      return $dir.$file;
  }
  *catfile = \&_pp_catfile unless defined &catfile;
  
  =item curdir
  
  Returns a string representation of the current directory.  "." on UNIX.
  
  =cut
  
  sub curdir { '.' }
  use constant _fn_curdir => ".";
  
  =item devnull
  
  Returns a string representation of the null device. "/dev/null" on UNIX.
  
  =cut
  
  sub devnull { '/dev/null' }
  use constant _fn_devnull => "/dev/null";
  
  =item rootdir
  
  Returns a string representation of the root directory.  "/" on UNIX.
  
  =cut
  
  sub rootdir { '/' }
  use constant _fn_rootdir => "/";
  
  =item tmpdir
  
  Returns a string representation of the first writable directory from
  the following list or the current directory if none from the list are
  writable:
  
      $ENV{TMPDIR}
      /tmp
  
  If running under taint mode, and if $ENV{TMPDIR}
  is tainted, it is not used.
  
  =cut
  
  my ($tmpdir, %tmpenv);
  # Cache and return the calculated tmpdir, recording which env vars
  # determined it.
  sub _cache_tmpdir {
      @tmpenv{@_[2..$#_]} = @ENV{@_[2..$#_]};
      return $tmpdir = $_[1];
  }
  # Retrieve the cached tmpdir, checking first whether relevant env vars have
  # changed and invalidated the cache.
  sub _cached_tmpdir {
      shift;
      local $^W;
      return if grep $ENV{$_} ne $tmpenv{$_}, @_;
      return $tmpdir;
  }
  sub _tmpdir {
      my $self = shift;
      my @dirlist = @_;
      my $taint = do { no strict 'refs'; ${"\cTAINT"} };
      if ($taint) { # Check for taint mode on perl >= 5.8.0
  	require Scalar::Util;
  	@dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;
      }
      elsif ($] < 5.007) { # No ${^TAINT} before 5.8
  	@dirlist = grep { !defined($_) || eval { eval('1'.substr $_,0,0) } }
  			@dirlist;
      }
      
      foreach (@dirlist) {
  	next unless defined && -d && -w _;
  	$tmpdir = $_;
  	last;
      }
      $tmpdir = $self->curdir unless defined $tmpdir;
      $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);
      if ( !$self->file_name_is_absolute($tmpdir) ) {
          # See [perl #120593] for the full details
          # If possible, return a full path, rather than '.' or 'lib', but
          # jump through some hoops to avoid returning a tainted value.
          ($tmpdir) = grep {
              $taint     ? ! Scalar::Util::tainted($_) :
              $] < 5.007 ? eval { eval('1'.substr $_,0,0) } : 1
          } $self->rel2abs($tmpdir), $tmpdir;
      }
      return $tmpdir;
  }
  
  sub tmpdir {
      my $cached = $_[0]->_cached_tmpdir('TMPDIR');
      return $cached if defined $cached;
      $_[0]->_cache_tmpdir($_[0]->_tmpdir( $ENV{TMPDIR}, "/tmp" ), 'TMPDIR');
  }
  
  =item updir
  
  Returns a string representation of the parent directory.  ".." on UNIX.
  
  =cut
  
  sub updir { '..' }
  use constant _fn_updir => "..";
  
  =item no_upwards
  
  Given a list of file names, strip out those that refer to a parent
  directory. (Does not strip symlinks, only '.', '..', and equivalents.)
  
  =cut
  
  sub no_upwards {
      my $self = shift;
      return grep(!/^\.{1,2}\z/s, @_);
  }
  
  =item case_tolerant
  
  Returns a true or false value indicating, respectively, that alphabetic
  is not or is significant when comparing file specifications.
  
  =cut
  
  sub case_tolerant { 0 }
  use constant _fn_case_tolerant => 0;
  
  =item file_name_is_absolute
  
  Takes as argument a path and returns true if it is an absolute path.
  
  This does not consult the local filesystem on Unix, Win32, OS/2 or Mac 
  OS (Classic).  It does consult the working environment for VMS (see
  L<File::Spec::VMS/file_name_is_absolute>).
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return scalar($file =~ m:^/:s);
  }
  
  =item path
  
  Takes no argument, returns the environment variable PATH as an array.
  
  =cut
  
  sub path {
      return () unless exists $ENV{PATH};
      my @path = split(':', $ENV{PATH});
      foreach (@path) { $_ = '.' if $_ eq '' }
      return @path;
  }
  
  =item join
  
  join is the same as catfile.
  
  =cut
  
  sub join {
      my $self = shift;
      return $self->catfile(@_);
  }
  
  =item splitpath
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                            $no_file );
  
  Splits a path into volume, directory, and filename portions. On systems
  with no concept of volume, returns '' for volume. 
  
  For systems with no syntax differentiating filenames from directories, 
  assumes that the last file is a path unless $no_file is true or a 
  trailing separator or /. or /.. is present. On Unix this means that $no_file
  true makes this return ( '', $path, '' ).
  
  The directory portion may or may not be returned with a trailing '/'.
  
  The results can be passed to L</catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
  
      my ($volume,$directory,$file) = ('','','');
  
      if ( $nofile ) {
          $directory = $path;
      }
      else {
          $path =~ m|^ ( (?: .* / (?: \.\.?\z )? )? ) ([^/]*) |xs;
          $directory = $1;
          $file      = $2;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of L</catdir()>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, empty
  directory names (C<''>) can be returned, because these are significant
  on some OSs.
  
  On Unix,
  
      File::Spec->splitdir( "/a/b//c/" );
  
  Yields:
  
      ( '', 'a', 'b', '', 'c', '' )
  
  =cut
  
  sub splitdir {
      return split m|/|, $_[1], -1;  # Preserve trailing fields
  }
  
  
  =item catpath()
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, $volume is ignored, and directory and file are concatenated.  A '/' is
  inserted if needed (though if the directory portion doesn't start with
  '/' it is not added).  On other OSs, $volume is significant.
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      if ( $directory ne ''                && 
           $file ne ''                     && 
           substr( $directory, -1 ) ne '/' && 
           substr( $file, 0, 1 ) ne '/' 
      ) {
          $directory .= "/$file" ;
      }
      else {
          $directory .= $file ;
      }
  
      return $directory ;
  }
  
  =item abs2rel
  
  Takes a destination path and an optional base path returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  If $base is not present or '', then L<cwd()|Cwd> is used. If $base is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<cwd()|Cwd>.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  $base filename. Otherwise all path components are assumed to be
  directories.
  
  If $path is relative, it is converted to absolute form using L</rel2abs()>.
  This means that it is taken to be relative to L<cwd()|Cwd>.
  
  No checks against the filesystem are made, so the result may not be correct if
  C<$base> contains symbolic links.  (Apply
  L<Cwd::abs_path()|Cwd/abs_path> beforehand if that
  is a concern.)  On VMS, there is interaction with the working environment, as
  logicals and macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub abs2rel {
      my($self,$path,$base) = @_;
      $base = Cwd::getcwd() unless defined $base and length $base;
  
      ($path, $base) = map $self->canonpath($_), $path, $base;
  
      my $path_directories;
      my $base_directories;
  
      if (grep $self->file_name_is_absolute($_), $path, $base) {
  	($path, $base) = map $self->rel2abs($_), $path, $base;
  
  	my ($path_volume) = $self->splitpath($path, 1);
  	my ($base_volume) = $self->splitpath($base, 1);
  
  	# Can't relativize across volumes
  	return $path unless $path_volume eq $base_volume;
  
  	$path_directories = ($self->splitpath($path, 1))[1];
  	$base_directories = ($self->splitpath($base, 1))[1];
  
  	# For UNC paths, the user might give a volume like //foo/bar that
  	# strictly speaking has no directory portion.  Treat it as if it
  	# had the root directory for that volume.
  	if (!length($base_directories) and $self->file_name_is_absolute($base)) {
  	    $base_directories = $self->rootdir;
  	}
      }
      else {
  	my $wd= ($self->splitpath(Cwd::getcwd(), 1))[1];
  	$path_directories = $self->catdir($wd, $path);
  	$base_directories = $self->catdir($wd, $base);
      }
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my @basechunks = $self->splitdir( $base_directories );
  
      if ($base_directories eq $self->rootdir) {
        return $self->curdir if $path_directories eq $self->rootdir;
        shift @pathchunks;
        return $self->canonpath( $self->catpath('', $self->catdir( @pathchunks ), '') );
      }
  
      my @common;
      while (@pathchunks && @basechunks && $self->_same($pathchunks[0], $basechunks[0])) {
          push @common, shift @pathchunks ;
          shift @basechunks ;
      }
      return $self->curdir unless @pathchunks || @basechunks;
  
      # @basechunks now contains the directories the resulting relative path 
      # must ascend out of before it can descend to $path_directory.  If there
      # are updir components, we must descend into the corresponding directories
      # (this only works if they are no symlinks).
      my @reverse_base;
      while( defined(my $dir= shift @basechunks) ) {
  	if( $dir ne $self->updir ) {
  	    unshift @reverse_base, $self->updir;
  	    push @common, $dir;
  	}
  	elsif( @common ) {
  	    if( @reverse_base && $reverse_base[0] eq $self->updir ) {
  		shift @reverse_base;
  		pop @common;
  	    }
  	    else {
  		unshift @reverse_base, pop @common;
  	    }
  	}
      }
      my $result_dirs = $self->catdir( @reverse_base, @pathchunks );
      return $self->canonpath( $self->catpath('', $result_dirs, '') );
  }
  
  sub _same {
    $_[1] eq $_[2];
  }
  
  =item rel2abs()
  
  Converts a relative path to an absolute path. 
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  If $base is not present or '', then L<cwd()|Cwd> is used. If $base is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<cwd()|Cwd>.
  
  On systems that have a grammar that indicates filenames, this ignores
  the $base filename. Otherwise all path components are assumed to be
  directories.
  
  If $path is absolute, it is cleaned up and returned using L</canonpath()>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = Cwd::getcwd();
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          # Glom them together
          $path = $self->catdir( $base, $path ) ;
      }
  
      return $self->canonpath( $path ) ;
  }
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  Please submit bug reports and patches to perlbug@perl.org.
  
  =head1 SEE ALSO
  
  L<File::Spec>
  
  =cut
  
  # Internal method to reduce xx\..\yy -> yy
  sub _collapse {
      my($fs, $path) = @_;
  
      my $updir  = $fs->updir;
      my $curdir = $fs->curdir;
  
      my($vol, $dirs, $file) = $fs->splitpath($path);
      my @dirs = $fs->splitdir($dirs);
      pop @dirs if @dirs && $dirs[-1] eq '';
  
      my @collapsed;
      foreach my $dir (@dirs) {
          if( $dir eq $updir              and   # if we have an updir
              @collapsed                  and   # and something to collapse
              length $collapsed[-1]       and   # and its not the rootdir
              $collapsed[-1] ne $updir    and   # nor another updir
              $collapsed[-1] ne $curdir         # nor the curdir
            ) 
          {                                     # then
              pop @collapsed;                   # collapse
          }
          else {                                # else
              push @collapsed, $dir;            # just hang onto it
          }
      }
  
      return $fs->catpath($vol,
                          $fs->catdir(@collapsed),
                          $file
                         );
  }
  
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_FILE_SPEC_UNIX

$fatpacked{"x86_64-linux-gnu-thread-multi/File/Spec/VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_FILE_SPEC_VMS';
  package File::Spec::VMS;
  
  use strict;
  use Cwd ();
  require File::Spec::Unix;
  
  our $VERSION = '3.75';
  $VERSION =~ tr/_//d;
  
  our @ISA = qw(File::Spec::Unix);
  
  use File::Basename;
  use VMS::Filespec;
  
  =head1 NAME
  
  File::Spec::VMS - methods for VMS file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::VMS; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  The default behavior is to allow either VMS or Unix syntax on input and to 
  return VMS syntax on output unless Unix syntax has been explicitly requested
  via the C<DECC$FILENAME_UNIX_REPORT> CRTL feature.
  
  =over 4
  
  =cut
  
  # Need to look up the feature settings.  The preferred way is to use the
  # VMS::Feature module, but that may not be available to dual life modules.
  
  my $use_feature;
  BEGIN {
      if (eval { local $SIG{__DIE__};
                 local @INC = @INC;
                 pop @INC if $INC[-1] eq '.';
                 require VMS::Feature; }) {
          $use_feature = 1;
      }
  }
  
  # Need to look up the UNIX report mode.  This may become a dynamic mode
  # in the future.
  sub _unix_rpt {
      my $unix_rpt;
      if ($use_feature) {
          $unix_rpt = VMS::Feature::current("filename_unix_report");
      } else {
          my $env_unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
          $unix_rpt = $env_unix_rpt =~ /^[ET1]/i; 
      }
      return $unix_rpt;
  }
  
  =item canonpath (override)
  
  Removes redundant portions of file specifications and returns results
  in native syntax unless Unix filename reporting has been enabled.
  
  =cut
  
  
  sub canonpath {
      my($self,$path) = @_;
  
      return undef unless defined $path;
  
      my $unix_rpt = $self->_unix_rpt;
  
      if ($path =~ m|/|) {
        my $pathify = $path =~ m|/\Z(?!\n)|;
        $path = $self->SUPER::canonpath($path);
  
        return $path if $unix_rpt;
        $path = $pathify ? vmspath($path) : vmsify($path);
      }
  
      $path =~ s/(?<!\^)</[/;			# < and >       ==> [ and ]
      $path =~ s/(?<!\^)>/]/;
      $path =~ s/(?<!\^)\]\[\./\.\]\[/g;		# ][.		==> .][
      $path =~ s/(?<!\^)\[000000\.\]\[/\[/g;	# [000000.][	==> [
      $path =~ s/(?<!\^)\[000000\./\[/g;		# [000000.	==> [
      $path =~ s/(?<!\^)\.\]\[000000\]/\]/g;	# .][000000]	==> ]
      $path =~ s/(?<!\^)\.\]\[/\./g;		# foo.][bar     ==> foo.bar
      1 while ($path =~ s/(?<!\^)([\[\.])(-+)\.(-+)([\.\]])/$1$2$3$4/);
  						# That loop does the following
  						# with any amount of dashes:
  						# .-.-.		==> .--.
  						# [-.-.		==> [--.
  						# .-.-]		==> .--]
  						# [-.-]		==> [--]
      1 while ($path =~ s/(?<!\^)([\[\.])(?:\^.|[^\]\.])+\.-(-+)([\]\.])/$1$2$3/);
  						# That loop does the following
  						# with any amount (minimum 2)
  						# of dashes:
  						# .foo.--.	==> .-.
  						# .foo.--]	==> .-]
  						# [foo.--.	==> [-.
  						# [foo.--]	==> [-]
  						#
  						# And then, the remaining cases
      $path =~ s/(?<!\^)\[\.-/[-/;		# [.-		==> [-
      $path =~ s/(?<!\^)\.(?:\^.|[^\]\.])+\.-\./\./g;	# .foo.-.	==> .
      $path =~ s/(?<!\^)\[(?:\^.|[^\]\.])+\.-\./\[/g;	# [foo.-.	==> [
      $path =~ s/(?<!\^)\.(?:\^.|[^\]\.])+\.-\]/\]/g;	# .foo.-]	==> ]
  						# [foo.-]       ==> [000000]
      $path =~ s/(?<!\^)\[(?:\^.|[^\]\.])+\.-\]/\[000000\]/g;
  						# []		==>
      $path =~ s/(?<!\^)\[\]// unless $path eq '[]';
      return $unix_rpt ? unixify($path) : $path;
  }
  
  =item catdir (override)
  
  Concatenates a list of file specifications, and returns the result as a
  native directory specification unless the Unix filename reporting feature
  has been enabled.  No check is made for "impossible" cases (e.g. elements
  other than the first being absolute filespecs).
  
  =cut
  
  sub catdir {
      my $self = shift;
      my $dir = pop;
  
      my $unix_rpt = $self->_unix_rpt;
  
      my @dirs = grep {defined() && length()} @_;
  
      my $rslt;
      if (@dirs) {
  	my $path = (@dirs == 1 ? $dirs[0] : $self->catdir(@dirs));
  	my ($spath,$sdir) = ($path,$dir);
  	$spath =~ s/\.dir\Z(?!\n)//i; $sdir =~ s/\.dir\Z(?!\n)//i; 
  
  	if ($unix_rpt) {
  	    $spath = unixify($spath) unless $spath =~ m#/#;
  	    $sdir= unixify($sdir) unless $sdir =~ m#/#;
              return $self->SUPER::catdir($spath, $sdir)
  	}
  
  	$rslt = vmspath( unixify($spath) . '/' . unixify($sdir));
  
  	# Special case for VMS absolute directory specs: these will have
  	# had device prepended during trip through Unix syntax in
  	# eliminate_macros(), since Unix syntax has no way to express
  	# "absolute from the top of this device's directory tree".
  	if ($spath =~ /^[\[<][^.\-]/s) { $rslt =~ s/^[^\[<]+//s; }
  
      } else {
  	# Single directory. Return an empty string on null input; otherwise
  	# just return a canonical path.
  
  	if    (not defined $dir or not length $dir) {
  	    $rslt = '';
  	} else {
  	    $rslt = $unix_rpt ? $dir : vmspath($dir);
  	}
      }
      return $self->canonpath($rslt);
  }
  
  =item catfile (override)
  
  Concatenates a list of directory specifications with a filename specification
  to build a path.
  
  =cut
  
  sub catfile {
      my $self = shift;
      my $tfile = pop();
      my $file = $self->canonpath($tfile);
      my @files = grep {defined() && length()} @_;
  
      my $unix_rpt = $self->_unix_rpt;
  
      my $rslt;
      if (@files) {
  	my $path = (@files == 1 ? $files[0] : $self->catdir(@files));
  	my $spath = $path;
  
          # Something building a VMS path in pieces may try to pass a
          # directory name in filename format, so normalize it.
  	$spath =~ s/\.dir\Z(?!\n)//i;
  
          # If the spath ends with a directory delimiter and the file is bare,
          # then just concatenate them.
  	if ($spath =~ /^(?<!\^)[^\)\]\/:>]+\)\Z(?!\n)/s && basename($file) eq $file) {
  	    $rslt = "$spath$file";
  	} else {
             $rslt = unixify($spath);
             $rslt .= (defined($rslt) && length($rslt) ? '/' : '') . unixify($file);
             $rslt = vmsify($rslt) unless $unix_rpt;
  	}
      }
      else {
          # Only passed a single file?
          my $xfile = (defined($file) && length($file)) ? $file : '';
  
          $rslt = $unix_rpt ? $xfile : vmsify($xfile);
      }
      return $self->canonpath($rslt) unless $unix_rpt;
  
      # In Unix report mode, do not strip off redundant path information.
      return $rslt;
  }
  
  
  =item curdir (override)
  
  Returns a string representation of the current directory: '[]' or '.'
  
  =cut
  
  sub curdir {
      my $self = shift @_;
      return '.' if ($self->_unix_rpt);
      return '[]';
  }
  
  =item devnull (override)
  
  Returns a string representation of the null device: '_NLA0:' or '/dev/null'
  
  =cut
  
  sub devnull {
      my $self = shift @_;
      return '/dev/null' if ($self->_unix_rpt);
      return "_NLA0:";
  }
  
  =item rootdir (override)
  
  Returns a string representation of the root directory: 'SYS$DISK:[000000]'
  or '/'
  
  =cut
  
  sub rootdir {
      my $self = shift @_;
      if ($self->_unix_rpt) {
         # Root may exist, try it first.
         my $try = '/';
         my ($dev1, $ino1) = stat('/');
         my ($dev2, $ino2) = stat('.');
  
         # Perl falls back to '.' if it can not determine '/'
         if (($dev1 != $dev2) || ($ino1 != $ino2)) {
             return $try;
         }
         # Fall back to UNIX format sys$disk.
         return '/sys$disk/';
      }
      return 'SYS$DISK:[000000]';
  }
  
  =item tmpdir (override)
  
  Returns a string representation of the first writable directory
  from the following list or '' if none are writable:
  
      /tmp if C<DECC$FILENAME_UNIX_REPORT> is enabled.
      sys$scratch:
      $ENV{TMPDIR}
  
  If running under taint mode, and if $ENV{TMPDIR}
  is tainted, it is not used.
  
  =cut
  
  sub tmpdir {
      my $self = shift @_;
      my $tmpdir = $self->_cached_tmpdir('TMPDIR');
      return $tmpdir if defined $tmpdir;
      if ($self->_unix_rpt) {
          $tmpdir = $self->_tmpdir('/tmp', '/sys$scratch', $ENV{TMPDIR});
      }
      else {
          $tmpdir = $self->_tmpdir( 'sys$scratch:', $ENV{TMPDIR} );
      }
      $self->_cache_tmpdir($tmpdir, 'TMPDIR');
  }
  
  =item updir (override)
  
  Returns a string representation of the parent directory: '[-]' or '..'
  
  =cut
  
  sub updir {
      my $self = shift @_;
      return '..' if ($self->_unix_rpt);
      return '[-]';
  }
  
  =item case_tolerant (override)
  
  VMS file specification syntax is case-tolerant.
  
  =cut
  
  sub case_tolerant {
      return 1;
  }
  
  =item path (override)
  
  Translate logical name DCL$PATH as a searchlist, rather than trying
  to C<split> string value of C<$ENV{'PATH'}>.
  
  =cut
  
  sub path {
      my (@dirs,$dir,$i);
      while ($dir = $ENV{'DCL$PATH;' . $i++}) { push(@dirs,$dir); }
      return @dirs;
  }
  
  =item file_name_is_absolute (override)
  
  Checks for VMS directory spec as well as Unix separators.
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      # If it's a logical name, expand it.
      $file = $ENV{$file} while $file =~ /^[\w\$\-]+\Z(?!\n)/s && $ENV{$file};
      return scalar($file =~ m!^/!s             ||
  		  $file =~ m![<\[][^.\-\]>]!  ||
  		  $file =~ /^[A-Za-z0-9_\$\-\~]+(?<!\^):/);
  }
  
  =item splitpath (override)
  
     ($volume,$directories,$file) = File::Spec->splitpath( $path );
     ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                           $no_file );
  
  Passing a true value for C<$no_file> indicates that the path being
  split only contains directory components, even on systems where you
  can usually (when not supporting a foreign syntax) tell the difference
  between directories and files at a glance.
  
  =cut
  
  sub splitpath {
      my($self,$path, $nofile) = @_;
      my($dev,$dir,$file)      = ('','','');
      my $vmsify_path = vmsify($path);
  
      if ( $nofile ) {
          #vmsify('d1/d2/d3') returns '[.d1.d2]d3'
          #vmsify('/d1/d2/d3') returns 'd1:[d2]d3'
          if( $vmsify_path =~ /(.*)\](.+)/ ){
              $vmsify_path = $1.'.'.$2.']';
          }
          $vmsify_path =~ /(.+:)?(.*)/s;
          $dir = defined $2 ? $2 : ''; # dir can be '0'
          return ($1 || '',$dir,$file);
      }
      else {
          $vmsify_path =~ /(.+:)?([\[<].*[\]>])?(.*)/s;
          return ($1 || '',$2 || '',$3);
      }
  }
  
  =item splitdir (override)
  
  Split a directory specification into the components.
  
  =cut
  
  sub splitdir {
      my($self,$dirspec) = @_;
      my @dirs = ();
      return @dirs if ( (!defined $dirspec) || ('' eq $dirspec) );
  
      $dirspec =~ s/(?<!\^)</[/;                  # < and >	==> [ and ]
      $dirspec =~ s/(?<!\^)>/]/;
      $dirspec =~ s/(?<!\^)\]\[\./\.\]\[/g;	# ][.		==> .][
      $dirspec =~ s/(?<!\^)\[000000\.\]\[/\[/g;	# [000000.][	==> [
      $dirspec =~ s/(?<!\^)\[000000\./\[/g;	# [000000.	==> [
      $dirspec =~ s/(?<!\^)\.\]\[000000\]/\]/g;	# .][000000]	==> ]
      $dirspec =~ s/(?<!\^)\.\]\[/\./g;		# foo.][bar	==> foo.bar
      while ($dirspec =~ s/(^|[\[\<\.])\-(\-+)($|[\]\>\.])/$1-.$2$3/g) {}
  						# That loop does the following
  						# with any amount of dashes:
  						# .--.		==> .-.-.
  						# [--.		==> [-.-.
  						# .--]		==> .-.-]
  						# [--]		==> [-.-]
      $dirspec = "[$dirspec]" unless $dirspec =~ /(?<!\^)[\[<]/; # make legal
      $dirspec =~ s/^(\[|<)\./$1/;
      @dirs = split /(?<!\^)\./, vmspath($dirspec);
      $dirs[0] =~ s/^[\[<]//s;  $dirs[-1] =~ s/[\]>]\Z(?!\n)//s;
      @dirs;
  }
  
  
  =item catpath (override)
  
  Construct a complete filespec.
  
  =cut
  
  sub catpath {
      my($self,$dev,$dir,$file) = @_;
      
      # We look for a volume in $dev, then in $dir, but not both
      my ($dir_volume, $dir_dir, $dir_file) = $self->splitpath($dir);
      $dev = $dir_volume unless length $dev;
      $dir = length $dir_file ? $self->catfile($dir_dir, $dir_file) : $dir_dir;
      
      if ($dev =~ m|^(?<!\^)/+([^/]+)|) { $dev = "$1:"; }
      else { $dev .= ':' unless $dev eq '' or $dev =~ /:\Z(?!\n)/; }
      if (length($dev) or length($dir)) {
          $dir = "[$dir]" unless $dir =~ /(?<!\^)[\[<\/]/;
          $dir = vmspath($dir);
      }
      $dir = '' if length($dev) && ($dir eq '[]' || $dir eq '<>');
      "$dev$dir$file";
  }
  
  =item abs2rel (override)
  
  Attempt to convert an absolute file specification to a relative specification.
  
  =cut
  
  sub abs2rel {
      my $self = shift;
      my($path,$base) = @_;
  
      $base = Cwd::getcwd() unless defined $base and length $base;
  
      # If there is no device or directory syntax on $base, make sure it
      # is treated as a directory.
      $base = vmspath($base) unless $base =~ m{(?<!\^)[\[<:]};
  
      for ($path, $base) { $_ = $self->rel2abs($_) }
  
      # Are we even starting $path on the same (node::)device as $base?  Note that
      # logical paths or nodename differences may be on the "same device" 
      # but the comparison that ignores device differences so as to concatenate 
      # [---] up directory specs is not even a good idea in cases where there is 
      # a logical path difference between $path and $base nodename and/or device.
      # Hence we fall back to returning the absolute $path spec
      # if there is a case blind device (or node) difference of any sort
      # and we do not even try to call $parse() or consult %ENV for $trnlnm()
      # (this module needs to run on non VMS platforms after all).
      
      my ($path_volume, $path_directories, $path_file) = $self->splitpath($path);
      my ($base_volume, $base_directories, $base_file) = $self->splitpath($base);
      return $self->canonpath( $path ) unless lc($path_volume) eq lc($base_volume);
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my $pathchunks = @pathchunks;
      unshift(@pathchunks,'000000') unless $pathchunks[0] eq '000000';
      my @basechunks = $self->splitdir( $base_directories );
      my $basechunks = @basechunks;
      unshift(@basechunks,'000000') unless $basechunks[0] eq '000000';
  
      while ( @pathchunks && 
              @basechunks && 
              lc( $pathchunks[0] ) eq lc( $basechunks[0] ) 
            ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # @basechunks now contains the directories to climb out of,
      # @pathchunks now has the directories to descend in to.
      if ((@basechunks > 0) || ($basechunks != $pathchunks)) {
        $path_directories = join '.', ('-' x @basechunks, @pathchunks) ;
      }
      else {
        $path_directories = join '.', @pathchunks;
      }
      $path_directories = '['.$path_directories.']';
      return $self->canonpath( $self->catpath( '', $path_directories, $path_file ) ) ;
  }
  
  
  =item rel2abs (override)
  
  Return an absolute file specification from a relative one.
  
  =cut
  
  sub rel2abs {
      my $self = shift ;
      my ($path,$base ) = @_;
      return undef unless defined $path;
      if ($path =~ m/\//) {
         $path = ( -d $path || $path =~ m/\/\z/  # educated guessing about
                    ? vmspath($path)             # whether it's a directory
                    : vmsify($path) );
      }
      $base = vmspath($base) if defined $base && $base =~ m/\//;
  
      # Clean up and split up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
              $base = Cwd::getcwd();
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          # Split up paths
          my ( $path_directories, $path_file ) =
              ($self->splitpath( $path ))[1,2] ;
  
          my ( $base_volume, $base_directories ) =
              $self->splitpath( $base ) ;
  
          $path_directories = '' if $path_directories eq '[]' ||
                                    $path_directories eq '<>';
          my $sep = '' ;
          $sep = '.'
              if ( $base_directories =~ m{[^.\]>]\Z(?!\n)} &&
                   $path_directories =~ m{^[^.\[<]}s
              ) ;
          $base_directories = "$base_directories$sep$path_directories";
          $base_directories =~ s{\.?[\]>][\[<]\.?}{.};
  
          $path = $self->catpath( $base_volume, $base_directories, $path_file );
     }
  
      return $self->canonpath( $path ) ;
  }
  
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004-14 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  An explanation of VMS file specs can be found at
  L<http://h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_files>.
  
  =cut
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_FILE_SPEC_VMS

$fatpacked{"x86_64-linux-gnu-thread-multi/File/Spec/Win32.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_FILE_SPEC_WIN32';
  package File::Spec::Win32;
  
  use strict;
  
  use Cwd ();
  require File::Spec::Unix;
  
  our $VERSION = '3.75';
  $VERSION =~ tr/_//d;
  
  our @ISA = qw(File::Spec::Unix);
  
  # Some regexes we use for path splitting
  my $DRIVE_RX = '[a-zA-Z]:';
  my $UNC_RX = '(?:\\\\\\\\|//)[^\\\\/]+[\\\\/][^\\\\/]+';
  my $VOL_RX = "(?:$DRIVE_RX|$UNC_RX)";
  
  
  =head1 NAME
  
  File::Spec::Win32 - methods for Win32 file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Win32; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  =over 4
  
  =item devnull
  
  Returns a string representation of the null device.
  
  =cut
  
  sub devnull {
      return "nul";
  }
  
  sub rootdir { '\\' }
  
  
  =item tmpdir
  
  Returns a string representation of the first existing directory
  from the following list:
  
      $ENV{TMPDIR}
      $ENV{TEMP}
      $ENV{TMP}
      SYS:/temp
      C:\system\temp
      C:/temp
      /tmp
      /
  
  The SYS:/temp is preferred in Novell NetWare and the C:\system\temp
  for Symbian (the File::Spec::Win32 is used also for those platforms).
  
  If running under taint mode, and if the environment
  variables are tainted, they are not used.
  
  =cut
  
  sub tmpdir {
      my $tmpdir = $_[0]->_cached_tmpdir(qw(TMPDIR TEMP TMP));
      return $tmpdir if defined $tmpdir;
      $tmpdir = $_[0]->_tmpdir( map( $ENV{$_}, qw(TMPDIR TEMP TMP) ),
  			      'SYS:/temp',
  			      'C:\system\temp',
  			      'C:/temp',
  			      '/tmp',
  			      '/'  );
      $_[0]->_cache_tmpdir($tmpdir, qw(TMPDIR TEMP TMP));
  }
  
  =item case_tolerant
  
  MSWin32 case-tolerance depends on GetVolumeInformation() $ouFsFlags == FS_CASE_SENSITIVE,
  indicating the case significance when comparing file specifications.
  Since XP FS_CASE_SENSITIVE is effectively disabled for the NT subsubsystem.
  See http://cygwin.com/ml/cygwin/2007-07/msg00891.html
  Default: 1
  
  =cut
  
  sub case_tolerant {
    eval {
      local @INC = @INC;
      pop @INC if $INC[-1] eq '.';
      require Win32API::File;
    } or return 1;
    my $drive = shift || "C:";
    my $osFsType = "\0"x256;
    my $osVolName = "\0"x256;
    my $ouFsFlags = 0;
    Win32API::File::GetVolumeInformation($drive, $osVolName, 256, [], [], $ouFsFlags, $osFsType, 256 );
    if ($ouFsFlags & Win32API::File::FS_CASE_SENSITIVE()) { return 0; }
    else { return 1; }
  }
  
  =item file_name_is_absolute
  
  As of right now, this returns 2 if the path is absolute with a
  volume, 1 if it's absolute with no volume, 0 otherwise.
  
  =cut
  
  sub file_name_is_absolute {
  
      my ($self,$file) = @_;
  
      if ($file =~ m{^($VOL_RX)}o) {
        my $vol = $1;
        return ($vol =~ m{^$UNC_RX}o ? 2
  	      : $file =~ m{^$DRIVE_RX[\\/]}o ? 2
  	      : 0);
      }
      return $file =~  m{^[\\/]} ? 1 : 0;
  }
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
  =cut
  
  sub catfile {
      shift;
  
      # Legacy / compatibility support
      #
      shift, return _canon_cat( "/", @_ )
  	if $_[0] eq "";
  
      # Compatibility with File::Spec <= 3.26:
      #     catfile('A:', 'foo') should return 'A:\foo'.
      return _canon_cat( ($_[0].'\\'), @_[1..$#_] )
          if $_[0] =~ m{^$DRIVE_RX\z}o;
  
      return _canon_cat( @_ );
  }
  
  sub catdir {
      shift;
  
      # Legacy / compatibility support
      #
      return ""
      	unless @_;
      shift, return _canon_cat( "/", @_ )
  	if $_[0] eq "";
  
      # Compatibility with File::Spec <= 3.26:
      #     catdir('A:', 'foo') should return 'A:\foo'.
      return _canon_cat( ($_[0].'\\'), @_[1..$#_] )
          if $_[0] =~ m{^$DRIVE_RX\z}o;
  
      return _canon_cat( @_ );
  }
  
  sub path {
      my @path = split(';', $ENV{PATH});
      s/"//g for @path;
      @path = grep length, @path;
      unshift(@path, ".");
      return @path;
  }
  
  =item canonpath
  
  No physical check on the filesystem, but a logical cleanup of a
  path. On UNIX eliminated successive slashes and successive "/.".
  On Win32 makes 
  
  	dir1\dir2\dir3\..\..\dir4 -> \dir\dir4 and even
  	dir1\dir2\dir3\...\dir4   -> \dir\dir4
  
  =cut
  
  sub canonpath {
      # Legacy / compatibility support
      #
      return $_[1] if !defined($_[1]) or $_[1] eq '';
      return _canon_cat( $_[1] );
  }
  
  =item splitpath
  
     ($volume,$directories,$file) = File::Spec->splitpath( $path );
     ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                           $no_file );
  
  Splits a path into volume, directory, and filename portions. Assumes that 
  the last file is a path unless the path ends in '\\', '\\.', '\\..'
  or $no_file is true.  On Win32 this means that $no_file true makes this return 
  ( $volume, $path, '' ).
  
  Separators accepted are \ and /.
  
  Volumes can be drive letters or UNC sharenames (\\server\share).
  
  The results can be passed to L</catpath> to get back a path equivalent to
  (usually identical to) the original path.
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file) = ('','','');
      if ( $nofile ) {
          $path =~ 
              m{^ ( $VOL_RX ? ) (.*) }sox;
          $volume    = $1;
          $directory = $2;
      }
      else {
          $path =~ 
              m{^ ( $VOL_RX ? )
                  ( (?:.*[\\/](?:\.\.?\Z(?!\n))?)? )
                  (.*)
               }sox;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of L<catdir()|File::Spec/catdir>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, leading empty and 
  trailing directory entries can be returned, because these are significant
  on some OSs. So,
  
      File::Spec->splitdir( "/a/b/c" );
  
  Yields:
  
      ( '', 'a', 'b', '', 'c', '' )
  
  =cut
  
  sub splitdir {
      my ($self,$directories) = @_ ;
      #
      # split() likes to forget about trailing null fields, so here we
      # check to be sure that there will not be any before handling the
      # simple case.
      #
      if ( $directories !~ m|[\\/]\Z(?!\n)| ) {
          return split( m|[\\/]|, $directories );
      }
      else {
          #
          # since there was a trailing separator, add a file name to the end, 
          # then do the split, then replace it with ''.
          #
          my( @directories )= split( m|[\\/]|, "${directories}dummy" ) ;
          $directories[ $#directories ]= '' ;
          return @directories ;
      }
  }
  
  
  =item catpath
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, $volume is ignored, and this is just like catfile(). On other OSs,
  the $volume become significant.
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      # If it's UNC, make sure the glue separator is there, reusing
      # whatever separator is first in the $volume
      my $v;
      $volume .= $v
          if ( (($v) = $volume =~ m@^([\\/])[\\/][^\\/]+[\\/][^\\/]+\Z(?!\n)@s) &&
               $directory =~ m@^[^\\/]@s
             ) ;
  
      $volume .= $directory ;
  
      # If the volume is not just A:, make sure the glue separator is 
      # there, reusing whatever separator is first in the $volume if possible.
      if ( $volume !~ m@^[a-zA-Z]:\Z(?!\n)@s &&
           $volume =~ m@[^\\/]\Z(?!\n)@      &&
           $file   =~ m@[^\\/]@
         ) {
          $volume =~ m@([\\/])@ ;
          my $sep = $1 ? $1 : '\\' ;
          $volume .= $sep ;
      }
  
      $volume .= $file ;
  
      return $volume ;
  }
  
  sub _same {
    lc($_[1]) eq lc($_[2]);
  }
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      my $is_abs = $self->file_name_is_absolute($path);
  
      # Check for volume (should probably document the '2' thing...)
      return $self->canonpath( $path ) if $is_abs == 2;
  
      if ($is_abs) {
        # It's missing a volume, add one
        my $vol = ($self->splitpath( Cwd::getcwd() ))[0];
        return $self->canonpath( $vol . $path );
      }
  
      if ( !defined( $base ) || $base eq '' ) {
        $base = Cwd::getdcwd( ($self->splitpath( $path ))[0] ) if defined &Cwd::getdcwd ;
        $base = Cwd::getcwd() unless defined $base ;
      }
      elsif ( ! $self->file_name_is_absolute( $base ) ) {
        $base = $self->rel2abs( $base ) ;
      }
      else {
        $base = $self->canonpath( $base ) ;
      }
  
      my ( $path_directories, $path_file ) =
        ($self->splitpath( $path, 1 ))[1,2] ;
  
      my ( $base_volume, $base_directories ) =
        $self->splitpath( $base, 1 ) ;
  
      $path = $self->catpath( 
  			   $base_volume, 
  			   $self->catdir( $base_directories, $path_directories ), 
  			   $path_file
  			  ) ;
  
      return $self->canonpath( $path ) ;
  }
  
  =back
  
  =head2 Note For File::Spec::Win32 Maintainers
  
  Novell NetWare inherits its File::Spec behaviour from File::Spec::Win32.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004,2007 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  
  sub _canon_cat				# @path -> path
  {
      my ($first, @rest) = @_;
  
      my $volume = $first =~ s{ \A ([A-Za-z]:) ([\\/]?) }{}x	# drive letter
      	       ? ucfirst( $1 ).( $2 ? "\\" : "" )
  	       : $first =~ s{ \A (?:\\\\|//) ([^\\/]+)
  				 (?: [\\/] ([^\\/]+) )?
  	       			 [\\/]? }{}xs			# UNC volume
  	       ? "\\\\$1".( defined $2 ? "\\$2" : "" )."\\"
  	       : $first =~ s{ \A [\\/] }{}x			# root dir
  	       ? "\\"
  	       : "";
      my $path   = join "\\", $first, @rest;
  
      $path =~ tr#\\/#\\\\#s;		# xx/yy --> xx\yy & xx\\yy --> xx\yy
  
      					# xx/././yy --> xx/yy
      $path =~ s{(?:
  		(?:\A|\\)		# at begin or after a slash
  		\.
  		(?:\\\.)*		# and more
  		(?:\\|\z) 		# at end or followed by slash
  	       )+			# performance boost -- I do not know why
  	     }{\\}gx;
  
      # XXX I do not know whether more dots are supported by the OS supporting
      #     this ... annotation (NetWare or symbian but not MSWin32).
      #     Then .... could easily become ../../.. etc:
      # Replace \.\.\. by (\.\.\.+)  and substitute with
      # { $1 . ".." . "\\.." x (length($2)-2) }gex
  	     				# ... --> ../..
      $path =~ s{ (\A|\\)			# at begin or after a slash
      		\.\.\.
  		(?=\\|\z) 		# at end or followed by slash
  	     }{$1..\\..}gx;
      					# xx\yy\..\zz --> xx\zz
      while ( $path =~ s{(?:
  		(?:\A|\\)		# at begin or after a slash
  		[^\\]+			# rip this 'yy' off
  		\\\.\.
  		(?<!\A\.\.\\\.\.)	# do *not* replace ^..\..
  		(?<!\\\.\.\\\.\.)	# do *not* replace \..\..
  		(?:\\|\z) 		# at end or followed by slash
  	       )+			# performance boost -- I do not know why
  	     }{\\}sx ) {}
  
      $path =~ s#\A\\##;			# \xx --> xx  NOTE: this is *not* root
      $path =~ s#\\\z##;			# xx\ --> xx
  
      if ( $volume =~ m#\\\z# )
      {					# <vol>\.. --> <vol>\
  	$path =~ s{ \A			# at begin
  		    \.\.
  		    (?:\\\.\.)*		# and more
  		    (?:\\|\z) 		# at end or followed by slash
  		 }{}x;
  
  	return $1			# \\HOST\SHARE\ --> \\HOST\SHARE
  	    if    $path eq ""
  	      and $volume =~ m#\A(\\\\.*)\\\z#s;
      }
      return $path ne "" || $volume ? $volume.$path : ".";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_FILE_SPEC_WIN32

$fatpacked{"x86_64-linux-gnu-thread-multi/IO.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_IO';
  #
  
  package IO;
  
  use XSLoader ();
  use Carp;
  use strict;
  use warnings;
  
  our $VERSION = "1.50";
  XSLoader::load 'IO', $VERSION;
  
  sub import {
      shift;
  
      warnings::warnif('deprecated', qq{Parameterless "use IO" deprecated})
          if @_ == 0 ;
      
      my @l = @_ ? @_ : qw(Handle Seekable File Pipe Socket Dir);
  
      local @INC = @INC;
      pop @INC if $INC[-1] eq '.';
      eval join("", map { "require IO::" . (/(\w+)/)[0] . ";\n" } @l)
  	or croak $@;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  IO - load various IO modules
  
  =head1 SYNOPSIS
  
     use IO qw(Handle File); # loads IO modules, here IO::Handle, IO::File
     use IO;                 # DEPRECATED
  
  =head1 DESCRIPTION
  
  C<IO> provides a simple mechanism to load several of the IO modules
  in one go.  The IO modules belonging to the core are:
  
        IO::Handle
        IO::Seekable
        IO::File
        IO::Pipe
        IO::Socket
        IO::Dir
        IO::Select
        IO::Poll
  
  Some other IO modules don't belong to the perl core but can be loaded
  as well if they have been installed from CPAN.  You can discover which
  ones exist with this query:  L<https://metacpan.org/search?q=IO%3A%3A>.
  
  For more information on any of these modules, please see its respective
  documentation.
  
  =head1 DEPRECATED
  
      use IO;                # loads all the modules listed below
  
  The loaded modules are IO::Handle, IO::Seekable, IO::File, IO::Pipe,
  IO::Socket, IO::Dir.  You should instead explicitly import the IO
  modules you want.
  
  =cut
  
X86_64-LINUX-GNU-THREAD-MULTI_IO

$fatpacked{"x86_64-linux-gnu-thread-multi/IO/Dir.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_IO_DIR';
  # IO::Dir.pm
  #
  # Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package IO::Dir;
  
  use 5.008_001;
  
  use strict;
  use Carp;
  use Symbol;
  use Exporter;
  use IO::File;
  use Tie::Hash;
  use File::stat;
  use File::Spec;
  
  our @ISA = qw(Tie::Hash Exporter);
  our $VERSION = "1.49";
  
  our @EXPORT_OK = qw(DIR_UNLINK);
  
  sub DIR_UNLINK () { 1 }
  
  sub new {
      @_ >= 1 && @_ <= 2 or croak 'usage: IO::Dir->new([DIRNAME])';
      my $class = shift;
      my $dh = gensym;
      if (@_) {
  	IO::Dir::open($dh, $_[0])
  	    or return undef;
      }
      bless $dh, $class;
  }
  
  sub DESTROY {
      my ($dh) = @_;
      local($., $@, $!, $^E, $?);
      no warnings 'io';
      closedir($dh);
  }
  
  sub open {
      @_ == 2 or croak 'usage: $dh->open(DIRNAME)';
      my ($dh, $dirname) = @_;
      return undef
  	unless opendir($dh, $dirname);
      # a dir name should always have a ":" in it; assume dirname is
      # in current directory
      $dirname = ':' .  $dirname if ( ($^O eq 'MacOS') && ($dirname !~ /:/) );
      ${*$dh}{io_dir_path} = $dirname;
      1;
  }
  
  sub close {
      @_ == 1 or croak 'usage: $dh->close()';
      my ($dh) = @_;
      closedir($dh);
  }
  
  sub read {
      @_ == 1 or croak 'usage: $dh->read()';
      my ($dh) = @_;
      readdir($dh);
  }
  
  sub seek {
      @_ == 2 or croak 'usage: $dh->seek(POS)';
      my ($dh,$pos) = @_;
      seekdir($dh,$pos);
  }
  
  sub tell {
      @_ == 1 or croak 'usage: $dh->tell()';
      my ($dh) = @_;
      telldir($dh);
  }
  
  sub rewind {
      @_ == 1 or croak 'usage: $dh->rewind()';
      my ($dh) = @_;
      rewinddir($dh);
  }
  
  sub TIEHASH {
      my($class,$dir,$options) = @_;
  
      my $dh = $class->new($dir)
  	or return undef;
  
      $options ||= 0;
  
      ${*$dh}{io_dir_unlink} = $options & DIR_UNLINK;
      $dh;
  }
  
  sub FIRSTKEY {
      my($dh) = @_;
      $dh->rewind;
      scalar $dh->read;
  }
  
  sub NEXTKEY {
      my($dh) = @_;
      scalar $dh->read;
  }
  
  sub EXISTS {
      my($dh,$key) = @_;
      -e File::Spec->catfile(${*$dh}{io_dir_path}, $key);
  }
  
  sub FETCH {
      my($dh,$key) = @_;
      &lstat(File::Spec->catfile(${*$dh}{io_dir_path}, $key));
  }
  
  sub STORE {
      my($dh,$key,$data) = @_;
      my($atime,$mtime) = ref($data) ? @$data : ($data,$data);
      my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);
      unless(-e $file) {
  	my $io = IO::File->new($file,O_CREAT | O_RDWR);
  	$io->close if $io;
      }
      utime($atime,$mtime, $file);
  }
  
  sub DELETE {
      my($dh,$key) = @_;
  
      # Only unlink if unlink-ing is enabled
      return 0
  	unless ${*$dh}{io_dir_unlink};
  
      my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);
  
      -d $file
  	? rmdir($file)
  	: unlink($file);
  }
  
  1;
  
  __END__
  
  =head1 NAME 
  
  IO::Dir - supply object methods for directory handles
  
  =head1 SYNOPSIS
  
      use IO::Dir;
      $d = IO::Dir->new(".");
      if (defined $d) {
          while (defined($_ = $d->read)) { something($_); }
          $d->rewind;
          while (defined($_ = $d->read)) { something_else($_); }
          undef $d;
      }
  
      tie %dir, 'IO::Dir', ".";
      foreach (keys %dir) {
  	print $_, " " , $dir{$_}->size,"\n";
      }
  
  =head1 DESCRIPTION
  
  The C<IO::Dir> package provides two interfaces to perl's directory reading
  routines.
  
  The first interface is an object approach. C<IO::Dir> provides an object
  constructor and methods, which are just wrappers around perl's built in
  directory reading routines.
  
  =over 4
  
  =item new ( [ DIRNAME ] )
  
  C<new> is the constructor for C<IO::Dir> objects. It accepts one optional
  argument which,  if given, C<new> will pass to C<open>
  
  =back
  
  The following methods are wrappers for the directory related functions built
  into perl (the trailing 'dir' has been removed from the names). See L<perlfunc>
  for details of these functions.
  
  =over 4
  
  =item open ( DIRNAME )
  
  =item read ()
  
  =item seek ( POS )
  
  =item tell ()
  
  =item rewind ()
  
  =item close ()
  
  =back
  
  C<IO::Dir> also provides an interface to reading directories via a tied
  hash. The tied hash extends the interface beyond just the directory
  reading routines by the use of C<lstat>, from the C<File::stat> package,
  C<unlink>, C<rmdir> and C<utime>.
  
  =over 4
  
  =item tie %hash, 'IO::Dir', DIRNAME [, OPTIONS ]
  
  =back
  
  The keys of the hash will be the names of the entries in the directory. 
  Reading a value from the hash will be the result of calling
  C<File::stat::lstat>.  Deleting an element from the hash will 
  delete the corresponding file or subdirectory,
  provided that C<DIR_UNLINK> is included in the C<OPTIONS>.
  
  Assigning to an entry in the hash will cause the time stamps of the file
  to be modified. If the file does not exist then it will be created. Assigning
  a single integer to a hash element will cause both the access and 
  modification times to be changed to that value. Alternatively a reference to
  an array of two values can be passed. The first array element will be used to
  set the access time and the second element will be used to set the modification
  time.
  
  =head1 SEE ALSO
  
  L<File::stat>
  
  =head1 AUTHOR
  
  Graham Barr. Currently maintained by the Perl Porters.  Please report all
  bugs at L<https://github.com/Perl/perl5/issues>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2003 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_IO_DIR

$fatpacked{"x86_64-linux-gnu-thread-multi/IO/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_IO_FILE';
  #
  
  package IO::File;
  
  =head1 NAME
  
  IO::File - supply object methods for filehandles
  
  =head1 SYNOPSIS
  
      use IO::File;
  
      $fh = IO::File->new();
      if ($fh->open("< file")) {
          print <$fh>;
          $fh->close;
      }
  
      $fh = IO::File->new("> file");
      if (defined $fh) {
          print $fh "bar\n";
          $fh->close;
      }
  
      $fh = IO::File->new("file", "r");
      if (defined $fh) {
          print <$fh>;
          undef $fh;       # automatically closes the file
      }
  
      $fh = IO::File->new("file", O_WRONLY|O_APPEND);
      if (defined $fh) {
          print $fh "corge\n";
  
          $pos = $fh->getpos;
          $fh->setpos($pos);
  
          undef $fh;       # automatically closes the file
      }
  
      autoflush STDOUT 1;
  
  =head1 DESCRIPTION
  
  C<IO::File> inherits from C<IO::Handle> and C<IO::Seekable>. It extends
  these classes with methods that are specific to file handles.
  
  =head1 CONSTRUCTOR
  
  =over 4
  
  =item new ( FILENAME [,MODE [,PERMS]] )
  
  Creates an C<IO::File>.  If it receives any parameters, they are passed to
  the method C<open>; if the open fails, the object is destroyed.  Otherwise,
  it is returned to the caller.
  
  =item new_tmpfile
  
  Creates an C<IO::File> opened for read/write on a newly created temporary
  file.  On systems where this is possible, the temporary file is anonymous
  (i.e. it is unlinked after creation, but held open).  If the temporary
  file cannot be created or opened, the C<IO::File> object is destroyed.
  Otherwise, it is returned to the caller.
  
  =back
  
  =head1 METHODS
  
  =over 4
  
  =item open( FILENAME [,MODE [,PERMS]] )
  
  =item open( FILENAME, IOLAYERS )
  
  C<open> accepts one, two or three parameters.  With one parameter,
  it is just a front end for the built-in C<open> function.  With two or three
  parameters, the first parameter is a filename that may include
  whitespace or other special characters, and the second parameter is
  the open mode, optionally followed by a file permission value.
  
  If C<IO::File::open> receives a Perl mode string ("E<gt>", "+E<lt>", etc.)
  or an ANSI C fopen() mode string ("w", "r+", etc.), it uses the basic
  Perl C<open> operator (but protects any special characters).
  
  If C<IO::File::open> is given a numeric mode, it passes that mode
  and the optional permissions value to the Perl C<sysopen> operator.
  The permissions default to 0666.
  
  If C<IO::File::open> is given a mode that includes the C<:> character,
  it passes all the three arguments to the three-argument C<open> operator.
  
  For convenience, C<IO::File> exports the O_XXX constants from the
  Fcntl module, if this module is available.
  
  =item binmode( [LAYER] )
  
  C<binmode> sets C<binmode> on the underlying C<IO> object, as documented
  in C<perldoc -f binmode>.
  
  C<binmode> accepts one optional parameter, which is the layer to be
  passed on to the C<binmode> call.
  
  =back
  
  =head1 NOTE
  
  Some operating systems may perform  C<IO::File::new()> or C<IO::File::open()>
  on a directory without errors.  This behavior is not portable and not
  suggested for use.  Using C<opendir()> and C<readdir()> or C<IO::Dir> are
  suggested instead.
  
  =head1 SEE ALSO
  
  L<perlfunc>, 
  L<perlop/"I/O Operators">,
  L<IO::Handle>,
  L<IO::Seekable>,
  L<IO::Dir>
  
  =head1 HISTORY
  
  Derived from FileHandle.pm by Graham Barr E<lt>F<gbarr@pobox.com>E<gt>.
  
  =cut
  
  use 5.008_001;
  use strict;
  use Carp;
  use Symbol;
  use SelectSaver;
  use IO::Seekable;
  
  require Exporter;
  
  our @ISA = qw(IO::Handle IO::Seekable Exporter);
  
  our $VERSION = "1.48";
  
  our @EXPORT = @IO::Seekable::EXPORT;
  
  eval {
      # Make all Fcntl O_XXX constants available for importing
      require Fcntl;
      my @O = grep /^O_/, @Fcntl::EXPORT;
      Fcntl->import(@O);  # first we import what we want to export
      push(@EXPORT, @O);
  };
  
  ################################################
  ## Constructor
  ##
  
  sub new {
      my $type = shift;
      my $class = ref($type) || $type || "IO::File";
      @_ >= 0 && @_ <= 3
  	or croak "usage: $class->new([FILENAME [,MODE [,PERMS]]])";
      my $fh = $class->SUPER::new();
      if (@_) {
  	$fh->open(@_)
  	    or return undef;
      }
      $fh;
  }
  
  ################################################
  ## Open
  ##
  
  sub open {
      @_ >= 2 && @_ <= 4 or croak 'usage: $fh->open(FILENAME [,MODE [,PERMS]])';
      my ($fh, $file) = @_;
      if (@_ > 2) {
  	my ($mode, $perms) = @_[2, 3];
  	if ($mode =~ /^\d+$/) {
  	    defined $perms or $perms = 0666;
  	    return sysopen($fh, $file, $mode, $perms);
  	} elsif ($mode =~ /:/) {
  	    return open($fh, $mode, $file) if @_ == 3;
  	    croak 'usage: $fh->open(FILENAME, IOLAYERS)';
  	} else {
              return open($fh, IO::Handle::_open_mode_string($mode), $file);
          }
      }
      open($fh, $file);
  }
  
  ################################################
  ## Binmode
  ##
  
  sub binmode {
      ( @_ == 1 or @_ == 2 ) or croak 'usage $fh->binmode([LAYER])';
  
      my($fh, $layer) = @_;
  
      return binmode $$fh unless $layer;
      return binmode $$fh, $layer;
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_IO_FILE

$fatpacked{"x86_64-linux-gnu-thread-multi/IO/Handle.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_IO_HANDLE';
  package IO::Handle;
  
  =head1 NAME
  
  IO::Handle - supply object methods for I/O handles
  
  =head1 SYNOPSIS
  
      use IO::Handle;
  
      $io = IO::Handle->new();
      if ($io->fdopen(fileno(STDIN),"r")) {
          print $io->getline;
          $io->close;
      }
  
      $io = IO::Handle->new();
      if ($io->fdopen(fileno(STDOUT),"w")) {
          $io->print("Some text\n");
      }
  
      # setvbuf is not available by default on Perls 5.8.0 and later.
      use IO::Handle '_IOLBF';
      $io->setvbuf($buffer_var, _IOLBF, 1024);
  
      undef $io;       # automatically closes the file if it's open
  
      autoflush STDOUT 1;
  
  =head1 DESCRIPTION
  
  C<IO::Handle> is the base class for all other IO handle classes. It is
  not intended that objects of C<IO::Handle> would be created directly,
  but instead C<IO::Handle> is inherited from by several other classes
  in the IO hierarchy.
  
  If you are reading this documentation, looking for a replacement for
  the C<FileHandle> package, then I suggest you read the documentation
  for C<IO::File> too.
  
  =head1 CONSTRUCTOR
  
  =over 4
  
  =item new ()
  
  Creates a new C<IO::Handle> object.
  
  =item new_from_fd ( FD, MODE )
  
  Creates an C<IO::Handle> like C<new> does.
  It requires two parameters, which are passed to the method C<fdopen>;
  if the fdopen fails, the object is destroyed. Otherwise, it is returned
  to the caller.
  
  =back
  
  =head1 METHODS
  
  See L<perlfunc> for complete descriptions of each of the following
  supported C<IO::Handle> methods, which are just front ends for the
  corresponding built-in functions:
  
      $io->close
      $io->eof
      $io->fcntl( FUNCTION, SCALAR )
      $io->fileno
      $io->format_write( [FORMAT_NAME] )
      $io->getc
      $io->ioctl( FUNCTION, SCALAR )
      $io->read ( BUF, LEN, [OFFSET] )
      $io->print ( ARGS )
      $io->printf ( FMT, [ARGS] )
      $io->say ( ARGS )
      $io->stat
      $io->sysread ( BUF, LEN, [OFFSET] )
      $io->syswrite ( BUF, [LEN, [OFFSET]] )
      $io->truncate ( LEN )
  
  See L<perlvar> for complete descriptions of each of the following
  supported C<IO::Handle> methods.  All of them return the previous
  value of the attribute and takes an optional single argument that when
  given will set the value.  If no argument is given the previous value
  is unchanged (except for $io->autoflush will actually turn ON
  autoflush by default).
  
      $io->autoflush ( [BOOL] )                         $|
      $io->format_page_number( [NUM] )                  $%
      $io->format_lines_per_page( [NUM] )               $=
      $io->format_lines_left( [NUM] )                   $-
      $io->format_name( [STR] )                         $~
      $io->format_top_name( [STR] )                     $^
      $io->input_line_number( [NUM])                    $.
  
  The following methods are not supported on a per-filehandle basis.
  
      IO::Handle->format_line_break_characters( [STR] ) $:
      IO::Handle->format_formfeed( [STR])               $^L
      IO::Handle->output_field_separator( [STR] )       $,
      IO::Handle->output_record_separator( [STR] )      $\
  
      IO::Handle->input_record_separator( [STR] )       $/
  
  Furthermore, for doing normal I/O you might need these:
  
  =over 4
  
  =item $io->fdopen ( FD, MODE )
  
  C<fdopen> is like an ordinary C<open> except that its first parameter
  is not a filename but rather a file handle name, an IO::Handle object,
  or a file descriptor number.  (For the documentation of the C<open>
  method, see L<IO::File>.)
  
  =item $io->opened
  
  Returns true if the object is currently a valid file descriptor, false
  otherwise.
  
  =item $io->getline
  
  This works like <$io> described in L<perlop/"I/O Operators">
  except that it's more readable and can be safely called in a
  list context but still returns just one line.  If used as the conditional
  within a C<while> or C-style C<for> loop, however, you will need to
  emulate the functionality of <$io> with C<< defined($_ = $io->getline) >>.
  
  =item $io->getlines
  
  This works like <$io> when called in a list context to read all
  the remaining lines in a file, except that it's more readable.
  It will also croak() if accidentally called in a scalar context.
  
  =item $io->ungetc ( ORD )
  
  Pushes a character with the given ordinal value back onto the given
  handle's input stream.  Only one character of pushback per handle is
  guaranteed.
  
  =item $io->write ( BUF, LEN [, OFFSET ] )
  
  This C<write> is somewhat like C<write> found in C, in that it is the
  opposite of read. The wrapper for the perl C<write> function is
  called C<format_write>. However, whilst the C C<write> function returns
  the number of bytes written, this C<write> function simply returns true
  if successful (like C<print>). A more C-like C<write> is C<syswrite>
  (see above).
  
  =item $io->error
  
  Returns a true value if the given handle has experienced any errors
  since it was opened or since the last call to C<clearerr>, or if the
  handle is invalid. It only returns false for a valid handle with no
  outstanding errors.
  
  =item $io->clearerr
  
  Clear the given handle's error indicator. Returns -1 if the handle is
  invalid, 0 otherwise.
  
  =item $io->sync
  
  C<sync> synchronizes a file's in-memory state  with  that  on the
  physical medium. C<sync> does not operate at the perlio api level, but
  operates on the file descriptor (similar to sysread, sysseek and
  systell). This means that any data held at the perlio api level will not
  be synchronized. To synchronize data that is buffered at the perlio api
  level you must use the flush method. C<sync> is not implemented on all
  platforms. Returns "0 but true" on success, C<undef> on error, C<undef>
  for an invalid handle. See L<fsync(3c)>.
  
  =item $io->flush
  
  C<flush> causes perl to flush any buffered data at the perlio api level.
  Any unread data in the buffer will be discarded, and any unwritten data
  will be written to the underlying file descriptor. Returns "0 but true"
  on success, C<undef> on error.
  
  =item $io->printflush ( ARGS )
  
  Turns on autoflush, print ARGS and then restores the autoflush status of the
  C<IO::Handle> object. Returns the return value from print.
  
  =item $io->blocking ( [ BOOL ] )
  
  If called with an argument C<blocking> will turn on non-blocking IO if
  C<BOOL> is false, and turn it off if C<BOOL> is true.
  
  C<blocking> will return the value of the previous setting, or the
  current setting if C<BOOL> is not given. 
  
  If an error occurs C<blocking> will return undef and C<$!> will be set.
  
  =back
  
  
  If the C functions setbuf() and/or setvbuf() are available, then
  C<IO::Handle::setbuf> and C<IO::Handle::setvbuf> set the buffering
  policy for an IO::Handle.  The calling sequences for the Perl functions
  are the same as their C counterparts--including the constants C<_IOFBF>,
  C<_IOLBF>, and C<_IONBF> for setvbuf()--except that the buffer parameter
  specifies a scalar variable to use as a buffer. You should only
  change the buffer before any I/O, or immediately after calling flush.
  
  WARNING: The IO::Handle::setvbuf() is not available by default on
  Perls 5.8.0 and later because setvbuf() is rather specific to using
  the stdio library, while Perl prefers the new perlio subsystem instead.
  
  WARNING: A variable used as a buffer by C<setbuf> or C<setvbuf> B<must not
  be modified> in any way until the IO::Handle is closed or C<setbuf> or
  C<setvbuf> is called again, or memory corruption may result! Remember that
  the order of global destruction is undefined, so even if your buffer
  variable remains in scope until program termination, it may be undefined
  before the file IO::Handle is closed. Note that you need to import the
  constants C<_IOFBF>, C<_IOLBF>, and C<_IONBF> explicitly. Like C, setbuf
  returns nothing. setvbuf returns "0 but true", on success, C<undef> on
  failure.
  
  Lastly, there is a special method for working under B<-T> and setuid/gid
  scripts:
  
  =over 4
  
  =item $io->untaint
  
  Marks the object as taint-clean, and as such data read from it will also
  be considered taint-clean. Note that this is a very trusting action to
  take, and appropriate consideration for the data source and potential
  vulnerability should be kept in mind. Returns 0 on success, -1 if setting
  the taint-clean flag failed. (eg invalid handle)
  
  =back
  
  =head1 NOTE
  
  An C<IO::Handle> object is a reference to a symbol/GLOB reference (see
  the C<Symbol> package).  Some modules that
  inherit from C<IO::Handle> may want to keep object related variables
  in the hash table part of the GLOB. In an attempt to prevent modules
  trampling on each other I propose the that any such module should prefix
  its variables with its own name separated by _'s. For example the IO::Socket
  module keeps a C<timeout> variable in 'io_socket_timeout'.
  
  =head1 SEE ALSO
  
  L<perlfunc>, 
  L<perlop/"I/O Operators">,
  L<IO::File>
  
  =head1 BUGS
  
  Due to backwards compatibility, all filehandles resemble objects
  of class C<IO::Handle>, or actually classes derived from that class.
  They actually aren't.  Which means you can't derive your own 
  class from C<IO::Handle> and inherit those methods.
  
  =head1 HISTORY
  
  Derived from FileHandle.pm by Graham Barr E<lt>F<gbarr@pobox.com>E<gt>
  
  =cut
  
  use 5.008_001;
  use strict;
  use Carp;
  use Symbol;
  use SelectSaver;
  use IO ();	# Load the XS module
  
  require Exporter;
  our @ISA = qw(Exporter);
  
  our $VERSION = "1.48";
  
  our @EXPORT_OK = qw(
      autoflush
      output_field_separator
      output_record_separator
      input_record_separator
      input_line_number
      format_page_number
      format_lines_per_page
      format_lines_left
      format_name
      format_top_name
      format_line_break_characters
      format_formfeed
      format_write
  
      print
      printf
      say
      getline
      getlines
  
      printflush
      flush
  
      SEEK_SET
      SEEK_CUR
      SEEK_END
      _IOFBF
      _IOLBF
      _IONBF
  );
  
  ################################################
  ## Constructors, destructors.
  ##
  
  sub new {
      my $class = ref($_[0]) || $_[0] || "IO::Handle";
      if (@_ != 1) {
  	# Since perl will automatically require IO::File if needed, but
  	# also initialises IO::File's @ISA as part of the core we must
  	# ensure IO::File is loaded if IO::Handle is. This avoids effect-
  	# ively "half-loading" IO::File.
  	if ($] > 5.013 && $class eq 'IO::File' && !$INC{"IO/File.pm"}) {
  	    require IO::File;
  	    shift;
  	    return IO::File::->new(@_);
  	}
  	croak "usage: $class->new()";
      }
      my $io = gensym;
      bless $io, $class;
  }
  
  sub new_from_fd {
      my $class = ref($_[0]) || $_[0] || "IO::Handle";
      @_ == 3 or croak "usage: $class->new_from_fd(FD, MODE)";
      my $io = gensym;
      shift;
      IO::Handle::fdopen($io, @_)
  	or return undef;
      bless $io, $class;
  }
  
  #
  # There is no need for DESTROY to do anything, because when the
  # last reference to an IO object is gone, Perl automatically
  # closes its associated files (if any).  However, to avoid any
  # attempts to autoload DESTROY, we here define it to do nothing.
  #
  sub DESTROY {}
  
  
  ################################################
  ## Open and close.
  ##
  
  sub _open_mode_string {
      my ($mode) = @_;
      $mode =~ /^\+?(<|>>?)$/
        or $mode =~ s/^r(\+?)$/$1</
        or $mode =~ s/^w(\+?)$/$1>/
        or $mode =~ s/^a(\+?)$/$1>>/
        or croak "IO::Handle: bad open mode: $mode";
      $mode;
  }
  
  sub fdopen {
      @_ == 3 or croak 'usage: $io->fdopen(FD, MODE)';
      my ($io, $fd, $mode) = @_;
      local(*GLOB);
  
      if (ref($fd) && "$fd" =~ /GLOB\(/o) {
  	# It's a glob reference; Alias it as we cannot get name of anon GLOBs
  	my $n = qualify(*GLOB);
  	*GLOB = *{*$fd};
  	$fd =  $n;
      } elsif ($fd =~ m#^\d+$#) {
  	# It's an FD number; prefix with "=".
  	$fd = "=$fd";
      }
  
      open($io, _open_mode_string($mode) . '&' . $fd)
  	? $io : undef;
  }
  
  sub close {
      @_ == 1 or croak 'usage: $io->close()';
      my($io) = @_;
  
      close($io);
  }
  
  ################################################
  ## Normal I/O functions.
  ##
  
  # flock
  # select
  
  sub opened {
      @_ == 1 or croak 'usage: $io->opened()';
      defined fileno($_[0]);
  }
  
  sub fileno {
      @_ == 1 or croak 'usage: $io->fileno()';
      fileno($_[0]);
  }
  
  sub getc {
      @_ == 1 or croak 'usage: $io->getc()';
      getc($_[0]);
  }
  
  sub eof {
      @_ == 1 or croak 'usage: $io->eof()';
      eof($_[0]);
  }
  
  sub print {
      @_ or croak 'usage: $io->print(ARGS)';
      my $this = shift;
      print $this @_;
  }
  
  sub printf {
      @_ >= 2 or croak 'usage: $io->printf(FMT,[ARGS])';
      my $this = shift;
      printf $this @_;
  }
  
  sub say {
      @_ or croak 'usage: $io->say(ARGS)';
      my $this = shift;
      local $\ = "\n";
      print $this @_;
  }
  
  sub truncate {
      @_ == 2 or croak 'usage: $io->truncate(LEN)';
      truncate($_[0], $_[1]);
  }
  
  sub read {
      @_ == 3 || @_ == 4 or croak 'usage: $io->read(BUF, LEN [, OFFSET])';
      read($_[0], $_[1], $_[2], $_[3] || 0);
  }
  
  sub sysread {
      @_ == 3 || @_ == 4 or croak 'usage: $io->sysread(BUF, LEN [, OFFSET])';
      sysread($_[0], $_[1], $_[2], $_[3] || 0);
  }
  
  sub write {
      @_ >= 2 && @_ <= 4 or croak 'usage: $io->write(BUF [, LEN [, OFFSET]])';
      local($\) = "";
      $_[2] = length($_[1]) unless defined $_[2];
      print { $_[0] } substr($_[1], $_[3] || 0, $_[2]);
  }
  
  sub syswrite {
      @_ >= 2 && @_ <= 4 or croak 'usage: $io->syswrite(BUF [, LEN [, OFFSET]])';
      if (defined($_[2])) {
  	syswrite($_[0], $_[1], $_[2], $_[3] || 0);
      } else {
  	syswrite($_[0], $_[1]);
      }
  }
  
  sub stat {
      @_ == 1 or croak 'usage: $io->stat()';
      stat($_[0]);
  }
  
  ################################################
  ## State modification functions.
  ##
  
  sub autoflush {
      my $old = SelectSaver->new(qualify($_[0], caller));
      my $prev = $|;
      $| = @_ > 1 ? $_[1] : 1;
      $prev;
  }
  
  sub output_field_separator {
      carp "output_field_separator is not supported on a per-handle basis"
  	if ref($_[0]);
      my $prev = $,;
      $, = $_[1] if @_ > 1;
      $prev;
  }
  
  sub output_record_separator {
      carp "output_record_separator is not supported on a per-handle basis"
  	if ref($_[0]);
      my $prev = $\;
      $\ = $_[1] if @_ > 1;
      $prev;
  }
  
  sub input_record_separator {
      carp "input_record_separator is not supported on a per-handle basis"
  	if ref($_[0]);
      my $prev = $/;
      $/ = $_[1] if @_ > 1;
      $prev;
  }
  
  sub input_line_number {
      local $.;
      () = tell qualify($_[0], caller) if ref($_[0]);
      my $prev = $.;
      $. = $_[1] if @_ > 1;
      $prev;
  }
  
  sub format_page_number {
      my $old;
      $old = SelectSaver->new(qualify($_[0], caller)) if ref($_[0]);
      my $prev = $%;
      $% = $_[1] if @_ > 1;
      $prev;
  }
  
  sub format_lines_per_page {
      my $old;
      $old = SelectSaver->new(qualify($_[0], caller)) if ref($_[0]);
      my $prev = $=;
      $= = $_[1] if @_ > 1;
      $prev;
  }
  
  sub format_lines_left {
      my $old;
      $old = SelectSaver->new(qualify($_[0], caller)) if ref($_[0]);
      my $prev = $-;
      $- = $_[1] if @_ > 1;
      $prev;
  }
  
  sub format_name {
      my $old;
      $old = SelectSaver->new(qualify($_[0], caller)) if ref($_[0]);
      my $prev = $~;
      $~ = qualify($_[1], caller) if @_ > 1;
      $prev;
  }
  
  sub format_top_name {
      my $old;
      $old = SelectSaver->new(qualify($_[0], caller)) if ref($_[0]);
      my $prev = $^;
      $^ = qualify($_[1], caller) if @_ > 1;
      $prev;
  }
  
  sub format_line_break_characters {
      carp "format_line_break_characters is not supported on a per-handle basis"
  	if ref($_[0]);
      my $prev = $:;
      $: = $_[1] if @_ > 1;
      $prev;
  }
  
  sub format_formfeed {
      carp "format_formfeed is not supported on a per-handle basis"
  	if ref($_[0]);
      my $prev = $^L;
      $^L = $_[1] if @_ > 1;
      $prev;
  }
  
  sub formline {
      my $io = shift;
      my $picture = shift;
      local($^A) = $^A;
      local($\) = "";
      formline($picture, @_);
      print $io $^A;
  }
  
  sub format_write {
      @_ < 3 || croak 'usage: $io->write( [FORMAT_NAME] )';
      if (@_ == 2) {
  	my ($io, $fmt) = @_;
  	my $oldfmt = $io->format_name(qualify($fmt,caller));
  	CORE::write($io);
  	$io->format_name($oldfmt);
      } else {
  	CORE::write($_[0]);
      }
  }
  
  sub fcntl {
      @_ == 3 || croak 'usage: $io->fcntl( OP, VALUE );';
      my ($io, $op) = @_;
      return fcntl($io, $op, $_[2]);
  }
  
  sub ioctl {
      @_ == 3 || croak 'usage: $io->ioctl( OP, VALUE );';
      my ($io, $op) = @_;
      return ioctl($io, $op, $_[2]);
  }
  
  # this sub is for compatibility with older releases of IO that used
  # a sub called constant to determine if a constant existed -- GMB
  #
  # The SEEK_* and _IO?BF constants were the only constants at that time
  # any new code should just check defined(&CONSTANT_NAME)
  
  sub constant {
      no strict 'refs';
      my $name = shift;
      (($name =~ /^(SEEK_(SET|CUR|END)|_IO[FLN]BF)$/) && defined &{$name})
  	? &{$name}() : undef;
  }
  
  
  # so that flush.pl can be deprecated
  
  sub printflush {
      my $io = shift;
      my $old;
      $old = SelectSaver->new(qualify($io, caller)) if ref($io);
      local $| = 1;
      if(ref($io)) {
          print $io @_;
      }
      else {
  	print @_;
      }
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_IO_HANDLE

$fatpacked{"x86_64-linux-gnu-thread-multi/IO/Pipe.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_IO_PIPE';
  # IO::Pipe.pm
  #
  # Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package IO::Pipe;
  
  use 5.008_001;
  
  use IO::Handle;
  use strict;
  use Carp;
  use Symbol;
  
  our $VERSION = "1.49";
  
  sub new {
      my $type = shift;
      my $class = ref($type) || $type || "IO::Pipe";
      @_ == 0 || @_ == 2 or croak "usage: $class->([READFH, WRITEFH])";
  
      my $me = bless gensym(), $class;
  
      my($readfh,$writefh) = @_ ? @_ : $me->handles;
  
      pipe($readfh, $writefh)
  	or return undef;
  
      @{*$me} = ($readfh, $writefh);
  
      $me;
  }
  
  sub handles {
      @_ == 1 or croak 'usage: $pipe->handles()';
      (IO::Pipe::End->new(), IO::Pipe::End->new());
  }
  
  my $do_spawn = $^O eq 'os2' || $^O eq 'MSWin32';
  
  sub _doit {
      my $me = shift;
      my $rw = shift;
  
      my $pid = $do_spawn ? 0 : fork();
  
      if($pid) { # Parent
          return $pid;
      }
      elsif(defined $pid) { # Child or spawn
          my $fh;
          my $io = $rw ? \*STDIN : \*STDOUT;
          my ($mode, $save) = $rw ? "r" : "w";
          if ($do_spawn) {
            require Fcntl;
            $save = IO::Handle->new_from_fd($io, $mode);
  	  my $handle = shift;
            # Close in child:
  	  unless ($^O eq 'MSWin32') {
              fcntl($handle, Fcntl::F_SETFD(), 1) or croak "fcntl: $!";
  	  }
            $fh = $rw ? ${*$me}[0] : ${*$me}[1];
          } else {
            shift;
            $fh = $rw ? $me->reader() : $me->writer(); # close the other end
          }
          bless $io, "IO::Handle";
          $io->fdopen($fh, $mode);
  	$fh->close;
  
          if ($do_spawn) {
            $pid = eval { system 1, @_ }; # 1 == P_NOWAIT
            my $err = $!;
      
            $io->fdopen($save, $mode);
            $save->close or croak "Cannot close $!";
            croak "IO::Pipe: Cannot spawn-NOWAIT: $err" if not $pid or $pid < 0;
            return $pid;
          } else {
            exec @_ or
              croak "IO::Pipe: Cannot exec: $!";
          }
      }
      else {
          croak "IO::Pipe: Cannot fork: $!";
      }
  
      # NOT Reached
  }
  
  sub reader {
      @_ >= 1 or croak 'usage: $pipe->reader( [SUB_COMMAND_ARGS] )';
      my $me = shift;
  
      return undef
  	unless(ref($me) || ref($me = $me->new));
  
      my $fh  = ${*$me}[0];
      my $pid;
      $pid = $me->_doit(0, $fh, @_)
          if(@_);
  
      close ${*$me}[1];
      bless $me, ref($fh);
      *$me = *$fh;          # Alias self to handle
      $me->fdopen($fh->fileno,"r")
  	unless defined($me->fileno);
      bless $fh;                  # Really wan't un-bless here
      ${*$me}{'io_pipe_pid'} = $pid
          if defined $pid;
  
      $me;
  }
  
  sub writer {
      @_ >= 1 or croak 'usage: $pipe->writer( [SUB_COMMAND_ARGS] )';
      my $me = shift;
  
      return undef
  	unless(ref($me) || ref($me = $me->new));
  
      my $fh  = ${*$me}[1];
      my $pid;
      $pid = $me->_doit(1, $fh, @_)
          if(@_);
  
      close ${*$me}[0];
      bless $me, ref($fh);
      *$me = *$fh;          # Alias self to handle
      $me->fdopen($fh->fileno,"w")
  	unless defined($me->fileno);
      bless $fh;                  # Really wan't un-bless here
      ${*$me}{'io_pipe_pid'} = $pid
          if defined $pid;
  
      $me;
  }
  
  package IO::Pipe::End;
  
  our(@ISA);
  
  @ISA = qw(IO::Handle);
  
  sub close {
      my $fh = shift;
      my $r = $fh->SUPER::close(@_);
  
      waitpid(${*$fh}{'io_pipe_pid'},0)
  	if(defined ${*$fh}{'io_pipe_pid'});
  
      $r;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  IO::Pipe - supply object methods for pipes
  
  =head1 SYNOPSIS
  
  	use IO::Pipe;
  
  	$pipe = IO::Pipe->new();
  
  	if($pid = fork()) { # Parent
  	    $pipe->reader();
  
  	    while(<$pipe>) {
  		...
  	    }
  
  	}
  	elsif(defined $pid) { # Child
  	    $pipe->writer();
  
  	    print $pipe ...
  	}
  
  	or
  
  	$pipe = IO::Pipe->new();
  
  	$pipe->reader(qw(ls -l));
  
  	while(<$pipe>) {
  	    ...
  	}
  
  =head1 DESCRIPTION
  
  C<IO::Pipe> provides an interface to creating pipes between
  processes.
  
  =head1 CONSTRUCTOR
  
  =over 4
  
  =item new ( [READER, WRITER] )
  
  Creates an C<IO::Pipe>, which is a reference to a newly created symbol
  (see the C<Symbol> package). C<IO::Pipe::new> optionally takes two
  arguments, which should be objects blessed into C<IO::Handle>, or a
  subclass thereof. These two objects will be used for the system call
  to C<pipe>. If no arguments are given then method C<handles> is called
  on the new C<IO::Pipe> object.
  
  These two handles are held in the array part of the GLOB until either
  C<reader> or C<writer> is called.
  
  =back
  
  =head1 METHODS
  
  =over 4
  
  =item reader ([ARGS])
  
  The object is re-blessed into a sub-class of C<IO::Handle>, and becomes a
  handle at the reading end of the pipe. If C<ARGS> are given then C<fork>
  is called and C<ARGS> are passed to exec.
  
  =item writer ([ARGS])
  
  The object is re-blessed into a sub-class of C<IO::Handle>, and becomes a
  handle at the writing end of the pipe. If C<ARGS> are given then C<fork>
  is called and C<ARGS> are passed to exec.
  
  =item handles ()
  
  This method is called during construction by C<IO::Pipe::new>
  on the newly created C<IO::Pipe> object. It returns an array of two objects
  blessed into C<IO::Pipe::End>, or a subclass thereof.
  
  =back
  
  =head1 SEE ALSO
  
  L<IO::Handle>
  
  =head1 AUTHOR
  
  Graham Barr. Currently maintained by the Perl Porters.  Please report all
  bugs at L<https://github.com/Perl/perl5/issues>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_IO_PIPE

$fatpacked{"x86_64-linux-gnu-thread-multi/IO/Poll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_IO_POLL';
  
  # IO::Poll.pm
  #
  # Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package IO::Poll;
  
  use strict;
  use IO::Handle;
  use Exporter ();
  
  our @ISA = qw(Exporter);
  our $VERSION = "1.49";
  
  our @EXPORT = qw( POLLIN
  	      POLLOUT
  	      POLLERR
  	      POLLHUP
  	      POLLNVAL
  	    );
  
  our @EXPORT_OK = qw(
   POLLPRI
   POLLRDNORM
   POLLWRNORM
   POLLRDBAND
   POLLWRBAND
   POLLNORM
  	       );
  
  # [0] maps fd's to requested masks
  # [1] maps fd's to returned  masks
  # [2] maps fd's to handles
  sub new {
      my $class = shift;
  
      my $self = bless [{},{},{}], $class;
  
      $self;
  }
  
  sub mask {
      my $self = shift;
      my $io = shift;
      my $fd = fileno($io);
      return unless defined $fd;
      if (@_) {
  	my $mask = shift;
  	if($mask) {
  	  $self->[0]{$fd}{$io} = $mask; # the error events are always returned
  	  $self->[1]{$fd}      = 0;     # output mask
  	  $self->[2]{$io}      = $io;   # remember handle
  	} else {
            delete $self->[0]{$fd}{$io};
            unless(%{$self->[0]{$fd}}) {
              # We no longer have any handles for this FD
              delete $self->[1]{$fd};
              delete $self->[0]{$fd};
            }
            delete $self->[2]{$io};
  	}
      }
      
      return unless exists $self->[0]{$fd} and exists $self->[0]{$fd}{$io};
  	return $self->[0]{$fd}{$io};
  }
  
  
  sub poll {
      my($self,$timeout) = @_;
  
      $self->[1] = {};
  
      my($fd,$mask,$iom);
      my @poll = ();
  
      while(($fd,$iom) = each %{$self->[0]}) {
  	$mask   = 0;
  	$mask  |= $_ for values(%$iom);
  	push(@poll,$fd => $mask);
      }
  
      my $ret = _poll(defined($timeout) ? $timeout * 1000 : -1,@poll);
  
      return $ret
  	unless $ret > 0;
  
      while(@poll) {
  	my($fd,$got) = splice(@poll,0,2);
  	$self->[1]{$fd} = $got if $got;
      }
  
      return $ret;  
  }
  
  sub events {
      my $self = shift;
      my $io = shift;
      my $fd = fileno($io);
      exists $self->[1]{$fd} and exists $self->[0]{$fd}{$io} 
                  ? $self->[1]{$fd} & ($self->[0]{$fd}{$io}|POLLHUP|POLLERR|POLLNVAL)
  	: 0;
  }
  
  sub remove {
      my $self = shift;
      my $io = shift;
      $self->mask($io,0);
  }
  
  sub handles {
      my $self = shift;
      return values %{$self->[2]} unless @_;
  
      my $events = shift || 0;
      my($fd,$ev,$io,$mask);
      my @handles = ();
  
      while(($fd,$ev) = each %{$self->[1]}) {
  	while (($io,$mask) = each %{$self->[0]{$fd}}) {
  	    $mask |= POLLHUP|POLLERR|POLLNVAL;  # must allow these
  	    push @handles,$self->[2]{$io} if ($ev & $mask) & $events;
  	}
      }
      return @handles;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  IO::Poll - Object interface to system poll call
  
  =head1 SYNOPSIS
  
      use IO::Poll qw(POLLRDNORM POLLWRNORM POLLIN POLLHUP);
  
      $poll = IO::Poll->new();
  
      $poll->mask($input_handle => POLLIN);
      $poll->mask($output_handle => POLLOUT);
  
      $poll->poll($timeout);
  
      $ev = $poll->events($input);
  
  =head1 DESCRIPTION
  
  C<IO::Poll> is a simple interface to the system level poll routine.
  
  =head1 METHODS
  
  =over 4
  
  =item mask ( IO [, EVENT_MASK ] )
  
  If EVENT_MASK is given, then, if EVENT_MASK is non-zero, IO is added to the
  list of file descriptors and the next call to poll will check for
  any event specified in EVENT_MASK. If EVENT_MASK is zero then IO will be
  removed from the list of file descriptors.
  
  If EVENT_MASK is not given then the return value will be the current
  event mask value for IO.
  
  =item poll ( [ TIMEOUT ] )
  
  Call the system level poll routine. If TIMEOUT is not specified then the
  call will block. Returns the number of handles which had events
  happen, or -1 on error.
  
  =item events ( IO )
  
  Returns the event mask which represents the events that happened on IO
  during the last call to C<poll>.
  
  =item remove ( IO )
  
  Remove IO from the list of file descriptors for the next poll.
  
  =item handles( [ EVENT_MASK ] )
  
  Returns a list of handles. If EVENT_MASK is not given then a list of all
  handles known will be returned. If EVENT_MASK is given then a list
  of handles will be returned which had one of the events specified by
  EVENT_MASK happen during the last call ti C<poll>
  
  =back
  
  =head1 SEE ALSO
  
  L<poll(2)>, L<IO::Handle>, L<IO::Select>
  
  =head1 AUTHOR
  
  Graham Barr. Currently maintained by the Perl Porters.  Please report all
  bugs at L<https://github.com/Perl/perl5/issues>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_IO_POLL

$fatpacked{"x86_64-linux-gnu-thread-multi/IO/Seekable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_IO_SEEKABLE';
  #
  
  package IO::Seekable;
  
  =head1 NAME
  
  IO::Seekable - supply seek based methods for I/O objects
  
  =head1 SYNOPSIS
  
      use IO::Seekable;
      package IO::Something;
      @ISA = qw(IO::Seekable);
  
  =head1 DESCRIPTION
  
  C<IO::Seekable> does not have a constructor of its own as it is intended to
  be inherited by other C<IO::Handle> based objects. It provides methods
  which allow seeking of the file descriptors.
  
  =over 4
  
  =item $io->getpos
  
  Returns an opaque value that represents the current position of the
  IO::File, or C<undef> if this is not possible (eg an unseekable stream such
  as a terminal, pipe or socket). If the fgetpos() function is available in
  your C library it is used to implements getpos, else perl emulates getpos
  using C's ftell() function.
  
  =item $io->setpos
  
  Uses the value of a previous getpos call to return to a previously visited
  position. Returns "0 but true" on success, C<undef> on failure.
  
  =back
  
  See L<perlfunc> for complete descriptions of each of the following
  supported C<IO::Seekable> methods, which are just front ends for the
  corresponding built-in functions:
  
  =over 4
  
  =item $io->seek ( POS, WHENCE )
  
  Seek the IO::File to position POS, relative to WHENCE:
  
  =over 8
  
  =item WHENCE=0 (SEEK_SET)
  
  POS is absolute position. (Seek relative to the start of the file)
  
  =item WHENCE=1 (SEEK_CUR)
  
  POS is an offset from the current position. (Seek relative to current)
  
  =item WHENCE=2 (SEEK_END)
  
  POS is an offset from the end of the file. (Seek relative to end)
  
  =back
  
  The SEEK_* constants can be imported from the C<Fcntl> module if you
  don't wish to use the numbers C<0> C<1> or C<2> in your code.
  
  Returns C<1> upon success, C<0> otherwise.
  
  =item $io->sysseek( POS, WHENCE )
  
  Similar to $io->seek, but sets the IO::File's position using the system
  call lseek(2) directly, so will confuse most perl IO operators except
  sysread and syswrite (see L<perlfunc> for full details)
  
  Returns the new position, or C<undef> on failure.  A position
  of zero is returned as the string C<"0 but true">
  
  =item $io->tell
  
  Returns the IO::File's current position, or -1 on error.
  
  =back
  
  =head1 SEE ALSO
  
  L<perlfunc>, 
  L<perlop/"I/O Operators">,
  L<IO::Handle>
  L<IO::File>
  
  =head1 HISTORY
  
  Derived from FileHandle.pm by Graham Barr E<lt>gbarr@pobox.comE<gt>
  
  =cut
  
  use 5.008_001;
  use Carp;
  use strict;
  use IO::Handle ();
  # XXX we can't get these from IO::Handle or we'll get prototype
  # mismatch warnings on C<use POSIX; use IO::File;> :-(
  use Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);
  require Exporter;
  
  our @EXPORT = qw(SEEK_SET SEEK_CUR SEEK_END);
  our @ISA = qw(Exporter);
  
  our $VERSION = "1.48";
  
  sub seek {
      @_ == 3 or croak 'usage: $io->seek(POS, WHENCE)';
      seek($_[0], $_[1], $_[2]);
  }
  
  sub sysseek {
      @_ == 3 or croak 'usage: $io->sysseek(POS, WHENCE)';
      sysseek($_[0], $_[1], $_[2]);
  }
  
  sub tell {
      @_ == 1 or croak 'usage: $io->tell()';
      tell($_[0]);
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_IO_SEEKABLE

$fatpacked{"x86_64-linux-gnu-thread-multi/IO/Select.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_IO_SELECT';
  # IO::Select.pm
  #
  # Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package IO::Select;
  
  use     strict;
  use warnings::register;
  require Exporter;
  
  our $VERSION = "1.49";
  
  our @ISA = qw(Exporter); # This is only so we can do version checking
  
  sub VEC_BITS () {0}
  sub FD_COUNT () {1}
  sub FIRST_FD () {2}
  
  sub new
  {
   my $self = shift;
   my $type = ref($self) || $self;
  
   my $vec = bless [undef,0], $type;
  
   $vec->add(@_)
      if @_;
  
   $vec;
  }
  
  sub add
  {
   shift->_update('add', @_);
  }
  
  
  sub remove
  {
   shift->_update('remove', @_);
  }
  
  
  sub exists
  {
   my $vec = shift;
   my $fno = $vec->_fileno(shift);
   return undef unless defined $fno;
   $vec->[$fno + FIRST_FD];
  }
  
  
  sub _fileno
  {
   my($self, $f) = @_;
   return unless defined $f;
   $f = $f->[0] if ref($f) eq 'ARRAY';
   if($f =~ /^[0-9]+$/) { # plain file number
    return $f;
   }
   elsif(defined(my $fd = fileno($f))) {
    return $fd;
   }
   else {
    # Neither a plain file number nor an opened filehandle; but maybe it was
    # previously registered and has since been closed. ->remove still wants to
    # know what fileno it had
    foreach my $i ( FIRST_FD .. $#$self ) {
     return $i - FIRST_FD if defined $self->[$i] && $self->[$i] == $f;
    }
    return undef;
   }
  }
  
  sub _update
  {
   my $vec = shift;
   my $add = shift eq 'add';
  
   my $bits = $vec->[VEC_BITS];
   $bits = '' unless defined $bits;
  
   my $count = 0;
   my $f;
   foreach $f (@_)
    {
     my $fn = $vec->_fileno($f);
     if ($add) {
       next unless defined $fn;
       my $i = $fn + FIRST_FD;
       if (defined $vec->[$i]) {
  	 $vec->[$i] = $f;  # if array rest might be different, so we update
  	 next;
       }
       $vec->[FD_COUNT]++;
       vec($bits, $fn, 1) = 1;
       $vec->[$i] = $f;
     } else {      # remove
       if ( ! defined $fn ) { # remove if fileno undef'd
         $fn = 0;
         for my $fe (@{$vec}[FIRST_FD .. $#$vec]) {
           if (defined($fe) && $fe == $f) {
  	   $vec->[FD_COUNT]--;
  	   $fe = undef;
  	   vec($bits, $fn, 1) = 0;
  	   last;
  	 }
  	 ++$fn;
         }
       }
       else {
         my $i = $fn + FIRST_FD;
         next unless defined $vec->[$i];
         $vec->[FD_COUNT]--;
         vec($bits, $fn, 1) = 0;
         $vec->[$i] = undef;
       }
     }
     $count++;
    }
   $vec->[VEC_BITS] = $vec->[FD_COUNT] ? $bits : undef;
   $count;
  }
  
  sub can_read
  {
   my $vec = shift;
   my $timeout = shift;
   my $r = $vec->[VEC_BITS];
  
   defined($r) && (select($r,undef,undef,$timeout) > 0)
      ? handles($vec, $r)
      : ();
  }
  
  sub can_write
  {
   my $vec = shift;
   my $timeout = shift;
   my $w = $vec->[VEC_BITS];
  
   defined($w) && (select(undef,$w,undef,$timeout) > 0)
      ? handles($vec, $w)
      : ();
  }
  
  sub has_exception
  {
   my $vec = shift;
   my $timeout = shift;
   my $e = $vec->[VEC_BITS];
  
   defined($e) && (select(undef,undef,$e,$timeout) > 0)
      ? handles($vec, $e)
      : ();
  }
  
  sub has_error
  {
   warnings::warn("Call to deprecated method 'has_error', use 'has_exception'")
  	if warnings::enabled();
   goto &has_exception;
  }
  
  sub count
  {
   my $vec = shift;
   $vec->[FD_COUNT];
  }
  
  sub bits
  {
   my $vec = shift;
   $vec->[VEC_BITS];
  }
  
  sub as_string  # for debugging
  {
   my $vec = shift;
   my $str = ref($vec) . ": ";
   my $bits = $vec->bits;
   my $count = $vec->count;
   $str .= defined($bits) ? unpack("b*", $bits) : "undef";
   $str .= " $count";
   my @handles = @$vec;
   splice(@handles, 0, FIRST_FD);
   for (@handles) {
       $str .= " " . (defined($_) ? "$_" : "-");
   }
   $str;
  }
  
  sub _max
  {
   my($a,$b,$c) = @_;
   $a > $b
      ? $a > $c
          ? $a
          : $c
      : $b > $c
          ? $b
          : $c;
  }
  
  sub select
  {
   shift
     if defined $_[0] && !ref($_[0]);
  
   my($r,$w,$e,$t) = @_;
   my @result = ();
  
   my $rb = defined $r ? $r->[VEC_BITS] : undef;
   my $wb = defined $w ? $w->[VEC_BITS] : undef;
   my $eb = defined $e ? $e->[VEC_BITS] : undef;
  
   if(select($rb,$wb,$eb,$t) > 0)
    {
     my @r = ();
     my @w = ();
     my @e = ();
     my $i = _max(defined $r ? scalar(@$r)-1 : 0,
                  defined $w ? scalar(@$w)-1 : 0,
                  defined $e ? scalar(@$e)-1 : 0);
  
     for( ; $i >= FIRST_FD ; $i--)
      {
       my $j = $i - FIRST_FD;
       push(@r, $r->[$i])
          if defined $rb && defined $r->[$i] && vec($rb, $j, 1);
       push(@w, $w->[$i])
          if defined $wb && defined $w->[$i] && vec($wb, $j, 1);
       push(@e, $e->[$i])
          if defined $eb && defined $e->[$i] && vec($eb, $j, 1);
      }
  
     @result = (\@r, \@w, \@e);
    }
   @result;
  }
  
  
  sub handles
  {
   my $vec = shift;
   my $bits = shift;
   my @h = ();
   my $i;
   my $max = scalar(@$vec) - 1;
  
   for ($i = FIRST_FD; $i <= $max; $i++)
    {
     next unless defined $vec->[$i];
     push(@h, $vec->[$i])
        if !defined($bits) || vec($bits, $i - FIRST_FD, 1);
    }
   
   @h;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  IO::Select - OO interface to the select system call
  
  =head1 SYNOPSIS
  
      use IO::Select;
  
      $s = IO::Select->new();
  
      $s->add(\*STDIN);
      $s->add($some_handle);
  
      @ready = $s->can_read($timeout);
  
      @ready = IO::Select->new(@handles)->can_read(0);
  
  =head1 DESCRIPTION
  
  The C<IO::Select> package implements an object approach to the system C<select>
  function call. It allows the user to see what IO handles, see L<IO::Handle>,
  are ready for reading, writing or have an exception pending.
  
  =head1 CONSTRUCTOR
  
  =over 4
  
  =item new ( [ HANDLES ] )
  
  The constructor creates a new object and optionally initialises it with a set
  of handles.
  
  =back
  
  =head1 METHODS
  
  =over 4
  
  =item add ( HANDLES )
  
  Add the list of handles to the C<IO::Select> object. It is these values that
  will be returned when an event occurs. C<IO::Select> keeps these values in a
  cache which is indexed by the C<fileno> of the handle, so if more than one
  handle with the same C<fileno> is specified then only the last one is cached.
  
  Each handle can be an C<IO::Handle> object, an integer or an array
  reference where the first element is an C<IO::Handle> or an integer.
  
  =item remove ( HANDLES )
  
  Remove all the given handles from the object. This method also works
  by the C<fileno> of the handles. So the exact handles that were added
  need not be passed, just handles that have an equivalent C<fileno>
  
  =item exists ( HANDLE )
  
  Returns a true value (actually the handle itself) if it is present.
  Returns undef otherwise.
  
  =item handles
  
  Return an array of all registered handles.
  
  =item can_read ( [ TIMEOUT ] )
  
  Return an array of handles that are ready for reading.  C<TIMEOUT> is the
  maximum amount of time to wait before returning an empty list (with C<$!>
  unchanged), in seconds, possibly fractional.  If C<TIMEOUT> is not given
  and any handles are registered then the call will block indefinitely.
  Upon error, an empty list is returned, with C<$!> set to indicate the
  error.  To distinguish between timeout and error, set C<$!> to zero
  before calling this method, and check it after an empty list is returned.
  
  =item can_write ( [ TIMEOUT ] )
  
  Same as C<can_read> except check for handles that can be written to.
  
  =item has_exception ( [ TIMEOUT ] )
  
  Same as C<can_read> except check for handles that have an exception
  condition, for example pending out-of-band data.
  
  =item count ()
  
  Returns the number of handles that the object will check for when
  one of the C<can_> methods is called or the object is passed to
  the C<select> static method.
  
  =item bits()
  
  Return the bit string suitable as argument to the core select() call.
  
  =item select ( READ, WRITE, EXCEPTION [, TIMEOUT ] )
  
  C<select> is a static method, that is you call it with the package name
  like C<new>. C<READ>, C<WRITE> and C<EXCEPTION> are either C<undef> or
  C<IO::Select> objects. C<TIMEOUT> is optional and has the same effect as
  for the core select call.
  
  If at least one handle is ready for the specified kind of operation,
  the result will be an array of 3 elements, each a reference to an array
  which will hold the handles that are ready for reading, writing and
  have exceptions respectively.  Upon timeout, an empty list is returned,
  with C<$!> unchanged.  Upon error, an empty list is returned, with C<$!>
  set to indicate the error.  To distinguish between timeout and error,
  set C<$!> to zero before calling this method, and check it after an
  empty list is returned.
  
  =back
  
  =head1 EXAMPLE
  
  Here is a short example which shows how C<IO::Select> could be used
  to write a server which communicates with several sockets while also
  listening for more connections on a listen socket
  
      use IO::Select;
      use IO::Socket;
  
      $lsn = IO::Socket::INET->new(Listen => 1, LocalPort => 8080);
      $sel = IO::Select->new( $lsn );
  
      while(@ready = $sel->can_read) {
          foreach $fh (@ready) {
              if($fh == $lsn) {
                  # Create a new socket
                  $new = $lsn->accept;
                  $sel->add($new);
              }
              else {
                  # Process socket
  
                  # Maybe we have finished with the socket
                  $sel->remove($fh);
                  $fh->close;
              }
          }
      }
  
  =head1 AUTHOR
  
  Graham Barr. Currently maintained by the Perl Porters.  Please report all
  bugs at L<https://github.com/Perl/perl5/issues>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
X86_64-LINUX-GNU-THREAD-MULTI_IO_SELECT

$fatpacked{"x86_64-linux-gnu-thread-multi/IO/Socket.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_IO_SOCKET';
  
  # IO::Socket.pm
  #
  # Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package IO::Socket;
  
  use 5.008_001;
  
  use IO::Handle;
  use Socket 1.3;
  use Carp;
  use strict;
  use Exporter;
  use Errno;
  
  # legacy
  
  require IO::Socket::INET;
  require IO::Socket::UNIX if ($^O ne 'epoc' && $^O ne 'symbian');
  
  our @ISA = qw(IO::Handle);
  
  our $VERSION = "1.49";
  
  our @EXPORT_OK = qw(sockatmark);
  
  our $errstr;
  
  sub import {
      my $pkg = shift;
      if (@_ && $_[0] eq 'sockatmark') { # not very extensible but for now, fast
  	Exporter::export_to_level('IO::Socket', 1, $pkg, 'sockatmark');
      } else {
  	my $callpkg = caller;
  	Exporter::export 'Socket', $callpkg, @_;
      }
  }
  
  sub new {
      my($class,%arg) = @_;
      my $sock = $class->SUPER::new();
  
      $sock->autoflush(1);
  
      ${*$sock}{'io_socket_timeout'} = delete $arg{Timeout};
  
      return scalar(%arg) ? $sock->configure(\%arg)
  			: $sock;
  }
  
  my @domain2pkg;
  
  sub register_domain {
      my($p,$d) = @_;
      $domain2pkg[$d] = $p;
  }
  
  sub configure {
      my($sock,$arg) = @_;
      my $domain = delete $arg->{Domain};
  
      croak 'IO::Socket: Cannot configure a generic socket'
  	unless defined $domain;
  
      croak "IO::Socket: Unsupported socket domain"
  	unless defined $domain2pkg[$domain];
  
      croak "IO::Socket: Cannot configure socket in domain '$domain'"
  	unless ref($sock) eq "IO::Socket";
  
      bless($sock, $domain2pkg[$domain]);
      $sock->configure($arg);
  }
  
  sub socket {
      @_ == 4 or croak 'usage: $sock->socket(DOMAIN, TYPE, PROTOCOL)';
      my($sock,$domain,$type,$protocol) = @_;
  
      socket($sock,$domain,$type,$protocol) or
      	return undef;
  
      ${*$sock}{'io_socket_domain'} = $domain;
      ${*$sock}{'io_socket_type'}   = $type;
  
      # "A value of 0 for protocol will let the system select an
      # appropriate protocol"
      # so we need to look up what the system selected,
      # not cache PF_UNSPEC.
      ${*$sock}{'io_socket_proto'} = $protocol if $protocol;
  
      $sock;
  }
  
  sub socketpair {
      @_ == 4 || croak 'usage: IO::Socket->socketpair(DOMAIN, TYPE, PROTOCOL)';
      my($class,$domain,$type,$protocol) = @_;
      my $sock1 = $class->new();
      my $sock2 = $class->new();
  
      socketpair($sock1,$sock2,$domain,$type,$protocol) or
      	return ();
  
      ${*$sock1}{'io_socket_type'}  = ${*$sock2}{'io_socket_type'}  = $type;
      ${*$sock1}{'io_socket_proto'} = ${*$sock2}{'io_socket_proto'} = $protocol;
  
      ($sock1,$sock2);
  }
  
  sub connect {
      @_ == 2 or croak 'usage: $sock->connect(NAME)';
      my $sock = shift;
      my $addr = shift;
      my $timeout = ${*$sock}{'io_socket_timeout'};
      my $err;
      my $blocking;
  
      $blocking = $sock->blocking(0) if $timeout;
      if (!connect($sock, $addr)) {
  	if (defined $timeout && ($!{EINPROGRESS} || $!{EWOULDBLOCK})) {
  	    require IO::Select;
  
  	    my $sel = IO::Select->new( $sock );
  
  	    undef $!;
  	    my($r,$w,$e) = IO::Select::select(undef,$sel,$sel,$timeout);
  	    if(@$e[0]) {
  		# Windows return from select after the timeout in case of
  		# WSAECONNREFUSED(10061) if exception set is not used.
  		# This behavior is different from Linux.
  		# Using the exception
  		# set we now emulate the behavior in Linux
  		#    - Karthik Rajagopalan
  		$err = $sock->getsockopt(SOL_SOCKET,SO_ERROR);
  		$errstr = $@ = "connect: $err";
  	    }
  	    elsif(!@$w[0]) {
  		$err = $! || (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);
  		$errstr = $@ = "connect: timeout";
  	    }
  	    elsif (!connect($sock,$addr) &&
                  not ($!{EISCONN} || ($^O eq 'MSWin32' &&
                  ($! == (($] < 5.019004) ? 10022 : Errno::EINVAL))))
              ) {
  		# Some systems refuse to re-connect() to
  		# an already open socket and set errno to EISCONN.
  		# Windows sets errno to WSAEINVAL (10022) (pre-5.19.4) or
  		# EINVAL (22) (5.19.4 onwards).
  		$err = $!;
  		$errstr = $@ = "connect: $!";
  	    }
  	}
          elsif ($blocking || !($!{EINPROGRESS} || $!{EWOULDBLOCK}))  {
  	    $err = $!;
  	    $errstr = $@ = "connect: $!";
  	}
      }
  
      $sock->blocking(1) if $blocking;
  
      $! = $err if $err;
  
      $err ? undef : $sock;
  }
  
  # Enable/disable blocking IO on sockets.
  # Without args return the current status of blocking,
  # with args change the mode as appropriate, returning the
  # old setting, or in case of error during the mode change
  # undef.
  
  sub blocking {
      my $sock = shift;
  
      return $sock->SUPER::blocking(@_)
          if $^O ne 'MSWin32' && $^O ne 'VMS';
  
      # Windows handles blocking differently
      #
      # http://groups.google.co.uk/group/perl.perl5.porters/browse_thread/thread/b4e2b1d88280ddff/630b667a66e3509f?#630b667a66e3509f
      # http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winsock/winsock/ioctlsocket_2.asp
      #
      # 0x8004667e is FIONBIO
      #
      # which is used to set blocking behaviour.
  
      # NOTE:
      # This is a little confusing, the perl keyword for this is
      # 'blocking' but the OS level behaviour is 'non-blocking', probably
      # because sockets are blocking by default.
      # Therefore internally we have to reverse the semantics.
  
      my $orig= !${*$sock}{io_sock_nonblocking};
  
      return $orig unless @_;
  
      my $block = shift;
  
      if ( !$block != !$orig ) {
          ${*$sock}{io_sock_nonblocking} = $block ? 0 : 1;
          ioctl($sock, 0x8004667e, pack("L!",${*$sock}{io_sock_nonblocking}))
              or return undef;
      }
  
      return $orig;
  }
  
  
  sub close {
      @_ == 1 or croak 'usage: $sock->close()';
      my $sock = shift;
      ${*$sock}{'io_socket_peername'} = undef;
      $sock->SUPER::close();
  }
  
  sub bind {
      @_ == 2 or croak 'usage: $sock->bind(NAME)';
      my $sock = shift;
      my $addr = shift;
  
      return bind($sock, $addr) ? $sock
  			      : undef;
  }
  
  sub listen {
      @_ >= 1 && @_ <= 2 or croak 'usage: $sock->listen([QUEUE])';
      my($sock,$queue) = @_;
      $queue = 5
  	unless $queue && $queue > 0;
  
      return listen($sock, $queue) ? $sock
  				 : undef;
  }
  
  sub accept {
      @_ == 1 || @_ == 2 or croak 'usage $sock->accept([PKG])';
      my $sock = shift;
      my $pkg = shift || $sock;
      my $timeout = ${*$sock}{'io_socket_timeout'};
      my $new = $pkg->new(Timeout => $timeout);
      my $peer = undef;
  
      if(defined $timeout) {
  	require IO::Select;
  
  	my $sel = IO::Select->new( $sock );
  
  	unless ($sel->can_read($timeout)) {
  	    $errstr = $@ = 'accept: timeout';
  	    $! = (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);
  	    return;
  	}
      }
  
      $peer = accept($new,$sock)
  	or return;
  
      ${*$new}{$_} = ${*$sock}{$_} for qw( io_socket_domain io_socket_type io_socket_proto );
  
      return wantarray ? ($new, $peer)
      	      	     : $new;
  }
  
  sub sockname {
      @_ == 1 or croak 'usage: $sock->sockname()';
      getsockname($_[0]);
  }
  
  sub peername {
      @_ == 1 or croak 'usage: $sock->peername()';
      my($sock) = @_;
      ${*$sock}{'io_socket_peername'} ||= getpeername($sock);
  }
  
  sub connected {
      @_ == 1 or croak 'usage: $sock->connected()';
      my($sock) = @_;
      getpeername($sock);
  }
  
  sub send {
      @_ >= 2 && @_ <= 4 or croak 'usage: $sock->send(BUF, [FLAGS, [TO]])';
      my $sock  = $_[0];
      my $flags = $_[2] || 0;
      my $peer;
  
      if ($_[3]) {
          # the caller explicitly requested a TO, so use it
          # this is non-portable for "connected" UDP sockets
          $peer = $_[3];
      }
      elsif (!defined getpeername($sock)) {
          # we're not connected, so we require a peer from somewhere
          $peer = $sock->peername;
  
  	croak 'send: Cannot determine peer address'
  	    unless(defined $peer);
      }
  
      my $r = $peer
        ? send($sock, $_[1], $flags, $peer)
        : send($sock, $_[1], $flags);
  
      # remember who we send to, if it was successful
      ${*$sock}{'io_socket_peername'} = $peer
  	if(@_ == 4 && defined $r);
  
      $r;
  }
  
  sub recv {
      @_ == 3 || @_ == 4 or croak 'usage: $sock->recv(BUF, LEN [, FLAGS])';
      my $sock  = $_[0];
      my $len   = $_[2];
      my $flags = $_[3] || 0;
  
      # remember who we recv'd from
      ${*$sock}{'io_socket_peername'} = recv($sock, $_[1]='', $len, $flags);
  }
  
  sub shutdown {
      @_ == 2 or croak 'usage: $sock->shutdown(HOW)';
      my($sock, $how) = @_;
      ${*$sock}{'io_socket_peername'} = undef;
      shutdown($sock, $how);
  }
  
  sub setsockopt {
      @_ == 4 or croak '$sock->setsockopt(LEVEL, OPTNAME, OPTVAL)';
      setsockopt($_[0],$_[1],$_[2],$_[3]);
  }
  
  my $intsize = length(pack("i",0));
  
  sub getsockopt {
      @_ == 3 or croak '$sock->getsockopt(LEVEL, OPTNAME)';
      my $r = getsockopt($_[0],$_[1],$_[2]);
      # Just a guess
      $r = unpack("i", $r)
  	if(defined $r && length($r) == $intsize);
      $r;
  }
  
  sub sockopt {
      my $sock = shift;
      @_ == 1 ? $sock->getsockopt(SOL_SOCKET,@_)
  	    : $sock->setsockopt(SOL_SOCKET,@_);
  }
  
  sub atmark {
      @_ == 1 or croak 'usage: $sock->atmark()';
      my($sock) = @_;
      sockatmark($sock);
  }
  
  sub timeout {
      @_ == 1 || @_ == 2 or croak 'usage: $sock->timeout([VALUE])';
      my($sock,$val) = @_;
      my $r = ${*$sock}{'io_socket_timeout'};
  
      ${*$sock}{'io_socket_timeout'} = defined $val ? 0 + $val : $val
  	if(@_ == 2);
  
      $r;
  }
  
  sub sockdomain {
      @_ == 1 or croak 'usage: $sock->sockdomain()';
      my $sock = shift;
      if (!defined(${*$sock}{'io_socket_domain'})) {
  	my $addr = $sock->sockname();
  	${*$sock}{'io_socket_domain'} = sockaddr_family($addr)
  	    if (defined($addr));
      }
      ${*$sock}{'io_socket_domain'};
  }
  
  sub socktype {
      @_ == 1 or croak 'usage: $sock->socktype()';
      my $sock = shift;
      ${*$sock}{'io_socket_type'} = $sock->sockopt(Socket::SO_TYPE)
  	if (!defined(${*$sock}{'io_socket_type'}) && defined(eval{Socket::SO_TYPE}));
      ${*$sock}{'io_socket_type'}
  }
  
  sub protocol {
      @_ == 1 or croak 'usage: $sock->protocol()';
      my($sock) = @_;
      ${*$sock}{'io_socket_proto'} = $sock->sockopt(Socket::SO_PROTOCOL)
  	if (!defined(${*$sock}{'io_socket_proto'}) && defined(eval{Socket::SO_PROTOCOL}));
      ${*$sock}{'io_socket_proto'};
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  IO::Socket - Object interface to socket communications
  
  =head1 SYNOPSIS
  
      use strict;
      use warnings;
  
      use IO::Socket qw(AF_INET AF_UNIX);
  
      # create a new AF_INET socket
      my $sock = IO::Socket->new(Domain => AF_INET);
      # which is the same as
      $sock = IO::Socket::INET->new();
  
      # create a new AF_UNIX socket
      $sock = IO::Socket->new(Domain => AF_UNIX);
      # which is the same as
      $sock = IO::Socket::UNIX->new();
  
  =head1 DESCRIPTION
  
  C<IO::Socket> provides an object-oriented, L<IO::Handle>-based interface to
  creating and using sockets via L<Socket>, which provides a near one-to-one
  interface to the C socket library.
  
  C<IO::Socket> is a base class that really only defines methods for those
  operations which are common to all types of sockets. Operations which are
  specific to a particular socket domain have methods defined in subclasses of
  C<IO::Socket>. See L<IO::Socket::INET>, L<IO::Socket::UNIX>, and
  L<IO::Socket::IP> for examples of such a subclass.
  
  C<IO::Socket> will export all functions (and constants) defined by L<Socket>.
  
  =head1 CONSTRUCTOR ARGUMENTS
  
  Given that C<IO::Socket> doesn't have attributes in the traditional sense, the
  following arguments, rather than attributes, can be passed into the
  constructor.
  
  Constructor arguments should be passed in C<< Key => 'Value' >> pairs.
  
  The only required argument is L<IO::Socket/"Domain">.
  
  =head2 Blocking
  
      my $sock = IO::Socket->new(..., Blocking => 1);
      $sock = IO::Socket->new(..., Blocking => 0);
  
  If defined but false, the socket will be set to non-blocking mode. If not
  specified it defaults to C<1> (blocking mode).
  
  =head2 Domain
  
      my $sock = IO::Socket->new(Domain => IO::Socket::AF_INET);
      $sock = IO::Socket->new(Domain => IO::Socket::AF_UNIX);
  
  The socket domain will define which subclass of C<IO::Socket> to use. The two
  options available along with this distribution are C<AF_INET> and C<AF_UNIX>.
  
  C<AF_INET> is for the internet address family of sockets and is handled via
  L<IO::Socket::INET>. C<AF_INET> sockets are bound to an internet address and
  port.
  
  C<AF_UNIX> is for the unix domain socket and is handled via
  L<IO::Socket::UNIX>. C<AF_UNIX> sockets are bound to the file system as their
  address name space.
  
  This argument is B<required>. All other arguments are optional.
  
  =head2 Listen
  
      my $sock = IO::Socket->new(..., Listen => 5);
  
  Listen should be an integer value or left unset.
  
  If provided, this argument will place the socket into listening mode. New
  connections can then be accepted using the L<IO::Socket/"accept"> method. The
  value given is used as the C<listen(2)> queue size.
  
  If the C<Listen> argument is given, but false, the queue size will be set to
  5.
  
  =head2 Timeout
  
      my $sock = IO::Socket->new(..., Timeout => 5);
  
  The timeout value, in seconds, for this socket connection. How exactly this
  value is utilized is defined in the socket domain subclasses that make use of
  the value.
  
  =head2 Type
  
      my $sock = IO::Socket->new(..., Type => IO::Socket::SOCK_STREAM);
  
  The socket type that will be used. These are usually C<SOCK_STREAM>,
  C<SOCK_DGRAM>, or C<SOCK_RAW>. If this argument is left undefined an attempt
  will be made to infer the type from the service name.
  
  For example, you'll usually use C<SOCK_STREAM> with a C<tcp> connection and
  C<SOCK_DGRAM> with a C<udp> connection.
  
  =head1 CONSTRUCTORS
  
  C<IO::Socket> extends the L<IO::Handle> constructor.
  
  =head2 new
  
      my $sock = IO::Socket->new();
  
      # get a new IO::Socket::INET instance
      $sock = IO::Socket->new(Domain => IO::Socket::AF_INET);
      # get a new IO::Socket::UNIX instance
      $sock = IO::Socket->new(Domain => IO::Socket::AF_UNIX);
  
      # Domain is the only required argument
      $sock = IO::Socket->new(
          Domain => IO::Socket::AF_INET, # AF_INET, AF_UNIX
          Type => IO::Socket::SOCK_STREAM, # SOCK_STREAM, SOCK_DGRAM, ...
          Proto => 'tcp', # 'tcp', 'udp', IPPROTO_TCP, IPPROTO_UDP
          # and so on...
      );
  
  Creates an C<IO::Socket>, which is a reference to a newly created symbol (see
  the L<Symbol> package). C<new> optionally takes arguments, these arguments
  are defined in L<IO::Socket/"CONSTRUCTOR ARGUMENTS">.
  
  Any of the L<IO::Socket/"CONSTRUCTOR ARGUMENTS"> may be passed to the
  constructor, but if any arguments are provided, then one of them must be
  the L<IO::Socket/"Domain"> argument. The L<IO::Socket/"Domain"> argument can,
  by default, be either C<AF_INET> or C<AF_UNIX>. Other domains can be used if a
  proper subclass for the domain family is registered. All other arguments will
  be passed to the C<configuration> method of the package for that domain.
  
  If the constructor fails it will return C<undef> and set the C<$errstr> package
  variable to contain an error message.
  
      $sock = IO::Socket->new(...)
          or die "Cannot create socket - $IO::Socket::errstr\n";
  
  For legacy reasons the error message is also set into the global C<$@>
  variable, and you may still find older code which looks here instead.
  
      $sock = IO::Socket->new(...)
          or die "Cannot create socket - $@\n";
  
  =head1 METHODS
  
  C<IO::Socket> inherits all methods from L<IO::Handle> and implements the
  following new ones.
  
  =head2 accept
  
      my $client_sock = $sock->accept();
      my $inet_sock = $sock->accept('IO::Socket::INET');
  
  The accept method will perform the system call C<accept> on the socket and
  return a new object. The new object will be created in the same class as the
  listen socket, unless a specific package name is specified. This object can be
  used to communicate with the client that was trying to connect.
  
  This differs slightly from the C<accept> function in L<perlfunc>.
  
  In a scalar context the new socket is returned, or C<undef> upon
  failure. In a list context a two-element array is returned containing
  the new socket and the peer address; the list will be empty upon failure.
  
  =head2 atmark
  
      my $integer = $sock->atmark();
      # read in some data on a given socket
      my $data;
      $sock->read($data, 1024) until $sock->atmark;
  
      # or, export the function to use:
      use IO::Socket 'sockatmark';
      $sock->read($data, 1024) until sockatmark($sock);
  
  True if the socket is currently positioned at the urgent data mark, false
  otherwise. If your system doesn't yet implement C<sockatmark> this will throw
  an exception.
  
  If your system does not support C<sockatmark>, the C<use> declaration will
  fail at compile time.
  
  =head2 autoflush
  
      # by default, autoflush will be turned on when referenced
      $sock->autoflush(); # turns on autoflush
      # turn off autoflush
      $sock->autoflush(0);
      # turn on autoflush
      $sock->autoflush(1);
  
  This attribute isn't overridden from L<IO::Handle>'s implementation. However,
  since we turn it on by default, it's worth mentioning here.
  
  =head2 bind
  
      use Socket qw(pack_sockaddr_in);
      my $port = 3000;
      my $ip_address = '0.0.0.0';
      my $packed_addr = pack_sockaddr_in($port, $ip_address);
      $sock->bind($packed_addr);
  
  Binds a network address to a socket, just as C<bind(2)> does. Returns true if
  it succeeded, false otherwise. You should provide a packed address of the
  appropriate type for the socket.
  
  =head2 connected
  
      my $peer_addr = $sock->connected();
      if ($peer_addr) {
          say "We're connected to $peer_addr";
      }
  
  If the socket is in a connected state, the peer address is returned. If the
  socket is not in a connected state, C<undef> is returned.
  
  Note that this method considers a half-open TCP socket to be "in a connected
  state".  Specifically, it does not distinguish between the
  B<ESTABLISHED> and B<CLOSE-WAIT> TCP states; it returns the peer address,
  rather than C<undef>, in either case.  Thus, in general, it cannot
  be used to reliably learn whether the peer has initiated a graceful shutdown
  because in most cases (see below) the local TCP state machine remains in
  B<CLOSE-WAIT> until the local application calls L<IO::Socket/"shutdown"> or
  C<close>. Only at that point does this function return C<undef>.
  
  The "in most cases" hedge is because local TCP state machine behavior may
  depend on the peer's socket options. In particular, if the peer socket has
  C<SO_LINGER> enabled with a zero timeout, then the peer's C<close> will
  generate a C<RST> segment. Upon receipt of that segment, the local TCP
  transitions immediately to B<CLOSED>, and in that state, this method I<will>
  return C<undef>.
  
  =head2 getsockopt
  
      my $value = $sock->getsockopt(SOL_SOCKET, SO_REUSEADDR);
      my $buf = $socket->getsockopt(SOL_SOCKET, SO_RCVBUF);
      say "Receive buffer is $buf bytes";
  
  Get an option associated with the socket. Levels other than C<SOL_SOCKET>
  may be specified here. As a convenience, this method will unpack a byte buffer
  of the correct size back into a number.
  
  =head2 listen
  
      $sock->listen(5);
  
  Does the same thing that the C<listen(2)> system call does. Returns true if it
  succeeded, false otherwise. Listens to a socket with a given queue size.
  
  =head2 peername
  
      my $sockaddr_in = $sock->peername();
  
  Returns the packed C<sockaddr> address of the other end of the socket
  connection. It calls C<getpeername>.
  
  
  =head2 protocol
  
      my $proto = $sock->protocol();
  
  Returns the number for the protocol being used on the socket, if
  known. If the protocol is unknown, as with an C<AF_UNIX> socket, zero
  is returned.
  
  =head2 recv
  
      my $buffer = "";
      my $length = 1024;
      my $flags = 0; # default. optional
      $sock->recv($buffer, $length);
      $sock->recv($buffer, $length, $flags);
  
  Similar in functionality to L<perlfunc/recv>.
  
  Receives a message on a socket. Attempts to receive C<$length> characters of
  data into C<$buffer> from the specified socket. C<$buffer> will be grown or
  shrunk to the length actually read. Takes the same flags as the system call of
  the same name. Returns the address of the sender if socket's protocol supports
  this; returns an empty string otherwise. If there's an error, returns
  C<undef>. This call is actually implemented in terms of the C<recvfrom(2)>
  system call.
  
  Flags are ORed together values, such as C<MSG_BCAST>, C<MSG_OOB>,
  C<MSG_TRUNC>. The default value for the flags is C<0>.
  
  The cached value of L<IO::Socket/"peername"> is updated with the result of
  C<recv>.
  
  B<Note:> In Perl v5.30 and newer, if the socket has been marked as C<:utf8>,
  C<recv> will throw an exception. The C<:encoding(...)> layer implicitly
  introduces the C<:utf8> layer. See L<perlfunc/binmode>.
  
  B<Note:> In Perl versions older than v5.30, depending on the status of the
  socket, either (8-bit) bytes or characters are received. By default all
  sockets operate on bytes, but for example if the socket has been changed
  using L<perlfunc/binmode> to operate with the C<:encoding(UTF-8)> I/O layer
  (see the L<perlfunc/open> pragma), the I/O will operate on UTF8-encoded
  Unicode characters, not bytes. Similarly for the C<:encoding> layer: in
  that case pretty much any characters can be read.
  
  =head2 send
  
      my $message = "Hello, world!";
      my $flags = 0; # defaults to zero
      my $to = '0.0.0.0'; # optional destination
      my $sent = $sock->send($message);
      $sent = $sock->send($message, $flags);
      $sent = $sock->send($message, $flags, $to);
  
  Similar in functionality to L<perlfunc/send>.
  
  Sends a message on a socket. Attempts to send the scalar message to the
  socket. Takes the same flags as the system call of the same name. On
  unconnected sockets, you must specify a destination to send to, in which case
  it does a C<sendto(2)> syscall. Returns the number of characters sent, or
  C<undef> on error. The C<sendmsg(2)> syscall is currently unimplemented.
  
  The C<flags> option is optional and defaults to C<0>.
  
  After a successful send with C<$to>, further calls to C<send> on an
  unconnected socket without C<$to> will send to the same address, and C<$to>
  will be used as the result of L<IO::Socket/"peername">.
  
  B<Note:> In Perl v5.30 and newer, if the socket has been marked as C<:utf8>,
  C<send> will throw an exception. The C<:encoding(...)> layer implicitly
  introduces the C<:utf8> layer. See L<perlfunc/binmode>.
  
  B<Note:> In Perl versions older than v5.30, depending on the status of the
  socket, either (8-bit) bytes or characters are sent. By default all
  sockets operate on bytes, but for example if the socket has been changed
  using L<perlfunc/binmode> to operate with the C<:encoding(UTF-8)> I/O layer
  (see the L<perlfunc/open> pragma), the I/O will operate on UTF8-encoded
  Unicode characters, not bytes. Similarly for the C<:encoding> layer: in
  that case pretty much any characters can be sent.
  
  =head2 setsockopt
  
      $sock->setsockopt(SOL_SOCKET, SO_REUSEADDR, 1);
      $sock->setsockopt(SOL_SOCKET, SO_RCVBUF, 64*1024);
  
  Set option associated with the socket. Levels other than C<SOL_SOCKET>
  may be specified here. As a convenience, this method will convert a number
  into a packed byte buffer.
  
  =head2 shutdown
  
      $sock->shutdown(SHUT_RD); # we stopped reading data
      $sock->shutdown(SHUT_WR); # we stopped writing data
      $sock->shutdown(SHUT_RDWR); # we stopped using this socket
  
  Shuts down a socket connection in the manner indicated by the value passed in,
  which has the same interpretation as in the syscall of the same name.
  
  This is useful with sockets when you want to tell the other side you're done
  writing but not done reading, or vice versa. It's also a more insistent form
  of C<close> because it also disables the file descriptor in any
  forked copies in other processes.
  
  Returns C<1> for success; on error, returns C<undef> if the socket is
  not a valid filehandle, or returns C<0> and sets C<$!> for any other failure.
  
  =head2 sockdomain
  
      my $domain = $sock->sockdomain();
  
  Returns the number for the socket domain type. For example, for
  an C<AF_INET> socket the value of C<&AF_INET> will be returned.
  
  =head2 socket
  
      my $sock = IO::Socket->new(); # no values given
      # now let's actually get a socket with the socket method
      # domain, type, and protocol are required
      $sock = $sock->socket(AF_INET, SOCK_STREAM, 'tcp');
  
  Opens a socket of the specified kind and returns it. Domain, type, and
  protocol are specified the same as for the syscall of the same name.
  
  =head2 socketpair
  
      my ($r, $w) = $sock->socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC);
      ($r, $w) = IO::Socket::UNIX
          ->socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC);
  
  Will return a list of two sockets created (read and write), or an empty list
  on failure.
  
  Differs slightly from C<socketpair> in L<perlfunc> in that the argument list
  is a bit simpler.
  
  =head2 sockname
  
      my $packed_addr = $sock->sockname();
  
  Returns the packed C<sockaddr> address of this end of the connection. It's the
  same as C<getsockname(2)>.
  
  =head2 sockopt
  
      my $value = $sock->sockopt(SO_REUSEADDR);
      $sock->sockopt(SO_REUSEADDR, 1);
  
  Unified method to both set and get options in the C<SOL_SOCKET> level. If
  called with one argument then L<IO::Socket/"getsockopt"> is called, otherwise
  L<IO::Socket/"setsockopt"> is called.
  
  =head2 socktype
  
      my $type = $sock->socktype();
  
  Returns the number for the socket type. For example, for
  a C<SOCK_STREAM> socket the value of C<&SOCK_STREAM> will be returned.
  
  =head2 timeout
  
      my $seconds = $sock->timeout();
      my $old_val = $sock->timeout(5); # set new and return old value
  
  Set or get the timeout value (in seconds) associated with this socket.
  If called without any arguments then the current setting is returned. If
  called with an argument the current setting is changed and the previous
  value returned.
  
  This method is available to all C<IO::Socket> implementations but may or may
  not be used by the individual domain subclasses.
  
  =head1 EXAMPLES
  
  Let's create a TCP server on C<localhost:3333>.
  
      use strict;
      use warnings;
      use feature 'say';
  
      use IO::Socket qw(AF_INET AF_UNIX SOCK_STREAM SHUT_WR);
  
      my $server = IO::Socket->new(
          Domain => AF_INET,
          Type => SOCK_STREAM,
          Proto => 'tcp',
          LocalHost => '0.0.0.0',
          LocalPort => 3333,
          ReusePort => 1,
          Listen => 5,
      ) || die "Can't open socket: $IO::Socket::errstr";
      say "Waiting on 3333";
  
      while (1) {
          # waiting for a new client connection
          my $client = $server->accept();
  
          # get information about a newly connected client
          my $client_address = $client->peerhost();
          my $client_port = $client->peerport();
          say "Connection from $client_address:$client_port";
  
          # read up to 1024 characters from the connected client
          my $data = "";
          $client->recv($data, 1024);
          say "received data: $data";
  
          # write response data to the connected client
          $data = "ok";
          $client->send($data);
  
          # notify client that response has been sent
          $client->shutdown(SHUT_WR);
      }
  
      $server->close();
  
  A client for such a server could be
  
      use strict;
      use warnings;
      use feature 'say';
  
      use IO::Socket qw(AF_INET AF_UNIX SOCK_STREAM SHUT_WR);
  
      my $client = IO::Socket->new(
          Domain => AF_INET,
          Type => SOCK_STREAM,
          proto => 'tcp',
          PeerPort => 3333,
          PeerHost => '0.0.0.0',
      ) || die "Can't open socket: $IO::Socket::errstr";
  
      say "Sending Hello World!";
      my $size = $client->send("Hello World!");
      say "Sent data of length: $size";
  
      $client->shutdown(SHUT_WR);
  
      my $buffer;
      $client->recv($buffer, 1024);
      say "Got back $buffer";
  
      $client->close();
  
  
  =head1 LIMITATIONS
  
  On some systems, for an IO::Socket object created with C<new_from_fd>,
  or created with L<IO::Socket/"accept"> from such an object, the
  L<IO::Socket/"protocol">, L<IO::Socket/"sockdomain"> and
  L<IO::Socket/"socktype"> methods may return C<undef>.
  
  =head1 SEE ALSO
  
  L<Socket>, L<IO::Handle>, L<IO::Socket::INET>, L<IO::Socket::UNIX>,
  L<IO::Socket::IP>
  
  =head1 AUTHOR
  
  Graham Barr.  atmark() by Lincoln Stein.  Currently maintained by the Perl 5
  Porters.  Please report all bugs at L<https://github.com/Perl/perl5/issues>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  The atmark() implementation: Copyright 2001, Lincoln Stein <lstein@cshl.org>.
  This module is distributed under the same terms as Perl itself.
  Feel free to use, modify and redistribute it as long as you retain
  the correct attribution.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_IO_SOCKET

$fatpacked{"x86_64-linux-gnu-thread-multi/IO/Socket/INET.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_IO_SOCKET_INET';
  # IO::Socket::INET.pm
  #
  # Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package IO::Socket::INET;
  
  use strict;
  use IO::Socket;
  use Socket;
  use Carp;
  use Exporter;
  use Errno;
  
  our @ISA = qw(IO::Socket);
  our $VERSION = "1.49";
  
  my $EINVAL = exists(&Errno::EINVAL) ? Errno::EINVAL() : 1;
  
  IO::Socket::INET->register_domain( AF_INET );
  
  my %socket_type = ( tcp  => SOCK_STREAM,
  		    udp  => SOCK_DGRAM,
  		    icmp => SOCK_RAW
  		  );
  my %proto_number;
  $proto_number{tcp}  = Socket::IPPROTO_TCP()  if defined &Socket::IPPROTO_TCP;
  $proto_number{udp}  = Socket::IPPROTO_UDP()  if defined &Socket::IPPROTO_UDP;
  $proto_number{icmp} = Socket::IPPROTO_ICMP() if defined &Socket::IPPROTO_ICMP;
  my %proto_name = reverse %proto_number;
  
  sub new {
      my $class = shift;
      unshift(@_, "PeerAddr") if @_ == 1;
      return $class->SUPER::new(@_);
  }
  
  sub _cache_proto {
      my @proto = @_;
      for (map lc($_), $proto[0], split(' ', $proto[1])) {
  	$proto_number{$_} = $proto[2];
      }
      $proto_name{$proto[2]} = $proto[0];
  }
  
  sub _get_proto_number {
      my $name = lc(shift);
      return undef unless defined $name;
      return $proto_number{$name} if exists $proto_number{$name};
  
      my @proto = eval { getprotobyname($name) };
      return undef unless @proto;
      _cache_proto(@proto);
  
      return $proto[2];
  }
  
  sub _get_proto_name {
      my $num = shift;
      return undef unless defined $num;
      return $proto_name{$num} if exists $proto_name{$num};
  
      my @proto = eval { getprotobynumber($num) };
      return undef unless @proto;
      _cache_proto(@proto);
  
      return $proto[0];
  }
  
  sub _sock_info {
    my($addr,$port,$proto) = @_;
    my $origport = $port;
    my @serv = ();
  
    $port = $1
  	if(defined $addr && $addr =~ s,:([\w\(\)/]+)$,,);
  
    if(defined $proto  && $proto =~ /\D/) {
      my $num = _get_proto_number($proto);
      unless (defined $num) {
        $IO::Socket::errstr = $@ = "Bad protocol '$proto'";
        return;
      }
      $proto = $num;
    }
  
    if(defined $port) {
      my $defport = ($port =~ s,\((\d+)\)$,,) ? $1 : undef;
      my $pnum = ($port =~ m,^(\d+)$,)[0];
  
      @serv = getservbyname($port, _get_proto_name($proto) || "")
  	if ($port =~ m,\D,);
  
      $port = $serv[2] || $defport || $pnum;
      unless (defined $port) {
  	$IO::Socket::errstr = $@ = "Bad service '$origport'";
  	return;
      }
  
      $proto = _get_proto_number($serv[3]) if @serv && !$proto;
    }
  
   return ($addr || undef,
  	 $port || undef,
  	 $proto || undef
  	);
  }
  
  sub _error {
      my $sock = shift;
      my $err = shift;
      {
        local($!);
        my $title = ref($sock).": ";
        $IO::Socket::errstr = $@ = join("", $_[0] =~ /^$title/ ? "" : $title, @_);
        $sock->close()
  	if(defined fileno($sock));
      }
      $! = $err;
      return undef;
  }
  
  sub _get_addr {
      my($sock,$addr_str, $multi) = @_;
      my @addr;
      if ($multi && $addr_str !~ /^\d+(?:\.\d+){3}$/) {
  	(undef, undef, undef, undef, @addr) = gethostbyname($addr_str);
      } else {
  	my $h = inet_aton($addr_str);
  	push(@addr, $h) if defined $h;
      }
      @addr;
  }
  
  sub configure {
      my($sock,$arg) = @_;
      my($lport,$rport,$laddr,$raddr,$proto,$type);
  
  
      $arg->{LocalAddr} = $arg->{LocalHost}
  	if exists $arg->{LocalHost} && !exists $arg->{LocalAddr};
  
      ($laddr,$lport,$proto) = _sock_info($arg->{LocalAddr},
  					$arg->{LocalPort},
  					$arg->{Proto})
  			or return _error($sock, $!, $@);
  
      $laddr = defined $laddr ? inet_aton($laddr)
  			    : INADDR_ANY;
  
      return _error($sock, $EINVAL, "Bad hostname '",$arg->{LocalAddr},"'")
  	unless(defined $laddr);
  
      $arg->{PeerAddr} = $arg->{PeerHost}
  	if exists $arg->{PeerHost} && !exists $arg->{PeerAddr};
  
      unless(exists $arg->{Listen}) {
  	($raddr,$rport,$proto) = _sock_info($arg->{PeerAddr},
  					    $arg->{PeerPort},
  					    $proto)
  			or return _error($sock, $!, $@);
      }
  
      $proto ||= _get_proto_number('tcp');
  
      $type = $arg->{Type} || $socket_type{lc _get_proto_name($proto)};
  
      my @raddr = ();
  
      if(defined $raddr) {
  	@raddr = $sock->_get_addr($raddr, $arg->{MultiHomed});
  	return _error($sock, $EINVAL, "Bad hostname '",$arg->{PeerAddr},"'")
  	    unless @raddr;
      }
  
      while(1) {
  
  	$sock->socket(AF_INET, $type, $proto) or
  	    return _error($sock, $!, "$!");
  
          if (defined $arg->{Blocking}) {
  	    defined $sock->blocking($arg->{Blocking})
  		or return _error($sock, $!, "$!");
  	}
  
  	if ($arg->{Reuse} || $arg->{ReuseAddr}) {
  	    $sock->sockopt(SO_REUSEADDR,1) or
  		    return _error($sock, $!, "$!");
  	}
  
  	if ($arg->{ReusePort}) {
  	    $sock->sockopt(SO_REUSEPORT,1) or
  		    return _error($sock, $!, "$!");
  	}
  
  	if ($arg->{Broadcast}) {
  		$sock->sockopt(SO_BROADCAST,1) or
  		    return _error($sock, $!, "$!");
  	}
  
  	if($lport || ($laddr ne INADDR_ANY) || exists $arg->{Listen}) {
  	    $sock->bind($lport || 0, $laddr) or
  		    return _error($sock, $!, "$!");
  	}
  
  	if(exists $arg->{Listen}) {
  	    $sock->listen($arg->{Listen} || 5) or
  		return _error($sock, $!, "$!");
  	    last;
  	}
  
   	# don't try to connect unless we're given a PeerAddr
   	last unless exists($arg->{PeerAddr});
   
          $raddr = shift @raddr;
  
  	return _error($sock, $EINVAL, 'Cannot determine remote port')
  		unless($rport || $type == SOCK_DGRAM || $type == SOCK_RAW);
  
  	last
  	    unless($type == SOCK_STREAM || defined $raddr);
  
  	return _error($sock, $EINVAL, "Bad hostname '",$arg->{PeerAddr},"'")
  	    unless defined $raddr;
  
  #        my $timeout = ${*$sock}{'io_socket_timeout'};
  #        my $before = time() if $timeout;
  
  	undef $@;
          if ($sock->connect(pack_sockaddr_in($rport, $raddr))) {
  #            ${*$sock}{'io_socket_timeout'} = $timeout;
              return $sock;
          }
  
  	return _error($sock, $!, $@ || "Timeout")
  	    unless @raddr;
  
  #	if ($timeout) {
  #	    my $new_timeout = $timeout - (time() - $before);
  #	    return _error($sock,
  #                         (exists(&Errno::ETIMEDOUT) ? Errno::ETIMEDOUT() : $EINVAL),
  #                         "Timeout") if $new_timeout <= 0;
  #	    ${*$sock}{'io_socket_timeout'} = $new_timeout;
  #        }
  
      }
  
      $sock;
  }
  
  sub connect {
      @_ == 2 || @_ == 3 or
         croak 'usage: $sock->connect(NAME) or $sock->connect(PORT, ADDR)';
      my $sock = shift;
      return $sock->SUPER::connect(@_ == 1 ? shift : pack_sockaddr_in(@_));
  }
  
  sub bind {
      @_ == 2 || @_ == 3 or
         croak 'usage: $sock->bind(NAME) or $sock->bind(PORT, ADDR)';
      my $sock = shift;
      return $sock->SUPER::bind(@_ == 1 ? shift : pack_sockaddr_in(@_))
  }
  
  sub sockaddr {
      @_ == 1 or croak 'usage: $sock->sockaddr()';
      my($sock) = @_;
      my $name = $sock->sockname;
      $name ? (sockaddr_in($name))[1] : undef;
  }
  
  sub sockport {
      @_ == 1 or croak 'usage: $sock->sockport()';
      my($sock) = @_;
      my $name = $sock->sockname;
      $name ? (sockaddr_in($name))[0] : undef;
  }
  
  sub sockhost {
      @_ == 1 or croak 'usage: $sock->sockhost()';
      my($sock) = @_;
      my $addr = $sock->sockaddr;
      $addr ? inet_ntoa($addr) : undef;
  }
  
  sub peeraddr {
      @_ == 1 or croak 'usage: $sock->peeraddr()';
      my($sock) = @_;
      my $name = $sock->peername;
      $name ? (sockaddr_in($name))[1] : undef;
  }
  
  sub peerport {
      @_ == 1 or croak 'usage: $sock->peerport()';
      my($sock) = @_;
      my $name = $sock->peername;
      $name ? (sockaddr_in($name))[0] : undef;
  }
  
  sub peerhost {
      @_ == 1 or croak 'usage: $sock->peerhost()';
      my($sock) = @_;
      my $addr = $sock->peeraddr;
      $addr ? inet_ntoa($addr) : undef;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  IO::Socket::INET - Object interface for AF_INET domain sockets
  
  =head1 SYNOPSIS
  
      use IO::Socket::INET;
  
  =head1 DESCRIPTION
  
  C<IO::Socket::INET> provides an object interface to creating and using sockets
  in the AF_INET domain. It is built upon the L<IO::Socket> interface and
  inherits all the methods defined by L<IO::Socket>.
  
  =head1 CONSTRUCTOR
  
  =over 4
  
  =item new ( [ARGS] )
  
  Creates an C<IO::Socket::INET> object, which is a reference to a
  newly created symbol (see the C<Symbol> package). C<new>
  optionally takes arguments, these arguments are in key-value pairs.
  
  In addition to the key-value pairs accepted by L<IO::Socket>,
  C<IO::Socket::INET> provides.
  
  
   PeerAddr    Remote host address          <hostname>[:<port>]
   PeerHost    Synonym for PeerAddr
   PeerPort    Remote port or service       <service>[(<no>)] | <no>
   LocalAddr   Local host bind address      hostname[:port]
   LocalHost   Synonym for LocalAddr
   LocalPort   Local host bind port         <service>[(<no>)] | <no>
   Proto       Protocol name (or number)    "tcp" | "udp" | ...
   Type        Socket type              SOCK_STREAM | SOCK_DGRAM | ...
   Listen      Queue size for listen
   ReuseAddr   Set SO_REUSEADDR before binding
   Reuse       Set SO_REUSEADDR before binding (deprecated,
                                                prefer ReuseAddr)
   ReusePort   Set SO_REUSEPORT before binding
   Broadcast   Set SO_BROADCAST before binding
   Timeout     Timeout value for various operations
   MultiHomed  Try all addresses for multi-homed hosts
   Blocking    Determine if connection will be blocking mode
  
  If C<Listen> is defined then a listen socket is created, else if the
  socket type, which is derived from the protocol, is SOCK_STREAM then
  connect() is called.  If the C<Listen> argument is given, but false,
  the queue size will be set to 5.
  
  Although it is not illegal, the use of C<MultiHomed> on a socket
  which is in non-blocking mode is of little use. This is because the
  first connect will never fail with a timeout as the connect call
  will not block.
  
  The C<PeerAddr> can be a hostname or the IP-address on the
  "xx.xx.xx.xx" form.  The C<PeerPort> can be a number or a symbolic
  service name.  The service name might be followed by a number in
  parenthesis which is used if the service is not known by the system.
  The C<PeerPort> specification can also be embedded in the C<PeerAddr>
  by preceding it with a ":".
  
  If C<Proto> is not given and you specify a symbolic C<PeerPort> port,
  then the constructor will try to derive C<Proto> from the service
  name.  As a last resort C<Proto> "tcp" is assumed.  The C<Type>
  parameter will be deduced from C<Proto> if not specified.
  
  If the constructor is only passed a single argument, it is assumed to
  be a C<PeerAddr> specification.
  
  If C<Blocking> is set to 0, the connection will be in nonblocking mode.
  If not specified it defaults to 1 (blocking mode).
  
  Examples:
  
     $sock = IO::Socket::INET->new(PeerAddr => 'www.perl.org',
                                   PeerPort => 'http(80)',
                                   Proto    => 'tcp');
  
     $sock = IO::Socket::INET->new(PeerAddr => 'localhost:smtp(25)');
  
     $sock = IO::Socket::INET->new(Listen    => 5,
                                   LocalAddr => 'localhost',
                                   LocalPort => 9000,
                                   Proto     => 'tcp');
  
     $sock = IO::Socket::INET->new('127.0.0.1:25');
  
     $sock = IO::Socket::INET->new(
                             PeerPort  => 9999,
                             PeerAddr  => inet_ntoa(INADDR_BROADCAST),
                             Proto     => 'udp',
                             LocalAddr => 'localhost',
                             Broadcast => 1 ) 
                         or die "Can't bind : $IO::Socket::errstr\n";
  
  If the constructor fails it will return C<undef> and set the
  C<$IO::Socket::errstr> package variable to contain an error message.
  
      $sock = IO::Socket::INET->new(...)
          or die "Cannot create socket - $IO::Socket::errstr\n";
  
  For legacy reasons the error message is also set into the global C<$@>
  variable, and you may still find older code which looks here instead.
  
      $sock = IO::Socket::INET->new(...)
          or die "Cannot create socket - $@\n";
  
  =back
  
  =head2 METHODS
  
  =over 4
  
  =item sockaddr ()
  
  Return the address part of the sockaddr structure for the socket
  
  =item sockport ()
  
  Return the port number that the socket is using on the local host
  
  =item sockhost ()
  
  Return the address part of the sockaddr structure for the socket in a
  text form xx.xx.xx.xx
  
  =item peeraddr ()
  
  Return the address part of the sockaddr structure for the socket on
  the peer host
  
  =item peerport ()
  
  Return the port number for the socket on the peer host.
  
  =item peerhost ()
  
  Return the address part of the sockaddr structure for the socket on the
  peer host in a text form xx.xx.xx.xx
  
  =back
  
  =head1 SEE ALSO
  
  L<Socket>, L<IO::Socket>
  
  =head1 AUTHOR
  
  Graham Barr. Currently maintained by the Perl Porters.  Please report all
  bugs at L<https://github.com/Perl/perl5/issues>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_IO_SOCKET_INET

$fatpacked{"x86_64-linux-gnu-thread-multi/IO/Socket/UNIX.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_IO_SOCKET_UNIX';
  # IO::Socket::UNIX.pm
  #
  # Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package IO::Socket::UNIX;
  
  use strict;
  use IO::Socket;
  use Carp;
  
  our @ISA = qw(IO::Socket);
  our $VERSION = "1.49";
  
  IO::Socket::UNIX->register_domain( AF_UNIX );
  
  sub new {
      my $class = shift;
      unshift(@_, "Peer") if @_ == 1;
      return $class->SUPER::new(@_);
  }
  
  sub configure {
      my($sock,$arg) = @_;
      my($bport,$cport);
  
      my $type = $arg->{Type} || SOCK_STREAM;
  
      $sock->socket(AF_UNIX, $type, 0) or
  	return undef;
  
      if(exists $arg->{Blocking}) {
          $sock->blocking($arg->{Blocking}) or
  	    return undef;
      }
      if(exists $arg->{Local}) {
  	my $addr = sockaddr_un($arg->{Local});
  	$sock->bind($addr) or
  	    return undef;
      }
      if(exists $arg->{Listen} && $type != SOCK_DGRAM) {
  	$sock->listen($arg->{Listen} || 5) or
  	    return undef;
      }
      elsif(exists $arg->{Peer}) {
  	my $addr = sockaddr_un($arg->{Peer});
  	$sock->connect($addr) or
  	    return undef;
      }
  
      $sock;
  }
  
  sub hostpath {
      @_ == 1 or croak 'usage: $sock->hostpath()';
      my $n = $_[0]->sockname || return undef;
      (sockaddr_un($n))[0];
  }
  
  sub peerpath {
      @_ == 1 or croak 'usage: $sock->peerpath()';
      my $n = $_[0]->peername || return undef;
      (sockaddr_un($n))[0];
  }
  
  1; # Keep require happy
  
  __END__
  
  =head1 NAME
  
  IO::Socket::UNIX - Object interface for AF_UNIX domain sockets
  
  =head1 SYNOPSIS
  
      use IO::Socket::UNIX;
  
      my $SOCK_PATH = "$ENV{HOME}/unix-domain-socket-test.sock";
  
      # Server:
      my $server = IO::Socket::UNIX->new(
          Type => SOCK_STREAM(),
          Local => $SOCK_PATH,
          Listen => 1,
      );
  
      my $count = 1;
      while (my $conn = $server->accept()) {
          $conn->print("Hello " . ($count++) . "\n");
      }
  
      # Client:
      my $client = IO::Socket::UNIX->new(
          Type => SOCK_STREAM(),
          Peer => $SOCK_PATH,
      );
  
      # Now read and write from $client
  
  =head1 DESCRIPTION
  
  C<IO::Socket::UNIX> provides an object interface to creating and using sockets
  in the AF_UNIX domain. It is built upon the L<IO::Socket> interface and
  inherits all the methods defined by L<IO::Socket>.
  
  =head1 CONSTRUCTOR
  
  =over 4
  
  =item new ( [ARGS] )
  
  Creates an C<IO::Socket::UNIX> object, which is a reference to a
  newly created symbol (see the C<Symbol> package). C<new>
  optionally takes arguments, these arguments are in key-value pairs.
  
  In addition to the key-value pairs accepted by L<IO::Socket>,
  C<IO::Socket::UNIX> provides.
  
      Type    	Type of socket (eg SOCK_STREAM or SOCK_DGRAM)
      Local   	Path to local fifo
      Peer    	Path to peer fifo
      Listen  	Queue size for listen
  
  If the constructor is only passed a single argument, it is assumed to
  be a C<Peer> specification.
  
  If the C<Listen> argument is given, but false, the queue size will be set to 5.
  
  If the constructor fails it will return C<undef> and set the
  C<$IO::Socket::errstr> package variable to contain an error message.
  
      $sock = IO::Socket::UNIX->new(...)
          or die "Cannot create socket - $IO::Socket::errstr\n";
  
  For legacy reasons the error message is also set into the global C<$@>
  variable, and you may still find older code which looks here instead.
  
      $sock = IO::Socket::UNIX->new(...)
          or die "Cannot create socket - $@\n";
  
  =back
  
  =head1 METHODS
  
  =over 4
  
  =item hostpath()
  
  Returns the pathname to the fifo at the local end
  
  =item peerpath()
  
  Returns the pathanme to the fifo at the peer end
  
  =back
  
  =head1 SEE ALSO
  
  L<Socket>, L<IO::Socket>
  
  =head1 AUTHOR
  
  Graham Barr. Currently maintained by the Perl Porters.  Please report all
  bugs at L<https://github.com/Perl/perl5/issues>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_IO_SOCKET_UNIX

$fatpacked{"x86_64-linux-gnu-thread-multi/List/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_LIST_UTIL';
  # Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package List::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA        = qw(Exporter);
  our @EXPORT_OK  = qw(
    all any first min max minstr maxstr none notall product reduce reductions sum sum0
    sample shuffle uniq uniqint uniqnum uniqstr zip zip_longest zip_shortest mesh mesh_longest mesh_shortest
    head tail pairs unpairs pairkeys pairvalues pairmap pairgrep pairfirst
  );
  our $VERSION    = "1.63";
  our $XS_VERSION = $VERSION;
  $VERSION =~ tr/_//d;
  
  require XSLoader;
  XSLoader::load('List::Util', $XS_VERSION);
  
  # Used by shuffle()
  our $RAND;
  
  sub import
  {
    my $pkg = caller;
  
    # (RT88848) Touch the caller's $a and $b, to avoid the warning of
    #   Name "main::a" used only once: possible typo" warning
    no strict 'refs';
    ${"${pkg}::a"} = ${"${pkg}::a"};
    ${"${pkg}::b"} = ${"${pkg}::b"};
  
    goto &Exporter::import;
  }
  
  # For objects returned by pairs()
  sub List::Util::_Pair::key   { shift->[0] }
  sub List::Util::_Pair::value { shift->[1] }
  sub List::Util::_Pair::TO_JSON { [ @{+shift} ] }
  
  =head1 NAME
  
  List::Util - A selection of general-utility list subroutines
  
  =head1 SYNOPSIS
  
      use List::Util qw(
        reduce any all none notall first reductions
  
        max maxstr min minstr product sum sum0
  
        pairs unpairs pairkeys pairvalues pairfirst pairgrep pairmap
  
        shuffle uniq uniqint uniqnum uniqstr zip mesh
      );
  
  =head1 DESCRIPTION
  
  C<List::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size so small such that being
  individual extensions would be wasteful.
  
  By default C<List::Util> does not export any subroutines.
  
  =cut
  
  =head1 LIST-REDUCTION FUNCTIONS
  
  The following set of functions all apply a given block of code to a list of
  values.
  
  =cut
  
  =head2 reduce
  
      $result = reduce { BLOCK } @list
  
  Reduces C<@list> by calling C<BLOCK> in a scalar context multiple times,
  setting C<$a> and C<$b> each time. The first call will be with C<$a> and C<$b>
  set to the first two elements of the list, subsequent calls will be done by
  setting C<$a> to the result of the previous call and C<$b> to the next element
  in the list.
  
  Returns the result of the last call to the C<BLOCK>. If C<@list> is empty then
  C<undef> is returned. If C<@list> only contains one element then that element
  is returned and C<BLOCK> is not executed.
  
  The following examples all demonstrate how C<reduce> could be used to implement
  the other list-reduction functions in this module. (They are not in fact
  implemented like this, but instead in a more efficient manner in individual C
  functions).
  
      $foo = reduce { defined($a)            ? $a :
                      $code->(local $_ = $b) ? $b :
                                               undef } undef, @list # first
  
      $foo = reduce { $a > $b ? $a : $b } 1..10       # max
      $foo = reduce { $a gt $b ? $a : $b } 'A'..'Z'   # maxstr
      $foo = reduce { $a < $b ? $a : $b } 1..10       # min
      $foo = reduce { $a lt $b ? $a : $b } 'aa'..'zz' # minstr
      $foo = reduce { $a + $b } 1 .. 10               # sum
      $foo = reduce { $a . $b } @bar                  # concat
  
      $foo = reduce { $a || $code->(local $_ = $b) } 0, @bar   # any
      $foo = reduce { $a && $code->(local $_ = $b) } 1, @bar   # all
      $foo = reduce { $a && !$code->(local $_ = $b) } 1, @bar  # none
      $foo = reduce { $a || !$code->(local $_ = $b) } 0, @bar  # notall
         # Note that these implementations do not fully short-circuit
  
  If your algorithm requires that C<reduce> produce an identity value, then make
  sure that you always pass that identity value as the first argument to prevent
  C<undef> being returned
  
    $foo = reduce { $a + $b } 0, @values;             # sum with 0 identity value
  
  The above example code blocks also suggest how to use C<reduce> to build a
  more efficient combined version of one of these basic functions and a C<map>
  block. For example, to find the total length of all the strings in a list,
  we could use
  
      $total = sum map { length } @strings;
  
  However, this produces a list of temporary integer values as long as the
  original list of strings, only to reduce it down to a single value again. We
  can compute the same result more efficiently by using C<reduce> with a code
  block that accumulates lengths by writing this instead as:
  
      $total = reduce { $a + length $b } 0, @strings
  
  The other scalar-returning list reduction functions are all specialisations of
  this generic idea.
  
  =head2 reductions
  
      @results = reductions { BLOCK } @list
  
  I<Since version 1.54.>
  
  Similar to C<reduce> except that it also returns the intermediate values along
  with the final result. As before, C<$a> is set to the first element of the
  given list, and the C<BLOCK> is then called once for remaining item in the
  list set into C<$b>, with the result being captured for return as well as
  becoming the new value for C<$a>.
  
  The returned list will begin with the initial value for C<$a>, followed by
  each return value from the block in order. The final value of the result will
  be identical to what the C<reduce> function would have returned given the same
  block and list.
  
      reduce     { "$a-$b" }  "a".."d"    # "a-b-c-d"
      reductions { "$a-$b" }  "a".."d"    # "a", "a-b", "a-b-c", "a-b-c-d"
  
  =head2 any
  
      my $bool = any { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<any> returns true if any element makes the C<BLOCK>
  return a true value. If C<BLOCK> never returns true or C<@list> was empty then
  it returns false.
  
  Many cases of using C<grep> in a conditional can be written using C<any>
  instead, as it can short-circuit after the first true result.
  
      if( any { length > 10 } @strings ) {
          # at least one string has more than 10 characters
      }
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 all
  
      my $bool = all { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any>, except that it requires all elements of the C<@list> to
  make the C<BLOCK> return true. If any element returns false, then it returns
  false. If the C<BLOCK> never returns false or the C<@list> was empty then it
  returns true.
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 none
  
  =head2 notall
  
      my $bool = none { BLOCK } @list;
  
      my $bool = notall { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any> and L</all>, but with the return sense inverted. C<none>
  returns true only if no value in the C<@list> causes the C<BLOCK> to return
  true, and C<notall> returns true only if not all of the values do.
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 first
  
      my $val = first { BLOCK } @list;
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<first> returns the first element where the result from
  C<BLOCK> is a true value. If C<BLOCK> never returns true or C<@list> was empty
  then C<undef> is returned.
  
      $foo = first { defined($_) } @list    # first defined value in @list
      $foo = first { $_ > $value } @list    # first value in @list which
                                            # is greater than $value
  
  =head2 max
  
      my $num = max @list;
  
  Returns the entry in the list with the highest numerical value. If the list is
  empty then C<undef> is returned.
  
      $foo = max 1..10                # 10
      $foo = max 3,9,12               # 12
      $foo = max @bar, @baz           # whatever
  
  =head2 maxstr
  
      my $str = maxstr @list;
  
  Similar to L</max>, but treats all the entries in the list as strings and
  returns the highest string as defined by the C<gt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = maxstr 'A'..'Z'          # 'Z'
      $foo = maxstr "hello","world"   # "world"
      $foo = maxstr @bar, @baz        # whatever
  
  =head2 min
  
      my $num = min @list;
  
  Similar to L</max> but returns the entry in the list with the lowest numerical
  value. If the list is empty then C<undef> is returned.
  
      $foo = min 1..10                # 1
      $foo = min 3,9,12               # 3
      $foo = min @bar, @baz           # whatever
  
  =head2 minstr
  
      my $str = minstr @list;
  
  Similar to L</min>, but treats all the entries in the list as strings and
  returns the lowest string as defined by the C<lt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = minstr 'A'..'Z'          # 'A'
      $foo = minstr "hello","world"   # "hello"
      $foo = minstr @bar, @baz        # whatever
  
  =head2 product
  
      my $num = product @list;
  
  I<Since version 1.35.>
  
  Returns the numerical product of all the elements in C<@list>. If C<@list> is
  empty then C<1> is returned.
  
      $foo = product 1..10            # 3628800
      $foo = product 3,9,12           # 324
  
  =head2 sum
  
      my $num_or_undef = sum @list;
  
  Returns the numerical sum of all the elements in C<@list>. For backwards
  compatibility, if C<@list> is empty then C<undef> is returned.
  
      $foo = sum 1..10                # 55
      $foo = sum 3,9,12               # 24
      $foo = sum @bar, @baz           # whatever
  
  =head2 sum0
  
      my $num = sum0 @list;
  
  I<Since version 1.26.>
  
  Similar to L</sum>, except this returns 0 when given an empty list, rather
  than C<undef>.
  
  =cut
  
  =head1 KEY/VALUE PAIR LIST FUNCTIONS
  
  The following set of functions, all inspired by L<List::Pairwise>, consume an
  even-sized list of pairs. The pairs may be key/value associations from a hash,
  or just a list of values. The functions will all preserve the original ordering
  of the pairs, and will not be confused by multiple pairs having the same "key"
  value - nor even do they require that the first of each pair be a plain string.
  
  B<NOTE>: At the time of writing, the following C<pair*> functions that take a
  block do not modify the value of C<$_> within the block, and instead operate
  using the C<$a> and C<$b> globals instead. This has turned out to be a poor
  design, as it precludes the ability to provide a C<pairsort> function. Better
  would be to pass pair-like objects as 2-element array references in C<$_>, in
  a style similar to the return value of the C<pairs> function. At some future
  version this behaviour may be added.
  
  Until then, users are alerted B<NOT> to rely on the value of C<$_> remaining
  unmodified between the outside and the inside of the control block. In
  particular, the following example is B<UNSAFE>:
  
   my @kvlist = ...
  
   foreach (qw( some keys here )) {
      my @items = pairgrep { $a eq $_ } @kvlist;
      ...
   }
  
  Instead, write this using a lexical variable:
  
   foreach my $key (qw( some keys here )) {
      my @items = pairgrep { $a eq $key } @kvlist;
      ...
   }
  
  =cut
  
  =head2 pairs
  
      my @pairs = pairs @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of C<ARRAY> references, each containing two items from the
  given list. It is a more efficient version of
  
      @pairs = pairmap { [ $a, $b ] } @kvlist
  
  It is most convenient to use in a C<foreach> loop, for example:
  
      foreach my $pair ( pairs @kvlist ) {
         my ( $key, $value ) = @$pair;
         ...
      }
  
  Since version C<1.39> these C<ARRAY> references are blessed objects,
  recognising the two methods C<key> and C<value>. The following code is
  equivalent:
  
      foreach my $pair ( pairs @kvlist ) {
         my $key   = $pair->key;
         my $value = $pair->value;
         ...
      }
  
  Since version C<1.51> they also have a C<TO_JSON> method to ease
  serialisation.
  
  =head2 unpairs
  
      my @kvlist = unpairs @pairs
  
  I<Since version 1.42.>
  
  The inverse function to C<pairs>; this function takes a list of C<ARRAY>
  references containing two elements each, and returns a flattened list of the
  two values from each of the pairs, in order. This is notionally equivalent to
  
      my @kvlist = map { @{$_}[0,1] } @pairs
  
  except that it is implemented more efficiently internally. Specifically, for
  any input item it will extract exactly two values for the output list; using
  C<undef> if the input array references are short.
  
  Between C<pairs> and C<unpairs>, a higher-order list function can be used to
  operate on the pairs as single scalars; such as the following near-equivalents
  of the other C<pair*> higher-order functions:
  
      @kvlist = unpairs grep { FUNC } pairs @kvlist
      # Like pairgrep, but takes $_ instead of $a and $b
  
      @kvlist = unpairs map { FUNC } pairs @kvlist
      # Like pairmap, but takes $_ instead of $a and $b
  
  Note however that these versions will not behave as nicely in scalar context.
  
  Finally, this technique can be used to implement a sort on a keyvalue pair
  list; e.g.:
  
      @kvlist = unpairs sort { $a->key cmp $b->key } pairs @kvlist
  
  =head2 pairkeys
  
      my @keys = pairkeys @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the first values of each of the pairs in the given list.
  It is a more efficient version of
  
      @keys = pairmap { $a } @kvlist
  
  =head2 pairvalues
  
      my @values = pairvalues @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the second values of each of the pairs in the given list.
  It is a more efficient version of
  
      @values = pairmap { $b } @kvlist
  
  =head2 pairgrep
  
      my @kvlist = pairgrep { BLOCK } @kvlist;
  
      my $count = pairgrep { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<grep> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns an even-sized list of those pairs for which the C<BLOCK> returned true
  in list context, or the count of the B<number of pairs> in scalar context.
  (Note, therefore, in scalar context that it returns a number half the size of
  the count of items it would have returned in list context).
  
      @subset = pairgrep { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairgrep> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairfirst
  
      my ( $key, $val ) = pairfirst { BLOCK } @kvlist;
  
      my $found = pairfirst { BLOCK } @kvlist;
  
  I<Since version 1.30.>
  
  Similar to the L</first> function, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the first pair of values from the list for which the C<BLOCK> returned
  true in list context, or an empty list of no such pair was found. In scalar
  context it returns a simple boolean value, rather than either the key or the
  value found.
  
      ( $key, $value ) = pairfirst { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairfirst> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairmap
  
      my @list = pairmap { BLOCK } @kvlist;
  
      my $count = pairmap { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<map> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in list
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the concatenation of all the values returned by the C<BLOCK> in list
  context, or the count of the number of items that would have been returned in
  scalar context.
  
      @result = pairmap { "The key $a has value $b" } @kvlist
  
  As with C<map> aliasing C<$_> to list elements, C<pairmap> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  See L</KNOWN BUGS> for a known-bug with C<pairmap>, and a workaround.
  
  =cut
  
  =head1 OTHER FUNCTIONS
  
  =cut
  
  =head2 shuffle
  
      my @values = shuffle @values;
  
  Returns the values of the input in a random order
  
      @cards = shuffle 0..51      # 0..51 in a random order
  
  This function is affected by the C<$RAND> variable.
  
  =cut
  
  =head2 sample
  
      my @items = sample $count, @values
  
  I<Since version 1.54.>
  
  Randomly select the given number of elements from the input list. Any given
  position in the input list will be selected at most once.
  
  If there are fewer than C<$count> items in the list then the function will
  return once all of them have been randomly selected; effectively the function
  behaves similarly to L</shuffle>.
  
  This function is affected by the C<$RAND> variable.
  
  =head2 uniq
  
      my @subset = uniq @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  DWIM-ish string equality or C<undef> test. Preserves the order of unique
  elements, and retains the first value of any duplicate set.
  
      my $count = uniq @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  The C<undef> value is treated by this function as distinct from the empty
  string, and no warning will be produced. It is left as-is in the returned
  list. Subsequent C<undef> values are still considered identical to the first,
  and will be removed.
  
  =head2 uniqint
  
      my @subset = uniqint @values
  
  I<Since version 1.55.>
  
  Filters a list of values to remove subsequent duplicates, as judged by an
  integer numerical equality test. Preserves the order of unique elements, and
  retains the first value of any duplicate set. Values in the returned list will
  be coerced into integers.
  
      my $count = uniqint @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other numerical operations treat it; it
  compares equal to zero but additionally produces a warning if such warnings
  are enabled (C<use warnings 'uninitialized';>). In addition, an C<undef> in
  the returned list is coerced into a numerical zero, so that the entire list of
  values returned by C<uniqint> are well-behaved as integers.
  
  =head2 uniqnum
  
      my @subset = uniqnum @values
  
  I<Since version 1.44.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  numerical equality test. Preserves the order of unique elements, and retains
  the first value of any duplicate set.
  
      my $count = uniqnum @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other numerical operations treat it; it
  compares equal to zero but additionally produces a warning if such warnings
  are enabled (C<use warnings 'uninitialized';>). In addition, an C<undef> in
  the returned list is coerced into a numerical zero, so that the entire list of
  values returned by C<uniqnum> are well-behaved as numbers.
  
  Note also that multiple IEEE C<NaN> values are treated as duplicates of
  each other, regardless of any differences in their payloads, and despite
  the fact that C<< 0+'NaN' == 0+'NaN' >> yields false.
  
  =head2 uniqstr
  
      my @subset = uniqstr @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  string equality test. Preserves the order of unique elements, and retains the
  first value of any duplicate set.
  
      my $count = uniqstr @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other string operations treat it; it
  compares equal to the empty string but additionally produces a warning if such
  warnings are enabled (C<use warnings 'uninitialized';>). In addition, an
  C<undef> in the returned list is coerced into an empty string, so that the
  entire list of values returned by C<uniqstr> are well-behaved as strings.
  
  =cut
  
  =head2 head
  
      my @values = head $size, @list;
  
  I<Since version 1.50.>
  
  Returns the first C<$size> elements from C<@list>. If C<$size> is negative, returns
  all but the last C<$size> elements from C<@list>.
  
      @result = head 2, qw( foo bar baz );
      # foo, bar
  
      @result = head -2, qw( foo bar baz );
      # foo
  
  =head2 tail
  
      my @values = tail $size, @list;
  
  I<Since version 1.50.>
  
  Returns the last C<$size> elements from C<@list>. If C<$size> is negative, returns
  all but the first C<$size> elements from C<@list>.
  
      @result = tail 2, qw( foo bar baz );
      # bar, baz
  
      @result = tail -2, qw( foo bar baz );
      # baz
  
  =head2 zip
  
      my @result = zip [1..3], ['a'..'c'];
      # [1, 'a'], [2, 'b'], [3, 'c']
  
  I<Since version 1.56.>
  
  Returns a list of array references, composed of elements from the given list
  of array references. Each array in the returned list is composed of elements
  at that corresponding position from each of the given input arrays. If any
  input arrays run out of elements before others, then C<undef> will be inserted
  into the result to fill in the gaps.
  
  The C<zip> function is particularly handy for iterating over multiple arrays
  at the same time with a C<foreach> loop, taking one element from each:
  
      foreach ( zip \@xs, \@ys, \@zs ) {
          my ($x, $y, $z) = @$_;
          ...
      }
  
  B<NOTE> to users of L<List::MoreUtils>: This function does not behave the same
  as C<List::MoreUtils::zip>, but is actually a non-prototyped equivalent to
  C<List::MoreUtils::zip_unflatten>. This function does not apply a prototype,
  so make sure to invoke it with references to arrays.
  
  For a function similar to the C<zip> function from C<List::MoreUtils>, see
  L<mesh>.
  
      my @result = zip_shortest ...
  
  A variation of the function that differs in how it behaves when given input
  arrays of differing lengths. C<zip_shortest> will stop as soon as any one of
  the input arrays run out of elements, discarding any remaining unused values
  from the others.
  
      my @result = zip_longest ...
  
  C<zip_longest> is an alias to the C<zip> function, provided simply to be
  explicit about that behaviour as compared to C<zip_shortest>.
  
  =head2 mesh
  
      my @result = mesh [1..3], ['a'..'c'];
      # (1, 'a', 2, 'b', 3, 'c')
  
  I<Since version 1.56.>
  
  Returns a list of items collected from elements of the given list of array
  references. Each section of items in the returned list is composed of elements
  at the corresponding position from each of the given input arrays. If any
  input arrays run out of elements before others, then C<undef> will be inserted
  into the result to fill in the gaps.
  
  This is similar to L<zip>, except that all of the ranges in the result are
  returned in one long flattened list, instead of being bundled into separate
  arrays.
  
  Because it returns a flat list of items, the C<mesh> function is particularly
  useful for building a hash out of two separate arrays of keys and values:
  
      my %hash = mesh \@keys, \@values;
  
      my $href = { mesh \@keys, \@values };
  
  B<NOTE> to users of L<List::MoreUtils>: This function is a non-prototyped
  equivalent to C<List::MoreUtils::mesh> or C<List::MoreUtils::zip> (themselves
  aliases of each other). This function does not apply a prototype, so make sure
  to invoke it with references to arrays.
  
      my @result = mesh_shortest ...
  
      my @result = mesh_longest ...
  
  These variations are similar to those of L<zip>, in that they differ in
  behaviour when one of the input lists runs out of elements before the others.
  
  =head1 CONFIGURATION VARIABLES
  
  =head2 $RAND
  
      local $List::Util::RAND = sub { ... };
  
  I<Since version 1.54.>
  
  This package variable is used by code which needs to generate random numbers
  (such as the L</shuffle> and L</sample> functions). If set to a CODE reference
  it provides an alternative to perl's builtin C<rand()> function. When a new
  random number is needed this function will be invoked with no arguments and is
  expected to return a floating-point value, of which only the fractional part
  will be used.
  
  =head1 KNOWN BUGS
  
  =head2 RT #95409
  
  L<https://rt.cpan.org/Ticket/Display.html?id=95409>
  
  If the block of code given to L</pairmap> contains lexical variables that are
  captured by a returned closure, and the closure is executed after the block
  has been re-used for the next iteration, these lexicals will not see the
  correct values. For example:
  
   my @subs = pairmap {
      my $var = "$a is $b";
      sub { print "$var\n" };
   } one => 1, two => 2, three => 3;
  
   $_->() for @subs;
  
  Will incorrectly print
  
   three is 3
   three is 3
   three is 3
  
  This is due to the performance optimisation of using C<MULTICALL> for the code
  block, which means that fresh SVs do not get allocated for each call to the
  block. Instead, the same SV is re-assigned for each iteration, and all the
  closures will share the value seen on the final iteration.
  
  To work around this bug, surround the code with a second set of braces. This
  creates an inner block that defeats the C<MULTICALL> logic, and does get fresh
  SVs allocated each time:
  
   my @subs = pairmap {
      {
         my $var = "$a is $b";
         sub { print "$var\n"; }
      }
   } one => 1, two => 2, three => 3;
  
  This bug only affects closures that are generated by the block but used
  afterwards. Lexical variables that are only used during the lifetime of the
  block's execution will take their individual values for each invocation, as
  normal.
  
  =head2 uniqnum() on oversized bignums
  
  Due to the way that C<uniqnum()> compares numbers, it cannot distinguish
  differences between bignums (especially bigints) that are too large to fit in
  the native platform types. For example,
  
   my $x = Math::BigInt->new( "1" x 100 );
   my $y = $x + 1;
  
   say for uniqnum( $x, $y );
  
  Will print just the value of C<$x>, believing that C<$y> is a numerically-
  equivalent value. This bug does not affect C<uniqstr()>, which will correctly
  observe that the two values stringify to different strings.
  
  =head1 SUGGESTED ADDITIONS
  
  The following are additions that have been requested, but I have been reluctant
  to add due to them being very simple to implement in perl
  
    # How many elements are true
  
    sub true { scalar grep { $_ } @_ }
  
    # How many elements are false
  
    sub false { scalar grep { !$_ } @_ }
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  Recent additions and current maintenance by
  Paul Evans, <leonerd@leonerd.org.uk>.
  
  =cut
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_LIST_UTIL

$fatpacked{"x86_64-linux-gnu-thread-multi/List/Util/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_LIST_UTIL_XS';
  package List::Util::XS;
  use strict;
  use warnings;
  use List::Util;
  
  our $VERSION = "1.63";       # FIXUP
  $VERSION =~ tr/_//d;         # FIXUP
  
  1;
  __END__
  
  =head1 NAME
  
  List::Util::XS - Indicate if List::Util was compiled with a C compiler
  
  =head1 SYNOPSIS
  
      use List::Util::XS 1.20;
  
  =head1 DESCRIPTION
  
  C<List::Util::XS> can be used as a dependency to ensure List::Util was
  installed using a C compiler and that the XS version is installed.
  
  During installation C<$List::Util::XS::VERSION> will be set to
  C<undef> if the XS was not compiled.
  
  Starting with release 1.23_03, Scalar-List-Util is B<always> using
  the XS implementation, but for backwards compatibility, we still
  ship the C<List::Util::XS> module which just loads C<List::Util>.
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_LIST_UTIL_XS

$fatpacked{"x86_64-linux-gnu-thread-multi/Scalar/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_SCALAR_UTIL';
  # Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package Scalar::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw(
    blessed refaddr reftype weaken unweaken isweak
  
    dualvar isdual isvstring looks_like_number openhandle readonly set_prototype
    tainted
  );
  our $VERSION    = "1.63";
  $VERSION =~ tr/_//d;
  
  require List::Util; # List::Util loads the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  # populating @EXPORT_FAIL is done in the XS code
  sub export_fail {
    if (grep { /^isvstring$/ } @_ ) {
      require Carp;
      Carp::croak("Vstrings are not implemented in this version of perl");
    }
  
    @_;
  }
  
  # set_prototype has been moved to Sub::Util with a different interface
  sub set_prototype(&$)
  {
    my ( $code, $proto ) = @_;
    return Sub::Util::set_prototype( $proto, $code );
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Scalar::Util - A selection of general-utility scalar subroutines
  
  =head1 SYNOPSIS
  
      use Scalar::Util qw(blessed dualvar isdual readonly refaddr reftype
                          tainted weaken isweak isvstring looks_like_number
                          set_prototype);
                          # and other useful utils appearing below
  
  =head1 DESCRIPTION
  
  C<Scalar::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size would be so small that 
  being individual extensions would be wasteful.
  
  By default C<Scalar::Util> does not export any subroutines.
  
  =head2 Core Perl C<builtin> Functions
  
  Many functions in this module have served as the inspiration for a new
  experimental facility in recent versions of Perl. From various development
  versions, starting at 5.35.7, equivalent functions to many of these utilities
  are available in the C<builtin::> package.
  
      use Scalar::Util qw(blessed);
  
      $class = blessed $obj;
  
      $class = builtin::blessed $obj;  # equivalent
  
  For more information, see the documentation on L<builtin>.
  
  =cut
  
  =head1 FUNCTIONS FOR REFERENCES
  
  The following functions all perform some useful activity on reference values.
  
  =head2 blessed
  
      my $pkg = blessed( $ref );
  
  If C<$ref> is a blessed reference, the name of the package that it is blessed
  into is returned. Otherwise C<undef> is returned.
  
      $scalar = "foo";
      $class  = blessed $scalar;           # undef
  
      $ref    = [];
      $class  = blessed $ref;              # undef
  
      $obj    = bless [], "Foo";
      $class  = blessed $obj;              # "Foo"
  
  Take care when using this function simply as a truth test (such as in
  C<if(blessed $ref)...>) because the package name C<"0"> is defined yet false.
  
  I<Since Perl version 5.35.7> an equivalent function is available as
  C<builtin::blessed>.
  
  =head2 refaddr
  
      my $addr = refaddr( $ref );
  
  If C<$ref> is reference, the internal memory address of the referenced value is
  returned as a plain integer. Otherwise C<undef> is returned.
  
      $addr = refaddr "string";           # undef
      $addr = refaddr \$var;              # eg 12345678
      $addr = refaddr [];                 # eg 23456784
  
      $obj  = bless {}, "Foo";
      $addr = refaddr $obj;               # eg 88123488
  
  I<Since Perl version 5.35.7> an equivalent function is available as
  C<builtin::refaddr>.
  
  =head2 reftype
  
      my $type = reftype( $ref );
  
  If C<$ref> is a reference, the basic Perl type of the variable referenced is
  returned as a plain string (such as C<ARRAY> or C<HASH>). Otherwise C<undef>
  is returned.
  
      $type = reftype "string";           # undef
      $type = reftype \$var;              # SCALAR
      $type = reftype [];                 # ARRAY
  
      $obj  = bless {}, "Foo";
      $type = reftype $obj;               # HASH
  
  Note that for internal reasons, all precompiled regexps (C<qr/.../>) are
  blessed references; thus C<ref()> returns the package name string C<"Regexp">
  on these but C<reftype()> will return the underlying C structure type of
  C<"REGEXP"> in all capitals.
  
  I<Since Perl version 5.35.7> an equivalent function is available as
  C<builtin::reftype>.
  
  =head2 weaken
  
      weaken( $ref );
  
  The lvalue C<$ref> will be turned into a weak reference. This means that it
  will not hold a reference count on the object it references. Also, when the
  reference count on that object reaches zero, the reference will be set to
  undef. This function mutates the lvalue passed as its argument and returns no
  value.
  
  This is useful for keeping copies of references, but you don't want to prevent
  the object being DESTROY-ed at its usual time.
  
      {
        my $var;
        $ref = \$var;
        weaken($ref);                     # Make $ref a weak reference
      }
      # $ref is now undef
  
  Note that if you take a copy of a scalar with a weakened reference, the copy
  will be a strong reference.
  
      my $var;
      my $foo = \$var;
      weaken($foo);                       # Make $foo a weak reference
      my $bar = $foo;                     # $bar is now a strong reference
  
  This may be less obvious in other situations, such as C<grep()>, for instance
  when grepping through a list of weakened references to objects that may have
  been destroyed already:
  
      @object = grep { defined } @object;
  
  This will indeed remove all references to destroyed objects, but the remaining
  references to objects will be strong, causing the remaining objects to never be
  destroyed because there is now always a strong reference to them in the @object
  array.
  
  I<Since Perl version 5.35.7> an equivalent function is available as
  C<builtin::weaken>.
  
  =head2 unweaken
  
      unweaken( $ref );
  
  I<Since version 1.36.>
  
  The lvalue C<REF> will be turned from a weak reference back into a normal
  (strong) reference again. This function mutates the lvalue passed as its
  argument and returns no value. This undoes the action performed by
  L</weaken>.
  
  This function is slightly neater and more convenient than the
  otherwise-equivalent code
  
      my $tmp = $REF;
      undef $REF;
      $REF = $tmp;
  
  (because in particular, simply assigning a weak reference back to itself does
  not work to unweaken it; C<$REF = $REF> does not work).
  
  I<Since Perl version 5.35.7> an equivalent function is available as
  C<builtin::unweaken>.
  
  =head2 isweak
  
      my $weak = isweak( $ref );
  
  Returns true if C<$ref> is a weak reference.
  
      $ref  = \$foo;
      $weak = isweak($ref);               # false
      weaken($ref);
      $weak = isweak($ref);               # true
  
  B<NOTE>: Copying a weak reference creates a normal, strong, reference.
  
      $copy = $ref;
      $weak = isweak($copy);              # false
  
  I<Since Perl version 5.35.7> an equivalent function is available as
  C<builtin::is_weak>.
  
  =head1 OTHER FUNCTIONS
  
  =head2 dualvar
  
      my $var = dualvar( $num, $string );
  
  Returns a scalar that has the value C<$num> in a numeric context and the value
  C<$string> in a string context.
  
      $foo = dualvar 10, "Hello";
      $num = $foo + 2;                    # 12
      $str = $foo . " world";             # Hello world
  
  =head2 isdual
  
      my $dual = isdual( $var );
  
  I<Since version 1.26.>
  
  If C<$var> is a scalar that has both numeric and string values, the result is
  true.
  
      $foo = dualvar 86, "Nix";
      $dual = isdual($foo);               # true
  
  Note that a scalar can be made to have both string and numeric content through
  standard operations:
  
      $foo = "10";
      $dual = isdual($foo);               # false
      $bar = $foo + 0;
      $dual = isdual($foo);               # true
  
  The C<$!> variable is commonly dual-valued, though it is also magical in other
  ways:
  
      $! = 1;
      $dual = isdual($!);                 # true
      print("$!\n");                      # "Operation not permitted"
  
  B<CAUTION>: This function is not as useful as it may seem. Dualvars are not a
  distinct concept in Perl, but a standard internal construct of all scalar
  values. Almost any value could be considered as a dualvar by this function
  through the course of normal operations.
  
  =head2 isvstring
  
      my $vstring = isvstring( $var );
  
  If C<$var> is a scalar which was coded as a vstring, the result is true.
  
      $vs   = v49.46.48;
      $fmt  = isvstring($vs) ? "%vd" : "%s"; #true
      printf($fmt,$vs);
  
  =head2 looks_like_number
  
      my $isnum = looks_like_number( $var );
  
  Returns true if perl thinks C<$var> is a number. See
  L<perlapi/looks_like_number>.
  
  =head2 openhandle
  
      my $fh = openhandle( $fh );
  
  Returns C<$fh> itself, if C<$fh> may be used as a filehandle and is open, or if
  it is a tied handle. Otherwise C<undef> is returned.
  
      $fh = openhandle(*STDIN);           # \*STDIN
      $fh = openhandle(\*STDIN);          # \*STDIN
      $fh = openhandle(*NOTOPEN);         # undef
      $fh = openhandle("scalar");         # undef
  
  =head2 readonly
  
      my $ro = readonly( $var );
  
  Returns true if C<$var> is readonly.
  
      sub foo { readonly($_[0]) }
  
      $readonly = foo($bar);              # false
      $readonly = foo(0);                 # true
  
  =head2 set_prototype
  
      my $code = set_prototype( $code, $prototype );
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
      set_prototype \&foo, '$$';
  
  =head2 tainted
  
      my $t = tainted( $var );
  
  Return true if C<$var> is tainted.
  
      $taint = tainted("constant");       # false
      $taint = tainted($ENV{PWD});        # true if running under -T
  
  =head1 DIAGNOSTICS
  
  Module use may give one of the following errors during import.
  
  =over
  
  =item Vstrings are not implemented in this version of perl
  
  The version of perl that you are using does not implement Vstrings, to use
  L</isvstring> you will need to use a newer release of perl.
  
  =back
  
  =head1 KNOWN BUGS
  
  There is a bug in perl5.6.0 with UV's that are >= 1<<31. This will
  show up as tests 8 and 9 of dualvar.t failing
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  Additionally L</weaken> and L</isweak> which are
  
  Copyright (c) 1999 Tuomas J. Lukka <lukka@iki.fi>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as perl itself.
  
  Copyright (C) 2004, 2008  Matthijs van Duin.  All rights reserved.
  Copyright (C) 2014 cPanel Inc.  All rights reserved.
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_SCALAR_UTIL

$fatpacked{"x86_64-linux-gnu-thread-multi/Socket.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_SOCKET';
  package Socket;
  
  use strict;
  { use v5.6.1; }
  
  our $VERSION = '2.036';
  
  =head1 NAME
  
  C<Socket> - networking constants and support functions
  
  =head1 SYNOPSIS
  
  C<Socket> a low-level module used by, among other things, the L<IO::Socket>
  family of modules. The following examples demonstrate some low-level uses but
  a practical program would likely use the higher-level API provided by
  C<IO::Socket> or similar instead.
  
   use Socket qw(PF_INET SOCK_STREAM pack_sockaddr_in inet_aton);
  
   socket(my $socket, PF_INET, SOCK_STREAM, 0)
       or die "socket: $!";
  
   my $port = getservbyname "echo", "tcp";
   connect($socket, pack_sockaddr_in($port, inet_aton("localhost")))
       or die "connect: $!";
  
   print $socket "Hello, world!\n";
   print <$socket>;
  
  See also the L</EXAMPLES> section.
  
  =head1 DESCRIPTION
  
  This module provides a variety of constants, structure manipulators and other
  functions related to socket-based networking. The values and functions
  provided are useful when used in conjunction with Perl core functions such as
  socket(), setsockopt() and bind(). It also provides several other support
  functions, mostly for dealing with conversions of network addresses between
  human-readable and native binary forms, and for hostname resolver operations.
  
  Some constants and functions are exported by default by this module; but for
  backward-compatibility any recently-added symbols are not exported by default
  and must be requested explicitly. When an import list is provided to the
  C<use Socket> line, the default exports are not automatically imported. It is
  therefore best practice to always to explicitly list all the symbols required.
  
  Also, some common socket "newline" constants are provided: the constants
  C<CR>, C<LF>, and C<CRLF>, as well as C<$CR>, C<$LF>, and C<$CRLF>, which map
  to C<\015>, C<\012>, and C<\015\012>. If you do not want to use the literal
  characters in your programs, then use the constants provided here. They are
  not exported by default, but can be imported individually, and with the
  C<:crlf> export tag:
  
   use Socket qw(:DEFAULT :crlf);
  
   $sock->print("GET / HTTP/1.0$CRLF");
  
  The entire getaddrinfo() subsystem can be exported using the tag C<:addrinfo>;
  this exports the getaddrinfo() and getnameinfo() functions, and all the
  C<AI_*>, C<NI_*>, C<NIx_*> and C<EAI_*> constants.
  
  =cut
  
  =head1 CONSTANTS
  
  In each of the following groups, there may be many more constants provided
  than just the ones given as examples in the section heading. If the heading
  ends C<...> then this means there are likely more; the exact constants
  provided will depend on the OS and headers found at compile-time.
  
  =cut
  
  =head2 PF_INET, PF_INET6, PF_UNIX, ...
  
  Protocol family constants to use as the first argument to socket() or the
  value of the C<SO_DOMAIN> or C<SO_FAMILY> socket option.
  
  =head2 AF_INET, AF_INET6, AF_UNIX, ...
  
  Address family constants used by the socket address structures, to pass to
  such functions as inet_pton() or getaddrinfo(), or are returned by such
  functions as sockaddr_family().
  
  =head2 SOCK_STREAM, SOCK_DGRAM, SOCK_RAW, ...
  
  Socket type constants to use as the second argument to socket(), or the value
  of the C<SO_TYPE> socket option.
  
  =head2 SOCK_NONBLOCK. SOCK_CLOEXEC
  
  Linux-specific shortcuts to specify the C<O_NONBLOCK> and C<FD_CLOEXEC> flags
  during a C<socket(2)> call.
  
   socket( my $sockh, PF_INET, SOCK_DGRAM|SOCK_NONBLOCK, 0 )
  
  =head2 SOL_SOCKET
  
  Socket option level constant for setsockopt() and getsockopt().
  
  =head2 SO_ACCEPTCONN, SO_BROADCAST, SO_ERROR, ...
  
  Socket option name constants for setsockopt() and getsockopt() at the
  C<SOL_SOCKET> level.
  
  =head2 IP_OPTIONS, IP_TOS, IP_TTL, ...
  
  Socket option name constants for IPv4 socket options at the C<IPPROTO_IP>
  level.
  
  =head2 IP_PMTUDISC_WANT, IP_PMTUDISC_DONT, ...
  
  Socket option value constants for C<IP_MTU_DISCOVER> socket option.
  
  =head2 IPTOS_LOWDELAY, IPTOS_THROUGHPUT, IPTOS_RELIABILITY, ...
  
  Socket option value constants for C<IP_TOS> socket option.
  
  =head2 MSG_BCAST, MSG_OOB, MSG_TRUNC, ...
  
  Message flag constants for send() and recv().
  
  =head2 SHUT_RD, SHUT_RDWR, SHUT_WR
  
  Direction constants for shutdown().
  
  =head2 INADDR_ANY, INADDR_BROADCAST, INADDR_LOOPBACK, INADDR_NONE
  
  Constants giving the special C<AF_INET> addresses for wildcard, broadcast,
  local loopback, and invalid addresses.
  
  Normally equivalent to inet_aton('0.0.0.0'), inet_aton('255.255.255.255'),
  inet_aton('localhost') and inet_aton('255.255.255.255') respectively.
  
  =head2 IPPROTO_IP, IPPROTO_IPV6, IPPROTO_TCP, ...
  
  IP protocol constants to use as the third argument to socket(), the level
  argument to getsockopt() or setsockopt(), or the value of the C<SO_PROTOCOL>
  socket option.
  
  =head2 TCP_CORK, TCP_KEEPALIVE, TCP_NODELAY, ...
  
  Socket option name constants for TCP socket options at the C<IPPROTO_TCP>
  level.
  
  =head2 IN6ADDR_ANY, IN6ADDR_LOOPBACK
  
  Constants giving the special C<AF_INET6> addresses for wildcard and local
  loopback.
  
  Normally equivalent to inet_pton(AF_INET6, "::") and
  inet_pton(AF_INET6, "::1") respectively.
  
  =head2 IPV6_ADD_MEMBERSHIP, IPV6_MTU, IPV6_V6ONLY, ...
  
  Socket option name constants for IPv6 socket options at the C<IPPROTO_IPV6>
  level.
  
  =cut
  
  # Still undocumented: SCM_*, SOMAXCONN, IOV_MAX, UIO_MAXIOV
  
  =head1 STRUCTURE MANIPULATORS
  
  The following functions convert between lists of Perl values and packed binary
  strings representing structures.
  
  =cut
  
  =head2 $family = sockaddr_family $sockaddr
  
  Takes a packed socket address (as returned by pack_sockaddr_in(),
  pack_sockaddr_un() or the perl builtin functions getsockname() and
  getpeername()). Returns the address family tag. This will be one of the
  C<AF_*> constants, such as C<AF_INET> for a C<sockaddr_in> addresses or
  C<AF_UNIX> for a C<sockaddr_un>. It can be used to figure out what unpack to
  use for a sockaddr of unknown type.
  
  =head2 $sockaddr = pack_sockaddr_in $port, $ip_address
  
  Takes two arguments, a port number and an opaque string (as returned by
  inet_aton(), or a v-string). Returns the C<sockaddr_in> structure with those
  arguments packed in and C<AF_INET> filled in. For Internet domain sockets,
  this structure is normally what you need for the arguments in bind(),
  connect(), and send().
  
  An undefined $port argument is taken as zero; an undefined $ip_address is
  considered a fatal error.
  
  =head2 ($port, $ip_address) = unpack_sockaddr_in $sockaddr
  
  Takes a C<sockaddr_in> structure (as returned by pack_sockaddr_in(),
  getpeername() or recv()). Returns a list of two elements: the port and an
  opaque string representing the IP address (you can use inet_ntoa() to convert
  the address to the four-dotted numeric format). Will croak if the structure
  does not represent an C<AF_INET> address.
  
  In scalar context will return just the IP address.
  
  =head2 $sockaddr = sockaddr_in $port, $ip_address
  
  =head2 ($port, $ip_address) = sockaddr_in $sockaddr
  
  A wrapper of pack_sockaddr_in() or unpack_sockaddr_in(). In list context,
  unpacks its argument and returns a list consisting of the port and IP address.
  In scalar context, packs its port and IP address arguments as a C<sockaddr_in>
  and returns it.
  
  Provided largely for legacy compatibility; it is better to use
  pack_sockaddr_in() or unpack_sockaddr_in() explicitly.
  
  =head2 $sockaddr = pack_sockaddr_in6 $port, $ip6_address, [$scope_id, [$flowinfo]]
  
  Takes two to four arguments, a port number, an opaque string (as returned by
  inet_pton()), optionally a scope ID number, and optionally a flow label
  number. Returns the C<sockaddr_in6> structure with those arguments packed in
  and C<AF_INET6> filled in. IPv6 equivalent of pack_sockaddr_in().
  
  An undefined $port argument is taken as zero; an undefined $ip6_address is
  considered a fatal error.
  
  =head2 ($port, $ip6_address, $scope_id, $flowinfo) = unpack_sockaddr_in6 $sockaddr
  
  Takes a C<sockaddr_in6> structure. Returns a list of four elements: the port
  number, an opaque string representing the IPv6 address, the scope ID, and the
  flow label. (You can use inet_ntop() to convert the address to the usual
  string format). Will croak if the structure does not represent an C<AF_INET6>
  address.
  
  In scalar context will return just the IP address.
  
  =head2 $sockaddr = sockaddr_in6 $port, $ip6_address, [$scope_id, [$flowinfo]]
  
  =head2 ($port, $ip6_address, $scope_id, $flowinfo) = sockaddr_in6 $sockaddr
  
  A wrapper of pack_sockaddr_in6() or unpack_sockaddr_in6(). In list context,
  unpacks its argument according to unpack_sockaddr_in6(). In scalar context,
  packs its arguments according to pack_sockaddr_in6().
  
  Provided largely for legacy compatibility; it is better to use
  pack_sockaddr_in6() or unpack_sockaddr_in6() explicitly.
  
  =head2 $sockaddr = pack_sockaddr_un $path
  
  Takes one argument, a pathname. Returns the C<sockaddr_un> structure with that
  path packed in with C<AF_UNIX> filled in. For C<PF_UNIX> sockets, this
  structure is normally what you need for the arguments in bind(), connect(),
  and send().
  
  =head2 ($path) = unpack_sockaddr_un $sockaddr
  
  Takes a C<sockaddr_un> structure (as returned by pack_sockaddr_un(),
  getpeername() or recv()). Returns a list of one element: the pathname. Will
  croak if the structure does not represent an C<AF_UNIX> address.
  
  =head2 $sockaddr = sockaddr_un $path
  
  =head2 ($path) = sockaddr_un $sockaddr
  
  A wrapper of pack_sockaddr_un() or unpack_sockaddr_un(). In a list context,
  unpacks its argument and returns a list consisting of the pathname. In a
  scalar context, packs its pathname as a C<sockaddr_un> and returns it.
  
  Provided largely for legacy compatibility; it is better to use
  pack_sockaddr_un() or unpack_sockaddr_un() explicitly.
  
  These are only supported if your system has E<lt>F<sys/un.h>E<gt>.
  
  =head2 $ip_mreq = pack_ip_mreq $multiaddr, $interface
  
  Takes an IPv4 multicast address and optionally an interface address (or
  C<INADDR_ANY>). Returns the C<ip_mreq> structure with those arguments packed
  in. Suitable for use with the C<IP_ADD_MEMBERSHIP> and C<IP_DROP_MEMBERSHIP>
  sockopts.
  
  =head2 ($multiaddr, $interface) = unpack_ip_mreq $ip_mreq
  
  Takes an C<ip_mreq> structure. Returns a list of two elements; the IPv4
  multicast address and interface address.
  
  =head2 $ip_mreq_source = pack_ip_mreq_source $multiaddr, $source, $interface
  
  Takes an IPv4 multicast address, source address, and optionally an interface
  address (or C<INADDR_ANY>). Returns the C<ip_mreq_source> structure with those
  arguments packed in. Suitable for use with the C<IP_ADD_SOURCE_MEMBERSHIP>
  and C<IP_DROP_SOURCE_MEMBERSHIP> sockopts.
  
  =head2 ($multiaddr, $source, $interface) = unpack_ip_mreq_source $ip_mreq
  
  Takes an C<ip_mreq_source> structure. Returns a list of three elements; the
  IPv4 multicast address, source address and interface address.
  
  =head2 $ipv6_mreq = pack_ipv6_mreq $multiaddr6, $ifindex
  
  Takes an IPv6 multicast address and an interface number. Returns the
  C<ipv6_mreq> structure with those arguments packed in. Suitable for use with
  the C<IPV6_ADD_MEMBERSHIP> and C<IPV6_DROP_MEMBERSHIP> sockopts.
  
  =head2 ($multiaddr6, $ifindex) = unpack_ipv6_mreq $ipv6_mreq
  
  Takes an C<ipv6_mreq> structure. Returns a list of two elements; the IPv6
  address and an interface number.
  
  =cut
  
  =head1 FUNCTIONS
  
  =cut
  
  =head2 $ip_address = inet_aton $string
  
  Takes a string giving the name of a host, or a textual representation of an IP
  address and translates that to an packed binary address structure suitable to
  pass to pack_sockaddr_in(). If passed a hostname that cannot be resolved,
  returns C<undef>. For multi-homed hosts (hosts with more than one address),
  the first address found is returned.
  
  For portability do not assume that the result of inet_aton() is 32 bits wide,
  in other words, that it would contain only the IPv4 address in network order.
  
  This IPv4-only function is provided largely for legacy reasons. Newly-written
  code should use getaddrinfo() or inet_pton() instead for IPv6 support.
  
  =head2 $string = inet_ntoa $ip_address
  
  Takes a packed binary address structure such as returned by
  unpack_sockaddr_in() (or a v-string representing the four octets of the IPv4
  address in network order) and translates it into a string of the form
  C<d.d.d.d> where the C<d>s are numbers less than 256 (the normal
  human-readable four dotted number notation for Internet addresses).
  
  This IPv4-only function is provided largely for legacy reasons. Newly-written
  code should use getnameinfo() or inet_ntop() instead for IPv6 support.
  
  =head2 $address = inet_pton $family, $string
  
  Takes an address family (such as C<AF_INET> or C<AF_INET6>) and a string
  containing a textual representation of an address in that family and
  translates that to an packed binary address structure.
  
  See also getaddrinfo() for a more powerful and flexible function to look up
  socket addresses given hostnames or textual addresses.
  
  =head2 $string = inet_ntop $family, $address
  
  Takes an address family and a packed binary address structure and translates
  it into a human-readable textual representation of the address; typically in
  C<d.d.d.d> form for C<AF_INET> or C<hhhh:hhhh::hhhh> form for C<AF_INET6>.
  
  See also getnameinfo() for a more powerful and flexible function to turn
  socket addresses into human-readable textual representations.
  
  =head2 ($err, @result) = getaddrinfo $host, $service, [$hints]
  
  Given both a hostname and service name, this function attempts to resolve the
  host name into a list of network addresses, and the service name into a
  protocol and port number, and then returns a list of address structures
  suitable to connect() to it.
  
  Given just a host name, this function attempts to resolve it to a list of
  network addresses, and then returns a list of address structures giving these
  addresses.
  
  Given just a service name, this function attempts to resolve it to a protocol
  and port number, and then returns a list of address structures that represent
  it suitable to bind() to. This use should be combined with the C<AI_PASSIVE>
  flag; see below.
  
  Given neither name, it generates an error.
  
  If present, $hints should be a reference to a hash, where the following keys
  are recognised:
  
  =over 4
  
  =item flags => INT
  
  A bitfield containing C<AI_*> constants; see below.
  
  =item family => INT
  
  Restrict to only generating addresses in this address family
  
  =item socktype => INT
  
  Restrict to only generating addresses of this socket type
  
  =item protocol => INT
  
  Restrict to only generating addresses for this protocol
  
  =back
  
  The return value will be a list; the first value being an error indication,
  followed by a list of address structures (if no error occurred).
  
  The error value will be a dualvar; comparable to the C<EAI_*> error constants,
  or printable as a human-readable error message string. If no error occurred it
  will be zero numerically and an empty string.
  
  Each value in the results list will be a hash reference containing the following
  fields:
  
  =over 4
  
  =item family => INT
  
  The address family (e.g. C<AF_INET>)
  
  =item socktype => INT
  
  The socket type (e.g. C<SOCK_STREAM>)
  
  =item protocol => INT
  
  The protocol (e.g. C<IPPROTO_TCP>)
  
  =item addr => STRING
  
  The address in a packed string (such as would be returned by
  pack_sockaddr_in())
  
  =item canonname => STRING
  
  The canonical name for the host if the C<AI_CANONNAME> flag was provided, or
  C<undef> otherwise. This field will only be present on the first returned
  address.
  
  =back
  
  The following flag constants are recognised in the $hints hash. Other flag
  constants may exist as provided by the OS.
  
  =over 4
  
  =item AI_PASSIVE
  
  Indicates that this resolution is for a local bind() for a passive (i.e.
  listening) socket, rather than an active (i.e. connecting) socket.
  
  =item AI_CANONNAME
  
  Indicates that the caller wishes the canonical hostname (C<canonname>) field
  of the result to be filled in.
  
  =item AI_NUMERICHOST
  
  Indicates that the caller will pass a numeric address, rather than a hostname,
  and that getaddrinfo() must not perform a resolve operation on this name. This
  flag will prevent a possibly-slow network lookup operation, and instead return
  an error if a hostname is passed.
  
  =back
  
  =head2 ($err, $hostname, $servicename) = getnameinfo $sockaddr, [$flags, [$xflags]]
  
  Given a packed socket address (such as from getsockname(), getpeername(), or
  returned by getaddrinfo() in a C<addr> field), returns the hostname and
  symbolic service name it represents. $flags may be a bitmask of C<NI_*>
  constants, or defaults to 0 if unspecified.
  
  The return value will be a list; the first value being an error condition,
  followed by the hostname and service name.
  
  The error value will be a dualvar; comparable to the C<EAI_*> error constants,
  or printable as a human-readable error message string. The host and service
  names will be plain strings.
  
  The following flag constants are recognised as $flags. Other flag constants may
  exist as provided by the OS.
  
  =over 4
  
  =item NI_NUMERICHOST
  
  Requests that a human-readable string representation of the numeric address be
  returned directly, rather than performing a name resolve operation that may
  convert it into a hostname. This will also avoid potentially-blocking network
  IO.
  
  =item NI_NUMERICSERV
  
  Requests that the port number be returned directly as a number representation
  rather than performing a name resolve operation that may convert it into a
  service name.
  
  =item NI_NAMEREQD
  
  If a name resolve operation fails to provide a name, then this flag will cause
  getnameinfo() to indicate an error, rather than returning the numeric
  representation as a human-readable string.
  
  =item NI_DGRAM
  
  Indicates that the socket address relates to a C<SOCK_DGRAM> socket, for the
  services whose name differs between TCP and UDP protocols.
  
  =back
  
  The following constants may be supplied as $xflags.
  
  =over 4
  
  =item NIx_NOHOST
  
  Indicates that the caller is not interested in the hostname of the result, so
  it does not have to be converted. C<undef> will be returned as the hostname.
  
  =item NIx_NOSERV
  
  Indicates that the caller is not interested in the service name of the result,
  so it does not have to be converted. C<undef> will be returned as the service
  name.
  
  =back
  
  =head1 getaddrinfo() / getnameinfo() ERROR CONSTANTS
  
  The following constants may be returned by getaddrinfo() or getnameinfo().
  Others may be provided by the OS.
  
  =over 4
  
  =item EAI_AGAIN
  
  A temporary failure occurred during name resolution. The operation may be
  successful if it is retried later.
  
  =item EAI_BADFLAGS
  
  The value of the C<flags> hint to getaddrinfo(), or the $flags parameter to
  getnameinfo() contains unrecognised flags.
  
  =item EAI_FAMILY
  
  The C<family> hint to getaddrinfo(), or the family of the socket address
  passed to getnameinfo() is not supported.
  
  =item EAI_NODATA
  
  The host name supplied to getaddrinfo() did not provide any usable address
  data.
  
  =item EAI_NONAME
  
  The host name supplied to getaddrinfo() does not exist, or the address
  supplied to getnameinfo() is not associated with a host name and the
  C<NI_NAMEREQD> flag was supplied.
  
  =item EAI_SERVICE
  
  The service name supplied to getaddrinfo() is not available for the socket
  type given in the $hints.
  
  =back
  
  =cut
  
  =head1 EXAMPLES
  
  =head2 Lookup for connect()
  
  The getaddrinfo() function converts a hostname and a service name into a list
  of structures, each containing a potential way to connect() to the named
  service on the named host.
  
   use IO::Socket;
   use Socket qw(SOCK_STREAM getaddrinfo);
  
   my %hints = (socktype => SOCK_STREAM);
   my ($err, @res) = getaddrinfo("localhost", "echo", \%hints);
   die "Cannot getaddrinfo - $err" if $err;
  
   my $sock;
  
   foreach my $ai (@res) {
       my $candidate = IO::Socket->new();
  
       $candidate->socket($ai->{family}, $ai->{socktype}, $ai->{protocol})
           or next;
  
       $candidate->connect($ai->{addr})
           or next;
  
       $sock = $candidate;
       last;
   }
  
   die "Cannot connect to localhost:echo" unless $sock;
  
   $sock->print("Hello, world!\n");
   print <$sock>;
  
  Because a list of potential candidates is returned, the C<while> loop tries
  each in turn until it finds one that succeeds both the socket() and connect()
  calls.
  
  This function performs the work of the legacy functions gethostbyname(),
  getservbyname(), inet_aton() and pack_sockaddr_in().
  
  In practice this logic is better performed by L<IO::Socket::IP>.
  
  =head2 Making a human-readable string out of an address
  
  The getnameinfo() function converts a socket address, such as returned by
  getsockname() or getpeername(), into a pair of human-readable strings
  representing the address and service name.
  
   use IO::Socket::IP;
   use Socket qw(getnameinfo);
  
   my $server = IO::Socket::IP->new(LocalPort => 12345, Listen => 1) or
       die "Cannot listen - $@";
  
   my $socket = $server->accept or die "accept: $!";
  
   my ($err, $hostname, $servicename) = getnameinfo($socket->peername);
   die "Cannot getnameinfo - $err" if $err;
  
   print "The peer is connected from $hostname\n";
  
  Since in this example only the hostname was used, the redundant conversion of
  the port number into a service name may be omitted by passing the
  C<NIx_NOSERV> flag.
  
   use Socket qw(getnameinfo NIx_NOSERV);
  
   my ($err, $hostname) = getnameinfo($socket->peername, 0, NIx_NOSERV);
  
  This function performs the work of the legacy functions unpack_sockaddr_in(),
  inet_ntoa(), gethostbyaddr() and getservbyport().
  
  In practice this logic is better performed by L<IO::Socket::IP>.
  
  =head2 Resolving hostnames into IP addresses
  
  To turn a hostname into a human-readable plain IP address use getaddrinfo()
  to turn the hostname into a list of socket structures, then getnameinfo() on
  each one to make it a readable IP address again.
  
   use Socket qw(:addrinfo SOCK_RAW);
  
   my ($err, @res) = getaddrinfo($hostname, "", {socktype => SOCK_RAW});
   die "Cannot getaddrinfo - $err" if $err;
  
   while( my $ai = shift @res ) {
       my ($err, $ipaddr) = getnameinfo($ai->{addr}, NI_NUMERICHOST, NIx_NOSERV);
       die "Cannot getnameinfo - $err" if $err;
  
       print "$ipaddr\n";
   }
  
  The C<socktype> hint to getaddrinfo() filters the results to only include one
  socket type and protocol. Without this most OSes return three combinations,
  for C<SOCK_STREAM>, C<SOCK_DGRAM> and C<SOCK_RAW>, resulting in triplicate
  output of addresses. The C<NI_NUMERICHOST> flag to getnameinfo() causes it to
  return a string-formatted plain IP address, rather than reverse resolving it
  back into a hostname.
  
  This combination performs the work of the legacy functions gethostbyname()
  and inet_ntoa().
  
  =head2 Accessing socket options
  
  The many C<SO_*> and other constants provide the socket option names for
  getsockopt() and setsockopt().
  
   use IO::Socket::INET;
   use Socket qw(SOL_SOCKET SO_RCVBUF IPPROTO_IP IP_TTL);
  
   my $socket = IO::Socket::INET->new(LocalPort => 0, Proto => 'udp')
       or die "Cannot create socket: $@";
  
   $socket->setsockopt(SOL_SOCKET, SO_RCVBUF, 64*1024) or
       die "setsockopt: $!";
  
   print "Receive buffer is ", $socket->getsockopt(SOL_SOCKET, SO_RCVBUF),
       " bytes\n";
  
   print "IP TTL is ", $socket->getsockopt(IPPROTO_IP, IP_TTL), "\n";
  
  As a convenience, L<IO::Socket>'s setsockopt() method will convert a number
  into a packed byte buffer, and getsockopt() will unpack a byte buffer of the
  correct size back into a number.
  
  =cut
  
  =head1 AUTHOR
  
  This module was originally maintained in Perl core by the Perl 5 Porters.
  
  It was extracted to dual-life on CPAN at version 1.95 by
  Paul Evans <leonerd@leonerd.org.uk>
  
  =cut
  
  use Carp;
  use warnings::register;
  
  require Exporter;
  require XSLoader;
  our @ISA = qw(Exporter);
  
  # <@Nicholas> you can't change @EXPORT without breaking the implicit API
  # Please put any new constants in @EXPORT_OK!
  
  # List re-ordered to match documentation above. Try to keep the ordering
  # consistent so it's easier to see which ones are or aren't documented.
  our @EXPORT = qw(
  	PF_802 PF_AAL PF_APPLETALK PF_CCITT PF_CHAOS PF_CTF PF_DATAKIT
  	PF_DECnet PF_DLI PF_ECMA PF_GOSIP PF_HYLINK PF_IMPLINK PF_INET PF_INET6
  	PF_ISO PF_KEY PF_LAST PF_LAT PF_LINK PF_MAX PF_NBS PF_NIT PF_NS PF_OSI
  	PF_OSINET PF_PUP PF_ROUTE PF_SNA PF_UNIX PF_UNSPEC PF_USER PF_WAN
  	PF_X25
  
  	AF_802 AF_AAL AF_APPLETALK AF_CCITT AF_CHAOS AF_CTF AF_DATAKIT
  	AF_DECnet AF_DLI AF_ECMA AF_GOSIP AF_HYLINK AF_IMPLINK AF_INET AF_INET6
  	AF_ISO AF_KEY AF_LAST AF_LAT AF_LINK AF_MAX AF_NBS AF_NIT AF_NS AF_OSI
  	AF_OSINET AF_PUP AF_ROUTE AF_SNA AF_UNIX AF_UNSPEC AF_USER AF_WAN
  	AF_X25
  
  	SOCK_DGRAM SOCK_RAW SOCK_RDM SOCK_SEQPACKET SOCK_STREAM
  
  	SOL_SOCKET
  
  	SO_ACCEPTCONN SO_ATTACH_FILTER SO_BACKLOG SO_BROADCAST SO_CHAMELEON
  	SO_DEBUG SO_DETACH_FILTER SO_DGRAM_ERRIND SO_DOMAIN SO_DONTLINGER
  	SO_DONTROUTE SO_ERROR SO_FAMILY SO_KEEPALIVE SO_LINGER SO_OOBINLINE
  	SO_PASSCRED SO_PASSIFNAME SO_PEERCRED SO_PROTOCOL SO_PROTOTYPE
  	SO_RCVBUF SO_RCVLOWAT SO_RCVTIMEO SO_REUSEADDR SO_REUSEPORT
  	SO_SECURITY_AUTHENTICATION SO_SECURITY_ENCRYPTION_NETWORK
  	SO_SECURITY_ENCRYPTION_TRANSPORT SO_SNDBUF SO_SNDLOWAT SO_SNDTIMEO
  	SO_STATE SO_TYPE SO_USELOOPBACK SO_XOPEN SO_XSE
  
  	IP_HDRINCL IP_OPTIONS IP_RECVOPTS IP_RECVRETOPTS IP_RETOPTS IP_TOS
  	IP_TTL
  
  	MSG_BCAST MSG_BTAG MSG_CTLFLAGS MSG_CTLIGNORE MSG_CTRUNC MSG_DONTROUTE
  	MSG_DONTWAIT MSG_EOF MSG_EOR MSG_ERRQUEUE MSG_ETAG MSG_FASTOPEN MSG_FIN
  	MSG_MAXIOVLEN MSG_MCAST MSG_NOSIGNAL MSG_OOB MSG_PEEK MSG_PROXY MSG_RST
  	MSG_SYN MSG_TRUNC MSG_URG MSG_WAITALL MSG_WIRE
  
  	SHUT_RD SHUT_RDWR SHUT_WR
  
  	INADDR_ANY INADDR_BROADCAST INADDR_LOOPBACK INADDR_NONE
  
  	SCM_CONNECT SCM_CREDENTIALS SCM_CREDS SCM_RIGHTS SCM_TIMESTAMP
  
  	SOMAXCONN
  
  	IOV_MAX
  	UIO_MAXIOV
  
  	sockaddr_family
  	pack_sockaddr_in  unpack_sockaddr_in  sockaddr_in
  	pack_sockaddr_in6 unpack_sockaddr_in6 sockaddr_in6
  	pack_sockaddr_un  unpack_sockaddr_un  sockaddr_un 
  
  	inet_aton inet_ntoa
  );
  
  # List re-ordered to match documentation above. Try to keep the ordering
  # consistent so it's easier to see which ones are or aren't documented.
  our @EXPORT_OK = qw(
  	CR LF CRLF $CR $LF $CRLF
  
  	SOCK_NONBLOCK SOCK_CLOEXEC
  
  	IP_ADD_MEMBERSHIP IP_ADD_SOURCE_MEMBERSHIP IP_BIND_ADDRESS_NO_PORT
  	IP_DROP_MEMBERSHIP IP_DROP_SOURCE_MEMBERSHIP IP_FREEBIND
  	IP_MULTICAST_ALL IP_MULTICAST_IF IP_MULTICAST_LOOP IP_MULTICAST_TTL
  	IP_MTU IP_MTU_DISCOVER IP_NODEFRAG IP_RECVERR IP_TRANSPARENT
  
  	IPPROTO_IP IPPROTO_IPV6 IPPROTO_RAW IPPROTO_ICMP IPPROTO_IGMP
  	IPPROTO_TCP IPPROTO_UDP IPPROTO_GRE IPPROTO_ESP IPPROTO_AH
  	IPPROTO_ICMPV6 IPPROTO_SCTP
  
  	IP_PMTUDISC_DO IP_PMTUDISC_DONT IP_PMTUDISC_PROBE IP_PMTUDISC_WANT
  
  	IPTOS_LOWDELAY IPTOS_THROUGHPUT IPTOS_RELIABILITY IPTOS_MINCOST
  
  	TCP_CONGESTION TCP_CONNECTIONTIMEOUT TCP_CORK TCP_DEFER_ACCEPT
  	TCP_FASTOPEN TCP_INFO TCP_INIT_CWND TCP_KEEPALIVE TCP_KEEPCNT
  	TCP_KEEPIDLE TCP_KEEPINTVL TCP_LINGER2 TCP_MAXRT TCP_MAXSEG
  	TCP_MD5SIG TCP_NODELAY TCP_NOOPT TCP_NOPUSH TCP_QUICKACK
  	TCP_SACK_ENABLE TCP_STDURG TCP_SYNCNT TCP_USER_TIMEOUT
  	TCP_WINDOW_CLAMP
  
  	IN6ADDR_ANY IN6ADDR_LOOPBACK
  
  	IPV6_ADDRFROM IPV6_ADD_MEMBERSHIP IPV6_DROP_MEMBERSHIP IPV6_JOIN_GROUP
  	IPV6_LEAVE_GROUP IPV6_MTU IPV6_MTU_DISCOVER IPV6_MULTICAST_HOPS
  	IPV6_MULTICAST_IF IPV6_MULTICAST_LOOP IPV6_RECVERR IPV6_ROUTER_ALERT
  	IPV6_UNICAST_HOPS IPV6_V6ONLY
  
  	SO_INCOMING_CPU SO_INCOMING_NAPI_ID SO_LOCK_FILTER SO_RCVBUFFORCE
  	SO_SNDBUFFORCE
  
  	pack_ip_mreq unpack_ip_mreq pack_ip_mreq_source unpack_ip_mreq_source
  
  	pack_ipv6_mreq unpack_ipv6_mreq
  
  	inet_pton inet_ntop
  
  	getaddrinfo getnameinfo
  
  	AI_ADDRCONFIG AI_ALL AI_CANONIDN AI_CANONNAME AI_IDN
  	AI_IDN_ALLOW_UNASSIGNED AI_IDN_USE_STD3_ASCII_RULES AI_NUMERICHOST
  	AI_NUMERICSERV AI_PASSIVE AI_V4MAPPED
  
  	NI_DGRAM NI_IDN NI_IDN_ALLOW_UNASSIGNED NI_IDN_USE_STD3_ASCII_RULES
  	NI_NAMEREQD NI_NOFQDN NI_NUMERICHOST NI_NUMERICSERV
  
  	NIx_NOHOST NIx_NOSERV
  
  	EAI_ADDRFAMILY EAI_AGAIN EAI_BADFLAGS EAI_BADHINTS EAI_FAIL EAI_FAMILY
  	EAI_NODATA EAI_NONAME EAI_PROTOCOL EAI_SERVICE EAI_SOCKTYPE EAI_SYSTEM
  );
  
  our %EXPORT_TAGS = (
      crlf     => [qw(CR LF CRLF $CR $LF $CRLF)],
      addrinfo => [qw(getaddrinfo getnameinfo), grep m/^(?:AI|NI|NIx|EAI)_/, @EXPORT_OK],
      all      => [@EXPORT, @EXPORT_OK],
  );
  
  BEGIN {
      sub CR   () {"\015"}
      sub LF   () {"\012"}
      sub CRLF () {"\015\012"}
  
      # These are not gni() constants; they're extensions for the perl API
      # The definitions in Socket.pm and Socket.xs must match
      sub NIx_NOHOST() {1 << 0}
      sub NIx_NOSERV() {1 << 1}
  }
  
  *CR   = \CR();
  *LF   = \LF();
  *CRLF = \CRLF();
  
  # The four deprecated addrinfo constants
  foreach my $name (qw( AI_IDN_ALLOW_UNASSIGNED AI_IDN_USE_STD3_ASCII_RULES NI_IDN_ALLOW_UNASSIGNED NI_IDN_USE_STD3_ASCII_RULES )) {
      no strict 'refs';
      *$name = sub {
  	croak "The addrinfo constant $name is deprecated";
      };
  }
  
  sub sockaddr_in {
      if (@_ == 6 && !wantarray) { # perl5.001m compat; use this && die
  	my($af, $port, @quad) = @_;
  	warnings::warn "6-ARG sockaddr_in call is deprecated" 
  	    if warnings::enabled();
  	pack_sockaddr_in($port, inet_aton(join('.', @quad)));
      } elsif (wantarray) {
  	croak "usage:   (port,iaddr) = sockaddr_in(sin_sv)" unless @_ == 1;
          unpack_sockaddr_in(@_);
      } else {
  	croak "usage:   sin_sv = sockaddr_in(port,iaddr))" unless @_ == 2;
          pack_sockaddr_in(@_);
      }
  }
  
  sub sockaddr_in6 {
      if (wantarray) {
  	croak "usage:   (port,in6addr,scope_id,flowinfo) = sockaddr_in6(sin6_sv)" unless @_ == 1;
  	unpack_sockaddr_in6(@_);
      }
      else {
  	croak "usage:   sin6_sv = sockaddr_in6(port,in6addr,[scope_id,[flowinfo]])" unless @_ >= 2 and @_ <= 4;
  	pack_sockaddr_in6(@_);
      }
  }
  
  sub sockaddr_un {
      if (wantarray) {
  	croak "usage:   (filename) = sockaddr_un(sun_sv)" unless @_ == 1;
          unpack_sockaddr_un(@_);
      } else {
  	croak "usage:   sun_sv = sockaddr_un(filename)" unless @_ == 1;
          pack_sockaddr_un(@_);
      }
  }
  
  XSLoader::load(__PACKAGE__, $VERSION);
  
  my %errstr;
  
  if( defined &getaddrinfo ) {
      # These are not part of the API, nothing uses them, and deleting them
      # reduces the size of %Socket:: by about 12K
      delete $Socket::{fake_getaddrinfo};
      delete $Socket::{fake_getnameinfo};
  } else {
      require Scalar::Util;
  
      *getaddrinfo = \&fake_getaddrinfo;
      *getnameinfo = \&fake_getnameinfo;
  
      # These numbers borrowed from GNU libc's implementation, but since
      # they're only used by our emulation, it doesn't matter if the real
      # platform's values differ
      my %constants = (
  	AI_PASSIVE     => 1,
  	AI_CANONNAME   => 2,
  	AI_NUMERICHOST => 4,
  	AI_V4MAPPED    => 8,
  	AI_ALL         => 16,
  	AI_ADDRCONFIG  => 32,
  	# RFC 2553 doesn't define this but Linux does - lets be nice and
  	# provide it since we can
  	AI_NUMERICSERV => 1024,
  
  	EAI_BADFLAGS   => -1,
  	EAI_NONAME     => -2,
  	EAI_NODATA     => -5,
  	EAI_FAMILY     => -6,
  	EAI_SERVICE    => -8,
  
  	NI_NUMERICHOST => 1,
  	NI_NUMERICSERV => 2,
  	NI_NOFQDN      => 4,
  	NI_NAMEREQD    => 8,
  	NI_DGRAM       => 16,
  
  	# Constants we don't support. Export them, but croak if anyone tries to
  	# use them
  	AI_IDN      => 64,
  	AI_CANONIDN => 128,
  	NI_IDN      => 32,
  
  	# Error constants we'll never return, so it doesn't matter what value
  	# these have, nor that we don't provide strings for them
  	EAI_SYSTEM   => -11,
  	EAI_BADHINTS => -1000,
  	EAI_PROTOCOL => -1001
      );
  
      foreach my $name ( keys %constants ) {
  	my $value = $constants{$name};
  
  	no strict 'refs';
  	defined &$name or *$name = sub () { $value };
      }
  
      %errstr = (
  	# These strings from RFC 2553
  	EAI_BADFLAGS()   => "invalid value for ai_flags",
  	EAI_NONAME()     => "nodename nor servname provided, or not known",
  	EAI_NODATA()     => "no address associated with nodename",
  	EAI_FAMILY()     => "ai_family not supported",
  	EAI_SERVICE()    => "servname not supported for ai_socktype",
      );
  }
  
  # The following functions are used if the system does not have a
  # getaddrinfo(3) function in libc; and are used to emulate it for the AF_INET
  # family
  
  # Borrowed from Regexp::Common::net
  my $REGEXP_IPv4_DECIMAL = qr/25[0-5]|2[0-4][0-9]|[0-1]?[0-9]{1,2}/;
  my $REGEXP_IPv4_DOTTEDQUAD = qr/$REGEXP_IPv4_DECIMAL\.$REGEXP_IPv4_DECIMAL\.$REGEXP_IPv4_DECIMAL\.$REGEXP_IPv4_DECIMAL/;
  
  sub fake_makeerr
  {
      my ( $errno ) = @_;
      my $errstr = $errno == 0 ? "" : ( $errstr{$errno} || $errno );
      return Scalar::Util::dualvar( $errno, $errstr );
  }
  
  sub fake_getaddrinfo
  {
      my ( $node, $service, $hints ) = @_;
  
      $node = "" unless defined $node;
  
      $service = "" unless defined $service;
  
      my ( $family, $socktype, $protocol, $flags ) = @$hints{qw( family socktype protocol flags )};
  
      $family ||= Socket::AF_INET(); # 0 == AF_UNSPEC, which we want too
      $family == Socket::AF_INET() or return fake_makeerr( EAI_FAMILY() );
  
      $socktype ||= 0;
  
      $protocol ||= 0;
  
      $flags ||= 0;
  
      my $flag_passive     = $flags & AI_PASSIVE();     $flags &= ~AI_PASSIVE();
      my $flag_canonname   = $flags & AI_CANONNAME();   $flags &= ~AI_CANONNAME();
      my $flag_numerichost = $flags & AI_NUMERICHOST(); $flags &= ~AI_NUMERICHOST();
      my $flag_numericserv = $flags & AI_NUMERICSERV(); $flags &= ~AI_NUMERICSERV();
  
      # These constants don't apply to AF_INET-only lookups, so we might as well
      # just ignore them. For AI_ADDRCONFIG we just presume the host has ability
      # to talk AF_INET. If not we'd have to return no addresses at all. :)
      $flags &= ~(AI_V4MAPPED()|AI_ALL()|AI_ADDRCONFIG());
  
      $flags & (AI_IDN()|AI_CANONIDN()) and
  	croak "Socket::getaddrinfo() does not support IDN";
  
      $flags == 0 or return fake_makeerr( EAI_BADFLAGS() );
  
      $node eq "" and $service eq "" and return fake_makeerr( EAI_NONAME() );
  
      my $canonname;
      my @addrs;
      if( $node ne "" ) {
  	return fake_makeerr( EAI_NONAME() ) if( $flag_numerichost and $node !~ m/^$REGEXP_IPv4_DOTTEDQUAD$/ );
  	( $canonname, undef, undef, undef, @addrs ) = gethostbyname( $node );
  	defined $canonname or return fake_makeerr( EAI_NONAME() );
  
  	undef $canonname unless $flag_canonname;
      }
      else {
  	$addrs[0] = $flag_passive ? Socket::inet_aton( "0.0.0.0" )
  				  : Socket::inet_aton( "127.0.0.1" );
      }
  
      my @ports; # Actually ARRAYrefs of [ socktype, protocol, port ]
      my $protname = "";
      if( $protocol ) {
  	$protname = eval { getprotobynumber( $protocol ) };
      }
  
      if( $service ne "" and $service !~ m/^\d+$/ ) {
  	return fake_makeerr( EAI_NONAME() ) if( $flag_numericserv );
  	getservbyname( $service, $protname ) or return fake_makeerr( EAI_SERVICE() );
      }
  
      foreach my $this_socktype ( Socket::SOCK_STREAM(), Socket::SOCK_DGRAM(), Socket::SOCK_RAW() ) {
  	next if $socktype and $this_socktype != $socktype;
  
  	my $this_protname = "raw";
  	$this_socktype == Socket::SOCK_STREAM() and $this_protname = "tcp";
  	$this_socktype == Socket::SOCK_DGRAM()  and $this_protname = "udp";
  
  	next if $protname and $this_protname ne $protname;
  
  	my $port;
  	if( $service ne "" ) {
  	    if( $service =~ m/^\d+$/ ) {
  		$port = "$service";
  	    }
  	    else {
  		( undef, undef, $port, $this_protname ) = getservbyname( $service, $this_protname );
  		next unless defined $port;
  	    }
  	}
  	else {
  	    $port = 0;
  	}
  
  	push @ports, [ $this_socktype, eval { scalar getprotobyname( $this_protname ) } || 0, $port ];
      }
  
      my @ret;
      foreach my $addr ( @addrs ) {
  	foreach my $portspec ( @ports ) {
  	    my ( $socktype, $protocol, $port ) = @$portspec;
  	    push @ret, {
  		family    => $family,
  		socktype  => $socktype,
  		protocol  => $protocol,
  		addr      => Socket::pack_sockaddr_in( $port, $addr ),
  		canonname => undef,
  	    };
  	}
      }
  
      # Only supply canonname for the first result
      if( defined $canonname ) {
  	$ret[0]->{canonname} = $canonname;
      }
  
      return ( fake_makeerr( 0 ), @ret );
  }
  
  sub fake_getnameinfo
  {
      my ( $addr, $flags, $xflags ) = @_;
  
      my ( $port, $inetaddr );
      eval { ( $port, $inetaddr ) = Socket::unpack_sockaddr_in( $addr ) }
  	or return fake_makeerr( EAI_FAMILY() );
  
      my $family = Socket::AF_INET();
  
      $flags ||= 0;
  
      my $flag_numerichost = $flags & NI_NUMERICHOST(); $flags &= ~NI_NUMERICHOST();
      my $flag_numericserv = $flags & NI_NUMERICSERV(); $flags &= ~NI_NUMERICSERV();
      my $flag_nofqdn      = $flags & NI_NOFQDN();      $flags &= ~NI_NOFQDN();
      my $flag_namereqd    = $flags & NI_NAMEREQD();    $flags &= ~NI_NAMEREQD();
      my $flag_dgram       = $flags & NI_DGRAM()   ;    $flags &= ~NI_DGRAM();
  
      $flags & NI_IDN() and
  	croak "Socket::getnameinfo() does not support IDN";
  
      $flags == 0 or return fake_makeerr( EAI_BADFLAGS() );
  
      $xflags ||= 0;
  
      my $node;
      if( $xflags & NIx_NOHOST ) {
  	$node = undef;
      }
      elsif( $flag_numerichost ) {
  	$node = Socket::inet_ntoa( $inetaddr );
      }
      else {
  	$node = gethostbyaddr( $inetaddr, $family );
  	if( !defined $node ) {
  	    return fake_makeerr( EAI_NONAME() ) if $flag_namereqd;
  	    $node = Socket::inet_ntoa( $inetaddr );
  	}
  	elsif( $flag_nofqdn ) {
  	    my ( $shortname ) = split m/\./, $node;
  	    my ( $fqdn ) = gethostbyname $shortname;
  	    $node = $shortname if defined $fqdn and $fqdn eq $node;
  	}
      }
  
      my $service;
      if( $xflags & NIx_NOSERV ) {
  	$service = undef;
      }
      elsif( $flag_numericserv ) {
  	$service = "$port";
      }
      else {
  	my $protname = $flag_dgram ? "udp" : "";
  	$service = getservbyport( $port, $protname );
  	if( !defined $service ) {
  	    $service = "$port";
  	}
      }
  
      return ( fake_makeerr( 0 ), $node, $service );
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_SOCKET

$fatpacked{"x86_64-linux-gnu-thread-multi/Sub/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_SUB_UTIL';
  # Copyright (c) 2014 Paul Evans <leonerd@leonerd.org.uk>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package Sub::Util;
  
  use strict;
  use warnings;
  
  require Exporter;
  
  our @ISA = qw( Exporter );
  our @EXPORT_OK = qw(
    prototype set_prototype
    subname set_subname
  );
  
  our $VERSION    = "1.63";
  $VERSION =~ tr/_//d;
  
  require List::Util; # as it has the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  =head1 NAME
  
  Sub::Util - A selection of utility subroutines for subs and CODE references
  
  =head1 SYNOPSIS
  
      use Sub::Util qw( prototype set_prototype subname set_subname );
  
  =head1 DESCRIPTION
  
  C<Sub::Util> contains a selection of utility subroutines that are useful for
  operating on subs and CODE references.
  
  The rationale for inclusion in this module is that the function performs some
  work for which an XS implementation is essential because it cannot be
  implemented in Pure Perl, and which is sufficiently-widely used across CPAN
  that its popularity warrants inclusion in a core module, which this is.
  
  =cut
  
  =head1 FUNCTIONS
  
  =cut
  
  =head2 prototype
  
      my $proto = prototype( $code )
  
  I<Since version 1.40.>
  
  Returns the prototype of the given C<$code> reference, if it has one, as a
  string. This is the same as the C<CORE::prototype> operator; it is included
  here simply for symmetry and completeness with the other functions.
  
  =cut
  
  sub prototype
  {
    my ( $code ) = @_;
    return CORE::prototype( $code );
  }
  
  =head2 set_prototype
  
      my $code = set_prototype $prototype, $code;
  
  I<Since version 1.40.>
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
  I<Caution>: This function takes arguments in a different order to the previous
  copy of the code from C<Scalar::Util>. This is to match the order of
  C<set_subname>, and other potential additions in this file. This order has
  been chosen as it allows a neat and simple chaining of other
  C<Sub::Util::set_*> functions as might become available, such as:
  
   my $code =
      set_subname   name_here =>
      set_prototype '&@'      =>
      set_attribute ':lvalue' =>
         sub { ...... };
  
  =cut
  
  =head2 subname
  
      my $name = subname( $code )
  
  I<Since version 1.40.>
  
  Returns the name of the given C<$code> reference, if it has one. Normal named
  subs will give a fully-qualified name consisting of the package and the
  localname separated by C<::>. Anonymous code references will give C<__ANON__>
  as the localname. If the package the code was compiled in has been deleted
  (e.g. using C<delete_package> from L<Symbol>), C<__ANON__> will be returned as
  the package name. If a name has been set using L</set_subname>, this name will be
  returned instead.
  
  This function was inspired by C<sub_fullname> from L<Sub::Identify>. The
  remaining functions that C<Sub::Identify> implements can easily be emulated
  using regexp operations, such as
  
   sub get_code_info { return (subname $_[0]) =~ m/^(.+)::(.*?)$/ }
   sub sub_name      { return (get_code_info $_[0])[0] }
   sub stash_name    { return (get_code_info $_[0])[1] }
  
  I<Users of Sub::Name beware>: This function is B<not> the same as
  C<Sub::Name::subname>; it returns the existing name of the sub rather than
  changing it. To set or change a name, see instead L</set_subname>.
  
  =cut
  
  =head2 set_subname
  
      my $code = set_subname $name, $code;
  
  I<Since version 1.40.>
  
  Sets the name of the function given by the C<$code> reference. Returns the
  C<$code> reference itself. If the C<$name> is unqualified, the package of the
  caller is used to qualify it.
  
  This is useful for applying names to anonymous CODE references so that stack
  traces and similar situations, to give a useful name rather than having the
  default of C<__ANON__>. Note that this name is only used for this situation;
  the C<set_subname> will not install it into the symbol table; you will have to
  do that yourself if required.
  
  However, since the name is not used by perl except as the return value of
  C<caller>, for stack traces or similar, there is no actual requirement that
  the name be syntactically valid as a perl function name. This could be used to
  attach extra information that could be useful in debugging stack traces.
  
  This function was copied from C<Sub::Name::subname> and renamed to the naming
  convention of this module.
  
  =cut
  
  =head1 AUTHOR
  
  The general structure of this module was written by Paul Evans
  <leonerd@leonerd.org.uk>.
  
  The XS implementation of L</set_subname> was copied from L<Sub::Name> by
  Matthijs van Duin <xmath@cpan.org>
  
  =cut
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_SUB_UTIL

$fatpacked{"x86_64-linux-gnu-thread-multi/Want.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_WANT';
  package Want;
  
  require 5.006;
  use Carp 'croak';
  use strict;
  use warnings;
  
  require Exporter;
  require DynaLoader;
  
  our @ISA = qw(Exporter DynaLoader);
  
  our @EXPORT = qw(want rreturn lnoreturn);
  our @EXPORT_OK = qw(howmany wantref);
  our $VERSION = '0.29';
  
  bootstrap Want $VERSION;
  
  my %reftype = (
      ARRAY  => 1,
      HASH   => 1,
      CODE   => 1,
      GLOB   => 1,
      OBJECT => 1,
  );
  
  sub _wantone {
      my ($uplevel, $arg) = @_;
      
      my $wantref = wantref($uplevel + 1);
      if	  ($arg =~ /^\d+$/) {
  	my $want_count = want_count($uplevel);
  	return ($want_count == -1 || $want_count >= $arg);
      }
      elsif (lc($arg) eq 'infinity') {
  	return (want_count($uplevel) == -1);
      }
      elsif ($arg eq 'REF') {
  	return $wantref;
      }
      elsif ($reftype{$arg}) {
  	return ($wantref eq $arg);
      }
      elsif ($arg eq 'REFSCALAR') {
  	return ($wantref eq 'SCALAR');
      }
      elsif ($arg eq 'LVALUE') {
  	return want_lvalue($uplevel);
      }
      elsif ($arg eq 'RVALUE') {
  	return !want_lvalue($uplevel);
      }
      elsif ($arg eq 'VOID') {
  	return !defined(wantarray_up($uplevel));
      }
      elsif ($arg eq 'SCALAR') {
  	my $gimme = wantarray_up($uplevel);
  	return (defined($gimme) && 0 == $gimme);
      }
      elsif ($arg eq 'BOOL' || $arg eq 'BOOLEAN') {
  	return want_boolean(bump_level($uplevel));
      }
      elsif ($arg eq 'LIST') {
  	return wantarray_up($uplevel);
      }
      elsif ($arg eq 'COUNT') {
  	croak("want: COUNT must be the *only* parameter");
      }
      elsif ($arg eq 'ASSIGN') {
  	return !!wantassign($uplevel + 1);
      }
      else {
  	croak ("want: Unrecognised specifier $arg");
      }    
  }
  
  sub want {
      if (@_ == 1 && $_[0] eq 'ASSIGN') {
  	@_ = (1);
  	goto &wantassign;
      }
      want_uplevel(1, @_);
  }
  
  # Simulate the propagation of context through a return value.
  sub bump_level {
      my ($level) = @_;
      for(;;) {
  	my ($p, $r) = parent_op_name($level+1);
  	if ($p eq "return"
          or  $p eq "(none)" && $r =~ /^leavesub(lv)?$/)
  	{
  	    ++$level
  	}
  	else {
  	    return $level
  	}
      }
  }
  
  sub want_uplevel {
      my ($level, @args) = @_;
  
      # Deal with special cases (for RFC21-consistency):
      if (1 == @args) {
  	@_ = (1 + $level);
  	goto &wantref    if $args[0] eq 'REF';
  	goto &howmany    if $args[0] eq 'COUNT';
  	goto &wantassign if $args[0] eq 'ASSIGN';
      }
  
      for my $arg (map split, @args) {
  	if ($arg =~ /^!(.*)/) {
  	    return 0 unless !_wantone(2 + $level, $1);
  	}
  	else {
  	    return 0 unless _wantone(2 + $level, $arg);
  	}
      }
      
      return 1;
  }
  
  sub howmany () {
      my $level = bump_level(@_, 1);
      my $count = want_count($level);
      return ($count < 0 ? undef : $count);
  }
  
  sub wantref {
      my $level = bump_level(@_, 1);
      my $n = parent_op_name($level);
      if    ($n eq 'rv2av') {
  	return "ARRAY";
      }
      elsif ($n eq 'rv2hv') {
  	return "HASH";
      }
      elsif ($n eq 'rv2cv' || $n eq 'entersub') {
  	return "CODE";
      }
      elsif ($n eq 'rv2gv' || $n eq 'gelem') {
  	return "GLOB";
      }
      elsif ($n eq 'rv2sv') {
  	return "SCALAR";
      }
      elsif ($n eq 'method_call') {
  	return 'OBJECT';
      }
      elsif ($n eq 'multideref') {
  	return first_multideref_type($level);
      }
      else {
  	return "";
      }
  }
  
  sub wantassign {
      my $uplevel = shift();
      return unless want_lvalue($uplevel);
      my $r = want_assign(bump_level($uplevel));
      if (want('BOOL')) {
  	return (defined($r) && 0 != $r);
      }
      else {
  	return $r ? (want('SCALAR') ? $r->[$#$r] : @$r) : ();
      }
  }
  
  sub double_return :lvalue;
  
  sub rreturn (@) {
      if (want_lvalue(1)) {
          croak "Can't rreturn in lvalue context";
      }
  
      # Extra scope needed to work with perl-5.19.7 or greater.
      # Prevents the return being optimised out, which is needed
      # since it's actually going to be used a stack level above
      # this sub.
      {
          return double_return(@_);
      }
  }
  
  sub lnoreturn () : lvalue {
      if (!want_lvalue(1) || !want_assign(1)) {
          croak "Can't lnoreturn except in ASSIGN context";
      }
  
      # Extra scope needed to work with perl-5.19.7 or greater.
      # Prevents the return being optimised out, which is needed
      # since it's actually going to be used a stack level above
      # this sub.
      #
      # But in older versions of perl, adding the extra scope
      # causes the error:
      #   Can't modify loop exit in lvalue subroutine return
      # so we have to check the version.
      if ($] >= 5.019) {
          return double_return(disarm_temp(my $undef));
      }
      return double_return(disarm_temp(my $undef));
  }
  
  # Some naughty people were relying on these internal methods.
  *_wantref = \&wantref;
  *_wantassign = \&wantassign;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Want - A generalisation of C<wantarray>
  
  =head1 SYNOPSIS
  
    use Want;
    sub foo :lvalue {
        if    (want(qw'LVALUE ASSIGN')) {
          print "We have been assigned ", want('ASSIGN');
          lnoreturn;
        }
        elsif (want('LIST')) {
          rreturn (1, 2, 3);
        }
        elsif (want('BOOL')) {
          rreturn 0;
        }
        elsif (want(qw'SCALAR !REF')) {
          rreturn 23;
        }
        elsif (want('HASH')) {
          rreturn { foo => 17, bar => 23 };
        }
        return;  # You have to put this at the end to keep the compiler happy
    }
  
  =head1 DESCRIPTION
  
  This module generalises the mechanism of the B<wantarray> function,
  allowing a function to determine in some detail how its return value
  is going to be immediately used.
  
  =head2 Top-level contexts:
  
  The three kinds of top-level context are well known:
  
  =over 4
  
  =item B<VOID>
  
  The return value is not being used in any way. It could be an entire statement
  like C<foo();>, or the last component of a compound statement which is itself in
  void context, such as C<$test || foo();>n. Be warned that the last statement
  of a subroutine will be in whatever context the subroutine was called in, because
  the result is implicitly returned.
  
  =item B<SCALAR>
  
  The return value is being treated as a scalar value of some sort:
  
    my $x = foo();
    $y += foo();
    print "123" x foo();
    print scalar foo();
    warn foo()->{23};
    ...etc...
  
  =item B<LIST>
  
  The return value is treated as a list of values:
  
    my @x = foo();
    my ($x) = foo();
    () = foo();		# even though the results are discarded
    print foo();
    bar(foo());		# unless the bar subroutine has a prototype
    print @hash{foo()};	# (hash slice)
    ...etc...
  
  =back
  
  =head2 Lvalue subroutines:
  
  The introduction of B<lvalue subroutines> in Perl 5.6 has created a new type
  of contextual information, which is independent of those listed above. When
  an lvalue subroutine is called, it can either be called in the ordinary way
  (so that its result is treated as an ordinary value, an B<rvalue>); or else
  it can be called so that its result is considered updatable, an B<lvalue>.
  
  These rather arcane terms (lvalue and rvalue) are easier to remember if you
  know why they are so called. If you consider a simple assignment statement
  C<left = right>, then the B<l>eft-hand side is an B<l>value and the B<r>ight-hand
  side is an B<r>value.
  
  So (for lvalue subroutines only) there are two new types of context:
  
  =over 4
  
  =item B<RVALUE>
  
  The caller is definitely not trying to assign to the result:
  
    foo();
    my $x = foo();
    ...etc...
  
  If the sub is declared without the C<:lvalue> attribute, then it will
  I<always> be in RVALUE context.
  
  If you need to return values from an lvalue subroutine in RVALUE context,
  you should use the C<rreturn> function rather than an ordinary C<return>.
  Otherwise you'll probably get a compile-time error in perl 5.6.1 and later.
  
  =item B<LVALUE>
  
  Either the caller is directly assigning to the result of the sub call:
  
    foo() = $x;
    foo() = (1, 1, 2, 3, 5, 8);
  
  or the caller is making a reference to the result, which might be assigned to
  later:
  
    my $ref = \(foo());	# Could now have: $$ref = 99;
    
    # Note that this example imposes LIST context on the sub call.
    # So we're taking a reference to the first element to be
    # returned _in list context_.
    # If we want to call the function in scalar context, we can
    # do it like this:
    my $ref = \(scalar foo());
  
  or else the result of the function call is being used as part of the argument list
  for I<another> function call:
  
    bar(foo());	# Will *always* call foo in lvalue context,
    		# (provided that foo is an C<:lvalue> sub)
    		# regardless of what bar actually does.
  
  The reason for this last case is that bar might be a sub which modifies its
  arguments. They're rare in contemporary Perl code, but perfectly possible:
  
    sub bar {
      $_[0] = 23;
    }
  
  (This is really a throwback to Perl 4, which didn't support explicit references.)
  
  =back
  
  =head2 Assignment context:
  
  The commonest use of lvalue subroutines is with the assignment statement:
  
    size() = 12;
    (list()) = (1..10);
  
  A useful motto to remember when thinking about assignment statements is
  I<context comes from the left>. Consider code like this:
  
    my ($x, $y, $z);
    sub list () :lvalue { ($x, $y, $z) }
    list = (1, 2, 3);
    print "\$x = $x; \$y = $y; \$z = $z\n";
  
  This prints C<$x = ; $y = ; $z = 3>, which may not be what you were expecting.
  The reason is that the assignment is in scalar context, so the comma operator
  is in scalar context too, and discards all values but the last. You can fix
  it by writing C<(list) = (1,2,3);> instead.
  
  If your lvalue subroutine is used on the left of an assignment statement,
  it's in B<ASSIGN> context.  If ASSIGN is the only argument to C<want()>, then
  it returns a reference to an array of the value(s) of the right-hand side.
  
  In this case, you should return with the C<lnoreturn> function, rather than
  an ordinary C<return>. 
  
  This makes it very easy to write lvalue subroutines which do clever things:
  
    use Want;
    use strict;
    sub backstr :lvalue {
      if (want(qw'LVALUE ASSIGN')) {
        my ($a) = want('ASSIGN');
        $_[0] = reverse $a;
        lnoreturn;
      }
      elsif (want('RVALUE')) {
        rreturn scalar reverse $_[0];
      }
      else {
        carp("Not in ASSIGN context");
      }
      return
    }
   
    print "foo -> ", backstr("foo"), "\n";	# foo -> oof
    backstr(my $robin) = "nibor";
    print "\$robin is now $robin\n";		# $robin is now robin
  
  Notice that you need to put a (meaningless) return
  statement at the end of the function, otherwise you will get the
  error
  I<Can't modify non-lvalue subroutine call in lvalue subroutine return>.
  
  The only way to write that C<backstr> function without using Want is to return
  a tied variable which is tied to a custom class.
  
  =head2 Reference context:
  
  Sometimes in scalar context the caller is expecting a reference of some sort
  to be returned:
  
      print foo()->();     # CODE reference expected
      print foo()->{bar};  # HASH reference expected
      print foo()->[23];   # ARRAY reference expected
      print ${foo()};	 # SCALAR reference expected
      print foo()->bar();	 # OBJECT reference expected
      
      my $format = *{foo()}{FORMAT} # GLOB reference expected
  
  You can check this using conditionals like C<if (want('CODE'))>.
  There is also a function C<wantref()> which returns one of the strings
  "CODE", "HASH", "ARRAY", "GLOB", "SCALAR" or "OBJECT"; or the empty string
  if a reference is not expected.
  
  Because C<want('SCALAR')> is already used to select ordinary scalar context,
  you have to use C<want('REFSCALAR')> to find out if a SCALAR reference is
  expected. Or you could use C<want('REF') eq 'SCALAR'> of course.
  
  Be warned that C<want('ARRAY')> is a B<very> different thing from C<wantarray()>.
  
  =head2 Item count
  
  Sometimes in list context the caller is expecting a particular number of items
  to be returned:
  
      my ($x, $y) = foo();   # foo is expected to return two items
  
  If you pass a number to the C<want> function, then it will return true or false
  according to whether at least that many items are wanted. So if we are in the
  definition of a sub which is being called as above, then:
  
      want(1) returns true
      want(2) returns true
      want(3) returns false
  
  Sometimes there is no limit to the number of items that might be used:
  
      my @x = foo();
      do_something_with( foo() );
  
  In this case, C<want(2)>, C<want(100)>, C<want(1E9)> and so on will all return
  true; and so will C<want('Infinity')>.
  
  The C<howmany> function can be used to find out how many items are wanted.
  If the context is scalar, then C<want(1)> returns true and C<howmany()> returns
  1. If you want to check whether your result is being assigned to a singleton
  list, you can say C<if (want('LIST', 1)) { ... }>.
  
  
  =head2 Boolean context
  
  Sometimes the caller is only interested in the truth or falsity of a function's
  return value:
  
      if (everything_is_okay()) {
  	# Carry on
      }
      
      print (foo() ? "ok\n" : "not ok\n");
      
  In the following example, all subroutine calls are in BOOL context:
  
      my $x = ( (foo() && !bar()) xor (baz() || quux()) );
  
  Boolean context, like the reference contexts above, is considered to be a subcontext
  of SCALAR.
  
  =head1 FUNCTIONS
  
  =over 4
  
  =item want(SPECIFIERS)
  
  This is the primary interface to this module, and should suffice for most
  purposes. You pass it a list of context specifiers, and the return value
  is true whenever all of the specifiers hold.
  
      want('LVALUE', 'SCALAR');   # Are we in scalar lvalue context?
      want('RVALUE', 3);		# Are at least three rvalues wanted?
      want('ARRAY');	# Is the return value used as an array ref?
  
  You can also prefix a specifier with an exclamation mark to indicate that you
  B<don't> want it to be true
  
      want(2, '!3');		# Caller wants exactly two items.
      want(qw'REF !CODE !GLOB');  # Expecting a reference that
      				#   isn't a CODE or GLOB ref.
      want(100, '!Infinity');	# Expecting at least 100 items,
      				#   but there is a limit.
  
  If the I<REF> keyword is the only parameter passed, then the type of reference will be
  returned.  This is just a synonym for the C<wantref> function: it's included because
  you might find it useful if you don't want to pollute your namespace by importing
  several functions, and to conform to Damian Conway's suggestion in RFC 21.
  
  Finally, the keyword I<COUNT> can be used, provided that it's the only keyword
  you pass. Mixing COUNT with other keywords is an error. This is a synonym for the
  C<howmany> function.
  
  A full list of the permitted keyword is in the B<ARGUMENTS> section below.
  
  =item rreturn
  
  Use this function instead of C<return> from inside an lvalue subroutine when
  you know that you're in RVALUE context. If you try to use a normal C<return>,
  you'll get a compile-time error in Perl 5.6.1 and above unless you return an
  lvalue. (Note: this is no longer true in Perl 5.16, where an ordinary return
  will once again work.)
  
  =item lnoreturn
  
  Use this function instead of C<return> from inside an lvalue subroutine when
  you're in ASSIGN context and you've used C<want('ASSIGN')> to carry out the
  appropriate action.
  
  If you use C<rreturn> or C<lnoreturn>, then you have to put a bare C<return;>
  at the very end of your lvalue subroutine, in order to stop the Perl compiler
  from complaining. Think of it as akin to the C<1;> that you have to put at the
  end of a module. (Note: this is no longer true in Perl 5.16.)
  
  =item howmany()
  
  Returns the I<expectation count>, i.e. the number of items expected. If the 
  expectation count is undefined, that
  indicates that an unlimited number of items might be used (e.g. the return
  value is being assigned to an array). In void context the expectation count
  is zero, and in scalar context it is one.
  
  The same as C<want('COUNT')>.
  
  =item wantref()
  
  Returns the type of reference which the caller is expecting, or the empty string
  if the caller isn't expecting a reference immediately.
  
  The same as C<want('REF')>.
  
  =back
  
  =head1 EXAMPLES
  
      use Carp 'croak';
      use Want 'howmany';
      sub numbers {
  	my $count = howmany();
  	croak("Can't make an infinite list") if !defined($count);
  	return (1..$count);
      }
      my ($one, $two, $three) = numbers();
      
      
      use Want 'want';
      sub pi () {
  	if    (want('ARRAY')) {
  	    return [3, 1, 4, 1, 5, 9];
  	}
  	elsif (want('LIST')) {
  	    return (3, 1, 4, 1, 5, 9);
  	}
  	else {
  	    return 3;
  	}
      }
      print pi->[2];	# prints 4
      print ((pi)[3]);	# prints 1
  
  =head1 ARGUMENTS
  
  The permitted arguments to the C<want> function are listed below.
  The list is structured so that sub-contexts appear below the context that they
  are part of.
  
  =over 4
  
  =item *
  
  VOID
  
  =item *
  
  SCALAR
  
  =over 4
  
  =item *
  
  REF
  
  =over 4
  
  =item *
  
  REFSCALAR
  
  =item *
  
  CODE
  
  =item *
  
  HASH
  
  =item *
  
  ARRAY
  
  =item *
  
  GLOB
  
  =item *
  
  OBJECT
  
  =back
  
  =item *
  
  BOOL
  
  =back
  
  =item *
  
  LIST
  
  =over 4
  
  =item *
  
  COUNT
  
  =item *
  
  E<lt>numberE<gt>
  
  =item *
  
  Infinity
  
  =back
  
  =item *
  
  LVALUE
  
  =over 4
  
  =item *
  
  ASSIGN
  
  =back
  
  =item *
  
  RVALUE
  
  =back
  
  =head1 EXPORT
  
  The C<want> and C<rreturn> functions are exported by default.
  The C<wantref> and/or C<howmany> functions can also be imported:
  
    use Want qw'want howmany';
  
  If you don't import these functions, you must qualify their names as (e.g.)
  C<Want::wantref>.
  
  =head1 INTERFACE
  
  This module is still under development, and the public interface may change in
  future versions. The C<want> function can now be regarded as stable.
  
  I'd be interested to know how you're using this module.
  
  =head1 SUBTLETIES
  
  There are two different levels of B<BOOL> context. I<Pure> boolean context
  occurs in conditional expressions, and the operands of the C<xor> and C<!>/C<not>
  operators.
  Pure boolean context also propagates down through the C<&&> and C<||> operators.
  
  However, consider an expression like C<my $x = foo() && "yes">. The subroutine
  is called in I<pseudo>-boolean context - its return value isn't B<entirely>
  ignored, because the undefined value, the empty string and the integer 0 are
  all false.
  
  At the moment C<want('BOOL')> is true in either pure or pseudo boolean
  context. Let me know if this is a problem.
  
  =head1 BUGS
  
   * Doesn't work from inside a tie-handler.
  
  =head1 AUTHOR
  
  Robin Houston, E<lt>robin@cpan.orgE<gt>
  
  Thanks to Damian Conway for encouragement and good suggestions,
  and Father Chrysostomos for a patch.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item *
  
  L<perlfunc/wantarray>
  
  =item *
  
  Perl6 RFC 21, by Damian Conway.
  http://dev.perl.org/rfc/21.html
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2001-2012, Robin Houston. All Rights Reserved.
  This module is free software. It may be used, redistributed
  and/or modified under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_WANT

$fatpacked{"x86_64-linux-gnu-thread-multi/encoding.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_ENCODING';
  # $Id: encoding.pm,v 3.00 2020/04/19 10:56:28 dankogai Exp $
  package encoding;
  our $VERSION = sprintf "%d.%02d", q$Revision: 3.00 $ =~ /(\d+)/g;
  
  use Encode;
  use strict;
  use warnings;
  use Config;
  
  use constant {
      DEBUG => !!$ENV{PERL_ENCODE_DEBUG},
      HAS_PERLIO => eval { require PerlIO::encoding; PerlIO::encoding->VERSION(0.02) },
      PERL_5_21_7 => $^V && $^V ge v5.21.7, # lexically scoped
  };
  
  sub _exception {
      my $name = shift;
      $] > 5.008 and return 0;    # 5.8.1 or higher then no
      my %utfs = map { $_ => 1 }
        qw(utf8 UCS-2BE UCS-2LE UTF-16 UTF-16BE UTF-16LE
        UTF-32 UTF-32BE UTF-32LE);
      $utfs{$name} or return 0;    # UTFs or no
      require Config;
      Config->import();
      our %Config;
      return $Config{perl_patchlevel} ? 0 : 1    # maintperl then no
  }
  
  sub in_locale { $^H & ( $locale::hint_bits || 0 ) }
  
  sub _get_locale_encoding {
      my $locale_encoding;
  
      if ($^O eq 'MSWin32') {
          my @tries = (
              # First try to get the OutputCP. This will work only if we
              # are attached to a console
              'Win32.pm' => 'Win32::GetConsoleOutputCP',
              'Win32/Console.pm' => 'Win32::Console::OutputCP',
              # If above failed, this means that we are a GUI app
              # Let's assume that the ANSI codepage is what matters
              'Win32.pm' => 'Win32::GetACP',
          );
          while (@tries) {
              my $cp = eval {
                  require $tries[0];
                  no strict 'refs';
                  &{$tries[1]}()
              };
              if ($cp) {
                  if ($cp == 65001) { # Code page for UTF-8
                      $locale_encoding = 'UTF-8';
                  } else {
                      $locale_encoding = 'cp' . $cp;
                  }
                  return $locale_encoding;
              }
              splice(@tries, 0, 2)
          }
      }
  
      # I18N::Langinfo isn't available everywhere
      $locale_encoding = eval {
          require I18N::Langinfo;
          find_encoding(
              I18N::Langinfo::langinfo( I18N::Langinfo::CODESET() )
          )->name
      };
      return $locale_encoding if defined $locale_encoding;
  
      eval {
          require POSIX;
          # Get the current locale
          # Remember that MSVCRT impl is quite different from Unixes
          my $locale = POSIX::setlocale(POSIX::LC_CTYPE());
          if ( $locale =~ /^([^.]+)\.([^.@]+)(?:@.*)?$/ ) {
              my $country_language;
              ( $country_language, $locale_encoding ) = ( $1, $2 );
  
              # Could do more heuristics based on the country and language
              # since we have Locale::Country and Locale::Language available.
              # TODO: get a database of Language -> Encoding mappings
              # (the Estonian database at http://www.eki.ee/letter/
              # would be excellent!) --jhi
              if (lc($locale_encoding) eq 'euc') {
                  if ( $country_language =~ /^ja_JP|japan(?:ese)?$/i ) {
                      $locale_encoding = 'euc-jp';
                  }
                  elsif ( $country_language =~ /^ko_KR|korean?$/i ) {
                      $locale_encoding = 'euc-kr';
                  }
                  elsif ( $country_language =~ /^zh_CN|chin(?:a|ese)$/i ) {
                      $locale_encoding = 'euc-cn';
                  }
                  elsif ( $country_language =~ /^zh_TW|taiwan(?:ese)?$/i ) {
                      $locale_encoding = 'euc-tw';
                  }
                  else {
                      require Carp;
                      Carp::croak(
                          "encoding: Locale encoding '$locale_encoding' too ambiguous"
                      );
                  }
              }
          }
      };
  
      return $locale_encoding;
  }
  
  sub import {
  
      if ( ord("A") == 193 ) {
          require Carp;
          Carp::croak("encoding: pragma does not support EBCDIC platforms");
      }
  
      my $deprecate =
          ($] >= 5.017 and !$Config{usecperl})
          ? "Use of the encoding pragma is deprecated" : 0;
  
      my $class = shift;
      my $name  = shift;
      if (!$name){
  	require Carp;
          Carp::croak("encoding: no encoding specified.");
      }
      if ( $name eq ':_get_locale_encoding' ) {    # used by lib/open.pm
          my $caller = caller();
          {
              no strict 'refs';
              *{"${caller}::_get_locale_encoding"} = \&_get_locale_encoding;
          }
          return;
      }
      $name = _get_locale_encoding() if $name eq ':locale';
      BEGIN { strict->unimport('hashpairs') if $] >= 5.027 and $^V =~ /c$/; }
      my %arg = @_;
      $name = $ENV{PERL_ENCODING} unless defined $name;
      my $enc = find_encoding($name);
      unless ( defined $enc ) {
          require Carp;
          Carp::croak("encoding: Unknown encoding '$name'");
      }
      $name = $enc->name;    # canonize
      unless ( $arg{Filter} ) {
          if ($] >= 5.025003 and !$Config{usecperl}) {
              require Carp;
              Carp::croak("The encoding pragma is no longer supported. Check cperl");
          }
          warnings::warnif("deprecated",$deprecate) if $deprecate;
  
          DEBUG and warn "_exception($name) = ", _exception($name);
          if (! _exception($name)) {
              if (!PERL_5_21_7) {
                  ${^ENCODING} = $enc;
              }
              else {
                  # Starting with 5.21.7, this pragma uses a shadow variable
                  # designed explicitly for it, ${^E_NCODING}, to enforce
                  # lexical scope; instead of ${^ENCODING}.
                  $^H{'encoding'} = 1;
                  ${^E_NCODING} = $enc;
              }
          }
          if (! HAS_PERLIO ) {
              return 1;
          }
      }
      else {
          warnings::warnif("deprecated",$deprecate) if $deprecate;
  
          defined( ${^ENCODING} ) and undef ${^ENCODING};
          undef ${^E_NCODING} if PERL_5_21_7;
  
          # implicitly 'use utf8'
          require utf8;      # to fetch $utf8::hint_bits;
          $^H |= $utf8::hint_bits;
  
              require Filter::Util::Call;
              Filter::Util::Call->import;
              filter_add(
                  sub {
                      my $status = filter_read();
                      if ( $status > 0 ) {
                          $_ = $enc->decode( $_, 1 );
                          DEBUG and warn $_;
                      }
                      $status;
                  }
              );
      }
      defined ${^UNICODE} and ${^UNICODE} != 0 and return 1;
      for my $h (qw(STDIN STDOUT)) {
          if ( $arg{$h} ) {
              unless ( defined find_encoding( $arg{$h} ) ) {
                  require Carp;
                  Carp::croak(
                      "encoding: Unknown encoding for $h, '$arg{$h}'");
              }
              binmode( $h, ":raw :encoding($arg{$h})" );
          }
          else {
              unless ( exists $arg{$h} ) {
                      no warnings 'uninitialized';
                      binmode( $h, ":raw :encoding($name)" );
              }
          }
      }
      return 1;    # I doubt if we need it, though
  }
  
  sub unimport {
      no warnings;
      undef ${^ENCODING};
      undef ${^E_NCODING} if PERL_5_21_7;
      if (HAS_PERLIO) {
          binmode( STDIN,  ":raw" );
          binmode( STDOUT, ":raw" );
      }
      else {
          binmode(STDIN);
          binmode(STDOUT);
      }
      if ( $INC{"Filter/Util/Call.pm"} ) {
          eval { filter_del() };
      }
  }
  
  1;
  __END__
  
  =pod
  
  =head1 NAME
  
  encoding - allows you to write your script in non-ASCII and non-UTF-8
  
  =head1 WARNING
  
  This module has been deprecated since perl v5.18.  See L</DESCRIPTION> and
  L</BUGS>.
  
  =head1 SYNOPSIS
  
    use encoding "greek";  # Perl like Greek to you?
    use encoding "euc-jp"; # Jperl!
  
    # or you can even do this if your shell supports your native encoding
  
    perl -Mencoding=latin2 -e'...' # Feeling centrally European?
    perl -Mencoding=euc-kr -e'...' # Or Korean?
  
    # more control
  
    # A simple euc-cn => utf-8 converter
    use encoding "euc-cn", STDOUT => "utf8";  while(<>){print};
  
    # "no encoding;" supported
    no encoding;
  
    # an alternate way, Filter
    use encoding "euc-jp", Filter=>1;
    # now you can use kanji identifiers -- in euc-jp!
  
    # encode based on the current locale - specialized purposes only;
    # fraught with danger!!
    use encoding ':locale';
  
  =head1 DESCRIPTION
  
  This pragma is used to enable a Perl script to be written in encodings that
  aren't strictly ASCII nor UTF-8.  It translates all or portions of the Perl
  program script from a given encoding into UTF-8, and changes the PerlIO layers
  of C<STDIN> and C<STDOUT> to the encoding specified.
  
  This pragma dates from the days when UTF-8-enabled editors were uncommon.  But
  that was long ago, and the need for it is greatly diminished.  That, coupled
  with the fact that it doesn't work with threads, along with other problems,
  (see L</BUGS>) have led to its being deprecated.  It is planned to remove this
  pragma in a future Perl version.  New code should be written in UTF-8, and the
  C<use utf8> pragma used instead (see L<perluniintro> and L<utf8> for details).
  Old code should be converted to UTF-8, via something like the recipe in the
  L</SYNOPSIS> (though this simple approach may require manual adjustments
  afterwards).
  
  If UTF-8 is not an option, it is recommended that one use a simple source
  filter, such as that provided by L<Filter::Encoding> on CPAN or this
  pragma's own C<Filter> option (see below).
  
  The only legitimate use of this pragma is almost certainly just one per file,
  near the top, with file scope, as the file is likely going to only be written
  in one encoding.  Further restrictions apply in Perls before v5.22 (see
  L</Prior to Perl v5.22>).
  
  There are two basic modes of operation (plus turning if off):
  
  =over 4
  
  =item C<use encoding ['I<ENCNAME>'] ;>
  
  Please note: This mode of operation is no longer supported as of Perl
  v5.26.
  
  This is the normal operation.  It translates various literals encountered in
  the Perl source file from the encoding I<ENCNAME> into UTF-8, and similarly
  converts character code points.  This is used when the script is a combination
  of ASCII (for the variable names and punctuation, I<etc>), but the literal
  data is in the specified encoding.
  
  I<ENCNAME> is optional.  If omitted, the encoding specified in the environment
  variable L<C<PERL_ENCODING>|perlrun/PERL_ENCODING> is used.  If this isn't
  set, or the resolved-to encoding is not known to C<L<Encode>>, the error
  C<Unknown encoding 'I<ENCNAME>'> will be thrown.
  
  Starting in Perl v5.8.6 (C<Encode> version 2.0.1), I<ENCNAME> may be the
  name C<:locale>.  This is for very specialized applications, and is documented
  in L</The C<:locale> sub-pragma> below.
  
  The literals that are converted are C<q//, qq//, qr//, qw///, qx//>, and
  starting in v5.8.1, C<tr///>.  Operations that do conversions include C<chr>,
  C<ord>, C<utf8::upgrade> (but not C<utf8::downgrade>), and C<chomp>.
  
  Also starting in v5.8.1, the C<DATA> pseudo-filehandle is translated from the
  encoding into UTF-8.
  
  For example, you can write code in EUC-JP as follows:
  
    my $Rakuda = "\xF1\xD1\xF1\xCC"; # Camel in Kanji
                 #<-char-><-char->   # 4 octets
    s/\bCamel\b/$Rakuda/;
  
  And with C<use encoding "euc-jp"> in effect, it is the same thing as
  that code in UTF-8:
  
    my $Rakuda = "\x{99F1}\x{99DD}"; # two Unicode Characters
    s/\bCamel\b/$Rakuda/;
  
  See L</EXAMPLE> below for a more complete example.
  
  Unless C<${^UNICODE}> (available starting in v5.8.2) exists and is non-zero, the
  PerlIO layers of C<STDIN> and C<STDOUT> are set to "C<:encoding(I<ENCNAME>)>".
  Therefore,
  
    use encoding "euc-jp";
    my $message = "Camel is the symbol of perl.\n";
    my $Rakuda = "\xF1\xD1\xF1\xCC"; # Camel in Kanji
    $message =~ s/\bCamel\b/$Rakuda/;
    print $message;
  
  will print
  
   "\xF1\xD1\xF1\xCC is the symbol of perl.\n"
  
  not
  
   "\x{99F1}\x{99DD} is the symbol of perl.\n"
  
  You can override this by giving extra arguments; see below.
  
  Note that C<STDERR> WILL NOT be changed, regardless.
  
  Also note that non-STD file handles remain unaffected.  Use C<use
  open> or C<binmode> to change the layers of those.
  
  =item C<use encoding I<ENCNAME>, Filter=E<gt>1;>
  
  This operates as above, but the C<Filter> argument with a non-zero
  value causes the entire script, and not just literals, to be translated from
  the encoding into UTF-8.  This allows identifiers in the source to be in that
  encoding as well.  (Problems may occur if the encoding is not a superset of
  ASCII; imagine all your semi-colons being translated into something
  different.)  One can use this form to make
  
   ${"\x{4eba}"}++
  
  work.  (This is equivalent to C<$I<human>++>, where I<human> is a single Han
  ideograph).
  
  This effectively means that your source code behaves as if it were written in
  UTF-8 with C<'use utf8>' in effect.  So even if your editor only supports
  Shift_JIS, for example, you can still try examples in Chapter 15 of
  C<Programming Perl, 3rd Ed.>.
  
  This option is significantly slower than the other one.
  
  =item C<no encoding;>
  
  Unsets the script encoding. The layers of C<STDIN>, C<STDOUT> are
  reset to "C<:raw>" (the default unprocessed raw stream of bytes).
  
  =back
  
  =head1 OPTIONS
  
  =head2 Setting C<STDIN> and/or C<STDOUT> individually
  
  The encodings of C<STDIN> and C<STDOUT> are individually settable by parameters to
  the pragma:
  
   use encoding 'euc-tw', STDIN => 'greek'  ...;
  
  In this case, you cannot omit the first I<ENCNAME>.  C<< STDIN => undef >>
  turns the I/O transcoding completely off for that filehandle.
  
  When C<${^UNICODE}> (available starting in v5.8.2) exists and is non-zero,
  these options will be completely ignored.  See L<perlvar/C<${^UNICODE}>> and
  L<"C<-C>" in perlrun|perlrun/-C [numberE<sol>list]> for details.
  
  =head2 The C<:locale> sub-pragma
  
  Starting in v5.8.6, the encoding name may be C<:locale>.  This means that the
  encoding is taken from the current locale, and not hard-coded by the pragma.
  Since a script really can only be encoded in exactly one encoding, this option
  is dangerous.  It makes sense only if the script itself is written in ASCII,
  and all the possible locales that will be in use when the script is executed
  are supersets of ASCII.  That means that the script itself doesn't get
  changed, but the I/O handles have the specified encoding added, and the
  operations like C<chr> and C<ord> use that encoding.
  
  The logic of finding which locale C<:locale> uses is as follows:
  
  =over 4
  
  =item 1.
  
  If the platform supports the C<langinfo(CODESET)> interface, the codeset
  returned is used as the default encoding for the open pragma.
  
  =item 2.
  
  If 1. didn't work but we are under the locale pragma, the environment
  variables C<LC_ALL> and C<LANG> (in that order) are matched for encodings
  (the part after "C<.>", if any), and if any found, that is used
  as the default encoding for the open pragma.
  
  =item 3.
  
  If 1. and 2. didn't work, the environment variables C<LC_ALL> and C<LANG>
  (in that order) are matched for anything looking like UTF-8, and if
  any found, C<:utf8> is used as the default encoding for the open
  pragma.
  
  =back
  
  If your locale environment variables (C<LC_ALL>, C<LC_CTYPE>, C<LANG>)
  contain the strings 'UTF-8' or 'UTF8' (case-insensitive matching),
  the default encoding of your C<STDIN>, C<STDOUT>, and C<STDERR>, and of
  B<any subsequent file open>, is UTF-8.
  
  =head1 CAVEATS
  
  =head2 SIDE EFFECTS
  
  =over
  
  =item *
  
  If the C<encoding> pragma is in scope then the lengths returned are
  calculated from the length of C<$/> in Unicode characters, which is not
  always the same as the length of C<$/> in the native encoding.
  
  =item *
  
  Without this pragma, if strings operating under byte semantics and strings
  with Unicode character data are concatenated, the new string will
  be created by decoding the byte strings as I<ISO 8859-1 (Latin-1)>.
  
  The B<encoding> pragma changes this to use the specified encoding
  instead.  For example:
  
      use encoding 'utf8';
      my $string = chr(20000); # a Unicode string
      utf8::encode($string);   # now it's a UTF-8 encoded byte string
      # concatenate with another Unicode string
      print length($string . chr(20000));
  
  Will print C<2>, because C<$string> is upgraded as UTF-8.  Without
  C<use encoding 'utf8';>, it will print C<4> instead, since C<$string>
  is three octets when interpreted as Latin-1.
  
  =back
  
  =head2 DO NOT MIX MULTIPLE ENCODINGS
  
  Notice that only literals (string or regular expression) having only
  legacy code points are affected: if you mix data like this
  
      \x{100}\xDF
      \xDF\x{100}
  
  the data is assumed to be in (Latin 1 and) Unicode, not in your native
  encoding.  In other words, this will match in "greek":
  
      "\xDF" =~ /\x{3af}/
  
  but this will not
  
      "\xDF\x{100}" =~ /\x{3af}\x{100}/
  
  since the C<\xDF> (ISO 8859-7 GREEK SMALL LETTER IOTA WITH TONOS) on
  the left will B<not> be upgraded to C<\x{3af}> (Unicode GREEK SMALL
  LETTER IOTA WITH TONOS) because of the C<\x{100}> on the left.  You
  should not be mixing your legacy data and Unicode in the same string.
  
  This pragma also affects encoding of the 0x80..0xFF code point range:
  normally characters in that range are left as eight-bit bytes (unless
  they are combined with characters with code points 0x100 or larger,
  in which case all characters need to become UTF-8 encoded), but if
  the C<encoding> pragma is present, even the 0x80..0xFF range always
  gets UTF-8 encoded.
  
  After all, the best thing about this pragma is that you don't have to
  resort to \x{....} just to spell your name in a native encoding.
  So feel free to put your strings in your encoding in quotes and
  regexes.
  
  =head2 Prior to Perl v5.22
  
  The pragma was a per script, not a per block lexical.  Only the last
  C<use encoding> or C<no encoding> mattered, and it affected
  B<the whole script>.  However, the C<no encoding> pragma was supported and
  C<use encoding> could appear as many times as you want in a given script
  (though only the last was effective).
  
  Since the scope wasn't lexical, other modules' use of C<chr>, C<ord>, I<etc.>
  were affected.  This leads to spooky, incorrect action at a distance that is
  hard to debug.
  
  This means you would have to be very careful of the load order:
  
    # called module
    package Module_IN_BAR;
    use encoding "bar";
    # stuff in "bar" encoding here
    1;
  
    # caller script
    use encoding "foo"
    use Module_IN_BAR;
    # surprise! use encoding "bar" is in effect.
  
  The best way to avoid this oddity is to use this pragma RIGHT AFTER
  other modules are loaded.  i.e.
  
    use Module_IN_BAR;
    use encoding "foo";
  
  =head2 Prior to Encode version 1.87
  
  =over
  
  =item *
  
  C<STDIN> and C<STDOUT> were not set under the filter option.
  And C<< STDIN=>I<ENCODING> >> and C<< STDOUT=>I<ENCODING> >> didn't work like
  non-filter version.
  
  =item *
  
  C<use utf8> wasn't implicitly declared so you have to C<use utf8> to do
  
   ${"\x{4eba}"}++
  
  =back
  
  =head2 Prior to Perl v5.8.1
  
  =over
  
  =item "NON-EUC" doublebyte encodings
  
  Because perl needs to parse the script before applying this pragma, such
  encodings as Shift_JIS and Big-5 that may contain C<'\'> (BACKSLASH;
  C<\x5c>) in the second byte fail because the second byte may
  accidentally escape the quoting character that follows.
  
  =item C<tr///>
  
  The B<encoding> pragma works by decoding string literals in
  C<q//,qq//,qr//,qw///, qx//> and so forth.  In perl v5.8.0, this
  does not apply to C<tr///>.  Therefore,
  
    use encoding 'euc-jp';
    #....
    $kana =~ tr/\xA4\xA1-\xA4\xF3/\xA5\xA1-\xA5\xF3/;
    #           -------- -------- -------- --------
  
  Does not work as
  
    $kana =~ tr/\x{3041}-\x{3093}/\x{30a1}-\x{30f3}/;
  
  =over
  
  =item Legend of characters above
  
    utf8     euc-jp   charnames::viacode()
    -----------------------------------------
    \x{3041} \xA4\xA1 HIRAGANA LETTER SMALL A
    \x{3093} \xA4\xF3 HIRAGANA LETTER N
    \x{30a1} \xA5\xA1 KATAKANA LETTER SMALL A
    \x{30f3} \xA5\xF3 KATAKANA LETTER N
  
  =back
  
  This counterintuitive behavior has been fixed in perl v5.8.1.
  
  In perl v5.8.0, you can work around this as follows;
  
    use encoding 'euc-jp';
    #  ....
    eval qq{ \$kana =~ tr/\xA4\xA1-\xA4\xF3/\xA5\xA1-\xA5\xF3/ };
  
  Note the C<tr//> expression is surrounded by C<qq{}>.  The idea behind
  this is the same as the classic idiom that makes C<tr///> 'interpolate':
  
     tr/$from/$to/;            # wrong!
     eval qq{ tr/$from/$to/ }; # workaround.
  
  =back
  
  =head1 EXAMPLE - Greekperl
  
      use encoding "iso 8859-7";
  
      # \xDF in ISO 8859-7 (Greek) is \x{3af} in Unicode.
  
      $a = "\xDF";
      $b = "\x{100}";
  
      printf "%#x\n", ord($a); # will print 0x3af, not 0xdf
  
      $c = $a . $b;
  
      # $c will be "\x{3af}\x{100}", not "\x{df}\x{100}".
  
      # chr() is affected, and ...
  
      print "mega\n"  if ord(chr(0xdf)) == 0x3af;
  
      # ... ord() is affected by the encoding pragma ...
  
      print "tera\n" if ord(pack("C", 0xdf)) == 0x3af;
  
      # ... as are eq and cmp ...
  
      print "peta\n" if "\x{3af}" eq  pack("C", 0xdf);
      print "exa\n"  if "\x{3af}" cmp pack("C", 0xdf) == 0;
  
      # ... but pack/unpack C are not affected, in case you still
      # want to go back to your native encoding
  
      print "zetta\n" if unpack("C", (pack("C", 0xdf))) == 0xdf;
  
  =head1 BUGS
  
  =over
  
  =item Thread safety
  
  C<use encoding ...> is not thread-safe (i.e., do not use in threaded
  applications).
  
  =item Can't be used by more than one module in a single program.
  
  Only one encoding is allowed.  If you combine modules in a program that have
  different encodings, only one will be actually used.
  
  =item Other modules using C<STDIN> and C<STDOUT> get the encoded stream
  
  They may be expecting something completely different.
  
  =item literals in regex that are longer than 127 bytes
  
  For native multibyte encodings (either fixed or variable length),
  the current implementation of the regular expressions may introduce
  recoding errors for regular expression literals longer than 127 bytes.
  
  =item EBCDIC
  
  The encoding pragma is not supported on EBCDIC platforms.
  
  =item C<format>
  
  This pragma doesn't work well with C<format> because PerlIO does not
  get along very well with it.  When C<format> contains non-ASCII
  characters it prints funny or gets "wide character warnings".
  To understand it, try the code below.
  
    # Save this one in utf8
    # replace *non-ascii* with a non-ascii string
    my $camel;
    format STDOUT =
    *non-ascii*@>>>>>>>
    $camel
    .
    $camel = "*non-ascii*";
    binmode(STDOUT=>':encoding(utf8)'); # bang!
    write;              # funny
    print $camel, "\n"; # fine
  
  Without binmode this happens to work but without binmode, print()
  fails instead of write().
  
  At any rate, the very use of C<format> is questionable when it comes to
  unicode characters since you have to consider such things as character
  width (i.e. double-width for ideographs) and directions (i.e. BIDI for
  Arabic and Hebrew).
  
  =item See also L</CAVEATS>
  
  =back
  
  =head1 HISTORY
  
  This pragma first appeared in Perl v5.8.0.  It has been enhanced in later
  releases as specified above.
  
  =head1 SEE ALSO
  
  L<perlunicode>, L<Encode>, L<open>, L<Filter::Util::Call>,
  
  Ch. 15 of C<Programming Perl (3rd Edition)>
  by Larry Wall, Tom Christiansen, Jon Orwant;
  O'Reilly & Associates; ISBN 0-596-00027-8
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_ENCODING

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


use v5.36;
use utf8;
use strictures 2; # nice `use strict`, `use warnings` defaults
use open qw(:utf8); # try to use Perl's internal Unicode encoding for everything
BEGIN{$diagnostics::PRETTY = 1} # a bit noisy, but somewhat informative
use diagnostics -verbose;

# Carp
    use Carp;
    use Carp::Assert;
# filepath functions
    use Cwd qw(abs_path);
    use File::Basename qw(basename dirname);
    use File::Spec;
# misc file utilities
    use File::Temp;
    use File::Slurp;
# misc scripting IO utilities
    use IO::Prompter;
    # `capture_stdout` for backticks w/o shell (escaping issues)
    use Capture::Tiny qw(:all);
    # for more complicated stuff
    # eg timeout, redirection
    use IPC::Run qw(run);
    use IPC::Cmd qw(can_run);
# option/arg handling
    use Getopt::Long qw(:config gnu_getopt auto_version); # auto_help not the greatest
    use Pod::Usage;
# use local modules
    use lib (
        dirname(abs_path($0)),
        ); # https://stackoverflow.com/a/46550384
 
# turn on features
    use builtin qw(true false is_bool reftype);
    no warnings 'experimental::builtin';
    use feature 'try';
    no warnings 'experimental::try';

    our $VERSION = version->declare('v2023.05.01');
# end prelude

my @builds = glob 'Gradescope-Utils-*';
@builds = grep {m/^Gradescope-Utils-([\d\.]+)(\.tar\.gz)?$/} @builds;
say STDERR '[debug] found versions:';
say for @builds;
my @versions = map {m/^Gradescope-Utils-([\d\.]+)(\.tar\.gz)?$/; version->parse($1)} @builds;
@versions = sort @versions;
my $latest_version = pop @versions;
should($latest_version->stringify, "$latest_version"); # I'm a bit nervous about how version objects are handled
say STDERR "[debug] using version: $latest_version";
# NOTE: we could use the perl equivalents for portability, but I'm assuming so much *nix anyways, there's no point
# (ie sorry windows users)
my $local_share = File::Spec->catdir($ENV{HOME}, '.local', 'share', 'gradescope-utils');
my $confirm_overwrite_install = sub{
    if(-e $local_share){
        my $confirm = IO::Prompter::prompt(
            "Confirm: update existing install at '$local_share'? (y/N)? ",
            -in => *STDIN
        );
        croak '[error] user cancelled' if $confirm ne 'y';
    }
    else{
        run ['mkdir', '-p', $local_share] or croak '[error] `mkdir` failed';
    }
};
@builds = grep {m/^Gradescope-Utils-$latest_version(\.tar\.gz)?$/} @builds;
# prefer the regular build dir over the tar 'd one, if it exists
if(grep {m/^Gradescope-Utils-$latest_version$/} @builds){
    say STDERR "[debug] using build at 'Gradescope-Utils-$latest_version/'";
    &$confirm_overwrite_install;
    run ['cp', '-rT', "Gradescope-Utils-$latest_version", $local_share] or croak '[error] `cp` failed';
}
elsif(grep {m/\.tar\.gz$/} @builds){
    say STDERR "[debug] using build at 'Gradescope-Utils-$latest_version.tar.gz'";
    &$confirm_overwrite_install;
    my $tmpdir = File::Temp->newdir();
    run ['tar', '-xf', "Gradescope-Utils-$latest_version.tar.gz", '-C', $tmpdir] or croak '[error] `tar` failed';
    run ['cp', '-rT', File::Spec->catdir($tmpdir, "Gradescope-Utils-$latest_version"), $local_share] or croak '[error] `cp` failed';
}
else{
    croak '[error] no suitable builds found';
}

my $local_bin = File::Spec->catdir($ENV{HOME}, '.local', 'bin');
if(!-e $local_bin){
    run ['mkdir', '-p', File::Spec->catdir($ENV{HOME}, '.local', 'bin')] or croak '[error] `mkdir` failed';
}
run ['ln', '-fs', File::Spec->catfile($local_share, 'bin', 'gradescope-utils.pl'), File::Spec->catfile($ENV{HOME}, '.local', 'bin', 'gu')] or croak '[error] `ln` failed';

=pod

=encoding utf8

=head1 NAME

=head1 SYNOPSIS

=head1 DESCRIPTION

=cut
