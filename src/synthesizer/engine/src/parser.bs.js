// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var $$String = require("bs-platform/lib/js/string.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");

function make_list(n, f) {
  var out = /* [] */0;
  for(var i = n - 1 | 0; i >= 0; --i){
    out = /* :: */[
      Curry._1(f, i),
      out
    ];
  }
  return out;
}

function explode(str) {
  return make_list(str.length, (function (param) {
                return Caml_string.get(str, param);
              }));
}

function implode(cs) {
  return $$String.init(List.length(cs), (function (param) {
                return List.nth(cs, param);
              }));
}

function skip_whitespace(_cs) {
  while(true) {
    var cs = _cs;
    if (!cs) {
      return cs;
    }
    var match = cs[0];
    if (match < 46) {
      var switcher = match - 11 | 0;
      if (switcher > 32 || switcher < 0) {
        if (switcher < -2) {
          return cs;
        }
        _cs = cs[1];
        continue ;
      }
      if (switcher < 21) {
        return cs;
      }
      switch (switcher - 21 | 0) {
        case 0 :
        case 8 :
        case 9 :
            _cs = cs[1];
            continue ;
        case 1 :
        case 2 :
        case 3 :
        case 4 :
        case 5 :
        case 6 :
        case 7 :
        case 10 :
        case 11 :
            return cs;
        
      }
    } else {
      if (match !== 60) {
        if (match !== 62) {
          return cs;
        }
        _cs = cs[1];
        continue ;
      }
      _cs = cs[1];
      continue ;
    }
  };
}

function parse_token(x) {
  var parse_token_r = function (_x, _y) {
    while(true) {
      var y = _y;
      var x = _x;
      if (!x) {
        return /* tuple */[
                x,
                y
              ];
      }
      var match = x[0];
      if (match >= 48) {
        if (match >= 58) {
          return /* tuple */[
                  x,
                  y
                ];
        }
        
      } else if (match !== 46) {
        return /* tuple */[
                x,
                y
              ];
      }
      _y = /* :: */[
        List.hd(x),
        y
      ];
      _x = List.tl(x);
      continue ;
    };
  };
  var match = parse_token_r(skip_whitespace(x), /* [] */0);
  return /* tuple */[
          implode(List.rev(match[1])),
          match[0]
        ];
}

function parse_context(_x) {
  while(true) {
    var x = _x;
    if (!x) {
      return /* tuple */[
              /* [] */0,
              x
            ];
    }
    var match = x[0];
    if (match >= 11) {
      switch (match) {
        case 48 :
        case 49 :
        case 50 :
        case 51 :
        case 52 :
        case 53 :
        case 54 :
        case 55 :
        case 56 :
        case 57 :
            break;
        case 33 :
        case 34 :
        case 35 :
        case 36 :
        case 37 :
        case 38 :
        case 39 :
        case 42 :
        case 43 :
        case 46 :
        case 47 :
        case 58 :
        case 59 :
        case 61 :
            return /* tuple */[
                    /* [] */0,
                    x
                  ];
        case 32 :
        case 40 :
        case 41 :
        case 44 :
        case 45 :
        case 60 :
        case 62 :
            _x = x[1];
            continue ;
        default:
          return /* tuple */[
                  /* [] */0,
                  x
                ];
      }
    } else {
      if (match < 9) {
        return /* tuple */[
                /* [] */0,
                x
              ];
      }
      _x = x[1];
      continue ;
    }
    var match$1 = parse_int(x);
    var match$2 = parse_type_(match$1[1]);
    var match$3 = parse_ann(match$2[1]);
    var match$4 = parse_context(match$3[1]);
    return /* tuple */[
            /* :: */[
              /* tuple */[
                match$1[0],
                /* tuple */[
                  match$2[0],
                  match$3[0]
                ]
              ],
              match$4[0]
            ],
            match$4[1]
          ];
  };
}

function parse_int(x) {
  var match = parse_token(x);
  return /* tuple */[
          Caml_format.caml_int_of_string(match[0]),
          match[1]
        ];
}

function parse_type_(_x) {
  while(true) {
    var x = _x;
    if (x) {
      var match = x[0];
      if (match < 60) {
        var switcher = match - 11 | 0;
        if (switcher > 32 || switcher < 0) {
          if ((switcher + 2 >>> 0) <= 36) {
            _x = x[1];
            continue ;
          }
          
        } else if (switcher >= 21) {
          switch (switcher - 21 | 0) {
            case 0 :
            case 8 :
            case 9 :
                _x = x[1];
                continue ;
            case 1 :
            case 2 :
            case 3 :
            case 4 :
            case 5 :
            case 6 :
            case 7 :
            case 10 :
            case 11 :
                break;
            
          }
        }
        
      } else if (match >= 63) {
        switch (match) {
          case 97 :
              return /* tuple */[
                      /* Any_t */4,
                      x[1]
                    ];
          case 98 :
              return /* tuple */[
                      /* Bool_t */2,
                      x[1]
                    ];
          case 99 :
              var match$1 = parse_type_(x[1]);
              var match$2 = parse_type_(match$1[1]);
              return /* tuple */[
                      /* Cons_t */Block.__(0, [
                          match$1[0],
                          match$2[0]
                        ]),
                      match$2[1]
                    ];
          case 100 :
              var match$3 = parse_adt(x[1]);
              return /* tuple */[
                      /* D */Block.__(3, [match$3[0]]),
                      match$3[1]
                    ];
          case 102 :
              var x$1 = x[1];
              var exit = 0;
              if (x$1 && x$1[0] === 97) {
                var match$4 = x$1[1];
                if (match$4 && match$4[0] === 105) {
                  var match$5 = match$4[1];
                  if (match$5) {
                    if (match$5[0] === 108) {
                      return /* tuple */[
                              /* Fail_t */5,
                              match$5[1]
                            ];
                    }
                    exit = 2;
                  } else {
                    exit = 2;
                  }
                } else {
                  exit = 2;
                }
              } else {
                exit = 2;
              }
              if (exit === 2) {
                var match$6 = parse_type_(x$1);
                var match$7 = parse_type_(match$6[1]);
                return /* tuple */[
                        /* Function_t */Block.__(1, [
                            match$6[0],
                            match$7[0]
                          ]),
                        match$7[1]
                      ];
              }
              break;
          case 105 :
              return /* tuple */[
                      /* Int_t */0,
                      x[1]
                    ];
          case 112 :
              var match$8 = parse_type_(x[1]);
              var match$9 = parse_type_(match$8[1]);
              return /* tuple */[
                      /* Pair_t */Block.__(2, [
                          match$8[0],
                          match$9[0]
                        ]),
                      match$9[1]
                    ];
          case 101 :
          case 103 :
          case 104 :
          case 106 :
          case 107 :
          case 108 :
          case 109 :
          case 110 :
          case 111 :
          case 113 :
          case 114 :
          case 115 :
          case 116 :
              break;
          case 117 :
              return /* tuple */[
                      /* Unit_t */3,
                      x[1]
                    ];
          default:
            
        }
      } else if (match !== 61) {
        _x = x[1];
        continue ;
      }
      
    }
    return Pervasives.failwith("Some code generated by parser_generator.py is throwing a parse error:\nWhile parsing a/an type_, I got \"" + (implode(x) + "\" which doesn't match any of the expected tags: ['fail', 'i', 'b', 'c', 'f', 'u', 'p', 'a', 'd']"));
  };
}

function parse_ann(_x) {
  while(true) {
    var x = _x;
    if (x) {
      var match = x[0];
      if (match < 60) {
        var switcher = match - 11 | 0;
        if (switcher > 32 || switcher < 0) {
          if ((switcher + 2 >>> 0) <= 36) {
            _x = x[1];
            continue ;
          }
          
        } else if (switcher >= 21) {
          switch (switcher - 21 | 0) {
            case 0 :
            case 8 :
            case 9 :
                _x = x[1];
                continue ;
            case 1 :
            case 2 :
            case 3 :
            case 4 :
            case 5 :
            case 6 :
            case 7 :
            case 10 :
            case 11 :
                break;
            
          }
        }
        
      } else if (match >= 63) {
        if (match === 97) {
          return /* tuple */[
                  /* AnnNone */0,
                  x[1]
                ];
        }
        
      } else if (match !== 61) {
        _x = x[1];
        continue ;
      }
      
    }
    return Pervasives.failwith("Some code generated by parser_generator.py is throwing a parse error:\nWhile parsing a/an ann, I got \"" + (implode(x) + "\" which doesn't match any of the expected tags: ['a', 'a', 'a', 'a']"));
  };
}

function parse_environment(_x) {
  while(true) {
    var x = _x;
    if (!x) {
      return /* tuple */[
              /* [] */0,
              x
            ];
    }
    var match = x[0];
    if (match >= 11) {
      switch (match) {
        case 48 :
        case 49 :
        case 50 :
        case 51 :
        case 52 :
        case 53 :
        case 54 :
        case 55 :
        case 56 :
        case 57 :
            break;
        case 59 :
            return /* tuple */[
                    /* [] */0,
                    x[1]
                  ];
        case 33 :
        case 34 :
        case 35 :
        case 36 :
        case 37 :
        case 38 :
        case 39 :
        case 42 :
        case 43 :
        case 46 :
        case 47 :
        case 58 :
        case 61 :
            return /* tuple */[
                    /* [] */0,
                    x
                  ];
        case 32 :
        case 40 :
        case 41 :
        case 44 :
        case 45 :
        case 60 :
        case 62 :
            _x = x[1];
            continue ;
        default:
          return /* tuple */[
                  /* [] */0,
                  x
                ];
      }
    } else {
      if (match < 9) {
        return /* tuple */[
                /* [] */0,
                x
              ];
      }
      _x = x[1];
      continue ;
    }
    var match$1 = parse_int(x);
    var match$2 = parse_res(match$1[1]);
    var match$3 = parse_environment(match$2[1]);
    return /* tuple */[
            /* :: */[
              /* tuple */[
                match$1[0],
                match$2[0]
              ],
              match$3[0]
            ],
            match$3[1]
          ];
  };
}

function parse_res(_x) {
  while(true) {
    var x = _x;
    if (x) {
      var match = x[0];
      if (match >= 44) {
        if (match >= 60) {
          if (match < 118) {
            switch (match - 60 | 0) {
              case 0 :
              case 2 :
                  _x = x[1];
                  continue ;
              case 37 :
                  var match$1 = parse_res(x[1]);
                  var match$2 = parse_res(match$1[1]);
                  return /* tuple */[
                          /* Rapp */Block.__(5, [
                              match$1[0],
                              match$2[0]
                            ]),
                          match$2[1]
                        ];
              case 38 :
                  var match$3 = parse_bool(x[1]);
                  return /* tuple */[
                          /* Rbool */Block.__(2, [match$3[0]]),
                          match$3[1]
                        ];
              case 39 :
                  var x$1 = x[1];
                  var exit = 0;
                  if (x$1) {
                    var match$4 = x$1[0];
                    if (match$4 !== 97) {
                      if (match$4 !== 116) {
                        exit = 2;
                      } else {
                        var match$5 = x$1[1];
                        if (match$5 && match$5[0] === 111) {
                          var match$6 = match$5[1];
                          if (match$6 && match$6[0] === 114) {
                            var match$7 = parse_int(match$6[1]);
                            var match$8 = parse_adt(match$7[1]);
                            var match$9 = parse_res(match$8[1]);
                            return /* tuple */[
                                    /* Rctor */Block.__(10, [
                                        match$7[0],
                                        match$8[0],
                                        match$9[0]
                                      ]),
                                    match$9[1]
                                  ];
                          }
                          exit = 2;
                        } else {
                          exit = 2;
                        }
                      }
                    } else {
                      var match$10 = x$1[1];
                      if (match$10 && match$10[0] === 115) {
                        var match$11 = match$10[1];
                        if (match$11 && match$11[0] === 101) {
                          var match$12 = parse_res(match$11[1]);
                          var match$13 = parse_branches(match$12[1]);
                          var match$14 = parse_environment(match$13[1]);
                          return /* tuple */[
                                  /* Rcase */Block.__(12, [
                                      match$12[0],
                                      match$13[0],
                                      match$14[0]
                                    ]),
                                  match$14[1]
                                ];
                        }
                        exit = 2;
                      } else {
                        exit = 2;
                      }
                    }
                  } else {
                    exit = 2;
                  }
                  if (exit === 2) {
                    var match$15 = parse_res(x$1);
                    var match$16 = parse_res(match$15[1]);
                    return /* tuple */[
                            /* Rcons */Block.__(3, [
                                match$15[0],
                                match$16[0]
                              ]),
                            match$16[1]
                          ];
                  }
                  break;
              case 42 :
                  var x$2 = x[1];
                  var exit$1 = 0;
                  if (x$2) {
                    var match$17 = x$2[0];
                    if (match$17 !== 108) {
                      if (match$17 !== 115) {
                        exit$1 = 2;
                      } else {
                        var match$18 = x$2[1];
                        if (match$18 && match$18[0] === 116) {
                          var match$19 = parse_res(match$18[1]);
                          return /* tuple */[
                                  /* Rfst */Block.__(8, [match$19[0]]),
                                  match$19[1]
                                ];
                        }
                        exit$1 = 2;
                      }
                    } else {
                      var match$20 = x$2[1];
                      if (match$20 && match$20[0] === 111) {
                        var match$21 = match$20[1];
                        if (match$21 && match$21[0] === 97) {
                          var match$22 = match$21[1];
                          if (match$22 && match$22[0] === 116) {
                            var match$23 = parse_float(match$22[1]);
                            return /* tuple */[
                                    /* Rfloat */Block.__(1, [match$23[0]]),
                                    match$23[1]
                                  ];
                          }
                          exit$1 = 2;
                        } else {
                          exit$1 = 2;
                        }
                      } else {
                        exit$1 = 2;
                      }
                    }
                  } else {
                    exit$1 = 2;
                  }
                  if (exit$1 === 2) {
                    var match$24 = parse_int(x$2);
                    var match$25 = parse_int(match$24[1]);
                    var match$26 = parse_type_(match$25[1]);
                    var match$27 = parse_exp(match$26[1]);
                    var match$28 = parse_environment(match$27[1]);
                    return /* tuple */[
                            /* Rfunc */Block.__(4, [
                                match$24[0],
                                match$25[0],
                                match$26[0],
                                match$27[0],
                                match$28[0]
                              ]),
                            match$28[1]
                          ];
                  }
                  break;
              case 44 :
                  var match$29 = parse_int(x[1]);
                  var match$30 = parse_environment(match$29[1]);
                  return /* tuple */[
                          /* Rhole */Block.__(6, [
                              match$29[0],
                              match$30[0]
                            ]),
                          match$30[1]
                        ];
              case 45 :
                  var x$3 = x[1];
                  var exit$2 = 0;
                  if (x$3 && x$3[0] === 99) {
                    var match$31 = x$3[1];
                    if (match$31 && match$31[0] === 116) {
                      var match$32 = match$31[1];
                      if (match$32 && match$32[0] === 111) {
                        var match$33 = match$32[1];
                        if (match$33 && match$33[0] === 114) {
                          var match$34 = parse_int(match$33[1]);
                          var match$35 = parse_adt(match$34[1]);
                          var match$36 = parse_res(match$35[1]);
                          return /* tuple */[
                                  /* Rictor */Block.__(11, [
                                      match$34[0],
                                      match$35[0],
                                      match$36[0]
                                    ]),
                                  match$36[1]
                                ];
                        }
                        exit$2 = 2;
                      } else {
                        exit$2 = 2;
                      }
                    } else {
                      exit$2 = 2;
                    }
                  } else {
                    exit$2 = 2;
                  }
                  if (exit$2 === 2) {
                    var match$37 = parse_int(x$3);
                    return /* tuple */[
                            /* Rint */Block.__(0, [match$37[0]]),
                            match$37[1]
                          ];
                  }
                  break;
              case 50 :
                  return /* tuple */[
                          /* Rnil */0,
                          x[1]
                        ];
              case 52 :
                  var match$38 = parse_res(x[1]);
                  var match$39 = parse_res(match$38[1]);
                  return /* tuple */[
                          /* Rpair */Block.__(7, [
                              match$38[0],
                              match$39[0]
                            ]),
                          match$39[1]
                        ];
              case 55 :
                  var match$40 = parse_res(x[1]);
                  return /* tuple */[
                          /* Rsnd */Block.__(9, [match$40[0]]),
                          match$40[1]
                        ];
              case 1 :
              case 3 :
              case 4 :
              case 5 :
              case 6 :
              case 7 :
              case 8 :
              case 9 :
              case 10 :
              case 11 :
              case 12 :
              case 13 :
              case 14 :
              case 15 :
              case 16 :
              case 17 :
              case 18 :
              case 19 :
              case 20 :
              case 21 :
              case 22 :
              case 23 :
              case 24 :
              case 25 :
              case 26 :
              case 27 :
              case 28 :
              case 29 :
              case 30 :
              case 31 :
              case 32 :
              case 33 :
              case 34 :
              case 35 :
              case 36 :
              case 40 :
              case 41 :
              case 43 :
              case 46 :
              case 47 :
              case 48 :
              case 49 :
              case 51 :
              case 53 :
              case 54 :
              case 56 :
                  break;
              case 57 :
                  return /* tuple */[
                          /* Runit */1,
                          x[1]
                        ];
              
            }
          }
          
        } else if (match < 46) {
          _x = x[1];
          continue ;
        }
        
      } else if (match >= 11) {
        if (match >= 32) {
          switch (match - 32 | 0) {
            case 0 :
            case 8 :
            case 9 :
                _x = x[1];
                continue ;
            case 1 :
            case 2 :
            case 3 :
            case 4 :
            case 5 :
            case 6 :
            case 7 :
            case 10 :
            case 11 :
                break;
            
          }
        }
        
      } else if (match >= 9) {
        _x = x[1];
        continue ;
      }
      
    }
    return Pervasives.failwith("Some code generated by parser_generator.py is throwing a parse error:\nWhile parsing a/an res, I got \"" + (implode(x) + "\" which doesn't match any of the expected tags: ['float', 'ictor', 'ctor', 'case', 'fst', 'i', 'b', 'c', 'n', 'f', 'a', 'h', 'u', 'p', 's']"));
  };
}

function parse_pattern(_x) {
  while(true) {
    var x = _x;
    if (x) {
      var match = x[0];
      if (match >= 61) {
        if (match !== 62) {
          if (match !== 112) {
            if (match === 118) {
              var match$1 = parse_int(x[1]);
              return /* tuple */[
                      /* V */Block.__(0, [match$1[0]]),
                      match$1[1]
                    ];
            }
            
          } else {
            var match$2 = parse_pattern(x[1]);
            var match$3 = parse_pattern(match$2[1]);
            return /* tuple */[
                    /* P */Block.__(1, [
                        match$2[0],
                        match$3[0]
                      ]),
                    match$3[1]
                  ];
          }
        } else {
          _x = x[1];
          continue ;
        }
      } else if (match >= 32) {
        if (match >= 46) {
          if (match >= 60) {
            _x = x[1];
            continue ;
          }
          
        } else {
          if (match >= 44) {
            _x = x[1];
            continue ;
          }
          switch (match - 32 | 0) {
            case 0 :
            case 8 :
            case 9 :
                _x = x[1];
                continue ;
            case 1 :
            case 2 :
            case 3 :
            case 4 :
            case 5 :
            case 6 :
            case 7 :
            case 10 :
            case 11 :
                break;
            
          }
        }
      } else if (match === 10 || match === 9) {
        _x = x[1];
        continue ;
      }
      
    }
    return Pervasives.failwith("Some code generated by parser_generator.py is throwing a parse error:\nWhile parsing a/an pattern, I got \"" + (implode(x) + "\" which doesn't match any of the expected tags: ['v', 'p']"));
  };
}

function parse_adt(_x) {
  while(true) {
    var x = _x;
    if (x) {
      var match = x[0];
      if (match >= 61) {
        if (match !== 62) {
          if (match >= 108) {
            if (match < 111) {
              switch (match - 108 | 0) {
                case 0 :
                    return /* tuple */[
                            /* List */0,
                            x[1]
                          ];
                case 1 :
                    break;
                case 2 :
                    return /* tuple */[
                            /* Num */1,
                            x[1]
                          ];
                
              }
            }
            
          } else if (match === 98) {
            return /* tuple */[
                    /* Bool */2,
                    x[1]
                  ];
          }
          
        } else {
          _x = x[1];
          continue ;
        }
      } else if (match >= 32) {
        if (match >= 46) {
          if (match >= 60) {
            _x = x[1];
            continue ;
          }
          
        } else {
          if (match >= 44) {
            _x = x[1];
            continue ;
          }
          switch (match - 32 | 0) {
            case 0 :
            case 8 :
            case 9 :
                _x = x[1];
                continue ;
            case 1 :
            case 2 :
            case 3 :
            case 4 :
            case 5 :
            case 6 :
            case 7 :
            case 10 :
            case 11 :
                break;
            
          }
        }
      } else if (match === 10 || match === 9) {
        _x = x[1];
        continue ;
      }
      
    }
    return Pervasives.failwith("Some code generated by parser_generator.py is throwing a parse error:\nWhile parsing a/an adt, I got \"" + (implode(x) + "\" which doesn't match any of the expected tags: ['l', 'n', 'b']"));
  };
}

function parse_branches(_x) {
  while(true) {
    var x = _x;
    if (!x) {
      return /* tuple */[
              /* [] */0,
              x
            ];
    }
    var match = x[0];
    if (match >= 11) {
      switch (match) {
        case 48 :
        case 49 :
        case 50 :
        case 51 :
        case 52 :
        case 53 :
        case 54 :
        case 55 :
        case 56 :
        case 57 :
            break;
        case 33 :
        case 34 :
        case 35 :
        case 36 :
        case 37 :
        case 38 :
        case 39 :
        case 42 :
        case 43 :
        case 46 :
        case 47 :
        case 58 :
        case 59 :
        case 61 :
            return /* tuple */[
                    /* [] */0,
                    x
                  ];
        case 32 :
        case 40 :
        case 41 :
        case 44 :
        case 45 :
        case 60 :
        case 62 :
            _x = x[1];
            continue ;
        default:
          return /* tuple */[
                  /* [] */0,
                  x
                ];
      }
    } else {
      if (match < 9) {
        return /* tuple */[
                /* [] */0,
                x
              ];
      }
      _x = x[1];
      continue ;
    }
    var match$1 = parse_int(x);
    var match$2 = parse_pattern(match$1[1]);
    var match$3 = parse_exp(match$2[1]);
    var match$4 = parse_branches(match$3[1]);
    return /* tuple */[
            /* :: */[
              /* tuple */[
                match$1[0],
                /* tuple */[
                  match$2[0],
                  match$3[0]
                ]
              ],
              match$4[0]
            ],
            match$4[1]
          ];
  };
}

function parse_exp(_x) {
  while(true) {
    var x = _x;
    if (x) {
      var match = x[0];
      if (match >= 44) {
        if (match >= 60) {
          if (match < 119) {
            switch (match - 60 | 0) {
              case 0 :
              case 2 :
                  _x = x[1];
                  continue ;
              case 37 :
                  var match$1 = parse_exp(x[1]);
                  var match$2 = parse_exp(match$1[1]);
                  return /* tuple */[
                          /* Application */Block.__(5, [
                              match$1[0],
                              match$2[0]
                            ]),
                          match$2[1]
                        ];
              case 38 :
                  var match$3 = parse_bool(x[1]);
                  return /* tuple */[
                          /* Bool */Block.__(2, [match$3[0]]),
                          match$3[1]
                        ];
              case 39 :
                  var x$1 = x[1];
                  var exit = 0;
                  if (x$1) {
                    var match$4 = x$1[0];
                    if (match$4 !== 97) {
                      if (match$4 !== 116) {
                        exit = 2;
                      } else {
                        var match$5 = x$1[1];
                        if (match$5 && match$5[0] === 111) {
                          var match$6 = match$5[1];
                          if (match$6 && match$6[0] === 114) {
                            var match$7 = parse_int(match$6[1]);
                            var match$8 = parse_adt(match$7[1]);
                            var match$9 = parse_exp(match$8[1]);
                            return /* tuple */[
                                    /* Ctor */Block.__(11, [
                                        match$7[0],
                                        match$8[0],
                                        match$9[0]
                                      ]),
                                    match$9[1]
                                  ];
                          }
                          exit = 2;
                        } else {
                          exit = 2;
                        }
                      }
                    } else {
                      var match$10 = x$1[1];
                      if (match$10 && match$10[0] === 115) {
                        var match$11 = match$10[1];
                        if (match$11 && match$11[0] === 101) {
                          var match$12 = parse_exp(match$11[1]);
                          var match$13 = parse_branches(match$12[1]);
                          return /* tuple */[
                                  /* Case */Block.__(12, [
                                      match$12[0],
                                      match$13[0]
                                    ]),
                                  match$13[1]
                                ];
                        }
                        exit = 2;
                      } else {
                        exit = 2;
                      }
                    }
                  } else {
                    exit = 2;
                  }
                  if (exit === 2) {
                    var match$14 = parse_exp(x$1);
                    var match$15 = parse_exp(match$14[1]);
                    return /* tuple */[
                            /* Cons */Block.__(3, [
                                match$14[0],
                                match$15[0]
                              ]),
                            match$15[1]
                          ];
                  }
                  break;
              case 42 :
                  var x$2 = x[1];
                  var exit$1 = 0;
                  if (x$2) {
                    var match$16 = x$2[0];
                    if (match$16 !== 108) {
                      if (match$16 !== 115) {
                        exit$1 = 2;
                      } else {
                        var match$17 = x$2[1];
                        if (match$17 && match$17[0] === 116) {
                          var match$18 = parse_exp(match$17[1]);
                          return /* tuple */[
                                  /* Fst */Block.__(9, [match$18[0]]),
                                  match$18[1]
                                ];
                        }
                        exit$1 = 2;
                      }
                    } else {
                      var match$19 = x$2[1];
                      if (match$19 && match$19[0] === 111) {
                        var match$20 = match$19[1];
                        if (match$20 && match$20[0] === 97) {
                          var match$21 = match$20[1];
                          if (match$21 && match$21[0] === 116) {
                            var match$22 = parse_float(match$21[1]);
                            return /* tuple */[
                                    /* Float */Block.__(1, [match$22[0]]),
                                    match$22[1]
                                  ];
                          }
                          exit$1 = 2;
                        } else {
                          exit$1 = 2;
                        }
                      } else {
                        exit$1 = 2;
                      }
                    }
                  } else {
                    exit$1 = 2;
                  }
                  if (exit$1 === 2) {
                    var match$23 = parse_int(x$2);
                    var match$24 = parse_int(match$23[1]);
                    var match$25 = parse_type_(match$24[1]);
                    var match$26 = parse_exp(match$25[1]);
                    return /* tuple */[
                            /* Function */Block.__(4, [
                                match$23[0],
                                match$24[0],
                                match$25[0],
                                match$26[0]
                              ]),
                            match$26[1]
                          ];
                  }
                  break;
              case 44 :
                  var match$27 = parse_int(x[1]);
                  return /* tuple */[
                          /* Hole */Block.__(6, [match$27[0]]),
                          match$27[1]
                        ];
              case 45 :
                  var match$28 = parse_int(x[1]);
                  return /* tuple */[
                          /* Int */Block.__(0, [match$28[0]]),
                          match$28[1]
                        ];
              case 50 :
                  return /* tuple */[
                          /* Nil */0,
                          x[1]
                        ];
              case 52 :
                  var match$29 = parse_exp(x[1]);
                  var match$30 = parse_exp(match$29[1]);
                  return /* tuple */[
                          /* Pair */Block.__(8, [
                              match$29[0],
                              match$30[0]
                            ]),
                          match$30[1]
                        ];
              case 55 :
                  var match$31 = parse_exp(x[1]);
                  return /* tuple */[
                          /* Snd */Block.__(10, [match$31[0]]),
                          match$31[1]
                        ];
              case 1 :
              case 3 :
              case 4 :
              case 5 :
              case 6 :
              case 7 :
              case 8 :
              case 9 :
              case 10 :
              case 11 :
              case 12 :
              case 13 :
              case 14 :
              case 15 :
              case 16 :
              case 17 :
              case 18 :
              case 19 :
              case 20 :
              case 21 :
              case 22 :
              case 23 :
              case 24 :
              case 25 :
              case 26 :
              case 27 :
              case 28 :
              case 29 :
              case 30 :
              case 31 :
              case 32 :
              case 33 :
              case 34 :
              case 35 :
              case 36 :
              case 40 :
              case 41 :
              case 43 :
              case 46 :
              case 47 :
              case 48 :
              case 49 :
              case 51 :
              case 53 :
              case 54 :
              case 56 :
                  break;
              case 57 :
                  return /* tuple */[
                          /* Unit */1,
                          x[1]
                        ];
              case 58 :
                  var match$32 = parse_int(x[1]);
                  return /* tuple */[
                          /* Var */Block.__(7, [match$32[0]]),
                          match$32[1]
                        ];
              
            }
          }
          
        } else if (match < 46) {
          _x = x[1];
          continue ;
        }
        
      } else if (match >= 11) {
        if (match >= 32) {
          switch (match - 32 | 0) {
            case 0 :
            case 8 :
            case 9 :
                _x = x[1];
                continue ;
            case 1 :
            case 2 :
            case 3 :
            case 4 :
            case 5 :
            case 6 :
            case 7 :
            case 10 :
            case 11 :
                break;
            
          }
        }
        
      } else if (match >= 9) {
        _x = x[1];
        continue ;
      }
      
    }
    return Pervasives.failwith("Some code generated by parser_generator.py is throwing a parse error:\nWhile parsing a/an exp, I got \"" + (implode(x) + "\" which doesn't match any of the expected tags: ['float', 'ctor', 'case', 'fst', 'i', 'b', 'c', 'n', 'f', 'a', 'h', 'u', 'v', 'p', 's']"));
  };
}

function parse_float(x) {
  var match = parse_token(x);
  return /* tuple */[
          Caml_format.caml_float_of_string(match[0]),
          match[1]
        ];
}

function parse_bool(x) {
  var match = parse_token(x);
  return /* tuple */[
          Pervasives.bool_of_string(match[0]),
          match[1]
        ];
}

function parse_value(_x) {
  while(true) {
    var x = _x;
    if (x) {
      var match = x[0];
      if (match < 60) {
        var switcher = match - 11 | 0;
        if (switcher > 32 || switcher < 0) {
          if ((switcher + 2 >>> 0) <= 36) {
            _x = x[1];
            continue ;
          }
          
        } else if (switcher >= 21) {
          switch (switcher - 21 | 0) {
            case 0 :
            case 8 :
            case 9 :
                _x = x[1];
                continue ;
            case 1 :
            case 2 :
            case 3 :
            case 4 :
            case 5 :
            case 6 :
            case 7 :
            case 10 :
            case 11 :
                break;
            
          }
        }
        
      } else if (match >= 63) {
        switch (match) {
          case 98 :
              var match$1 = parse_bool(x[1]);
              return /* tuple */[
                      /* Vbool */Block.__(1, [match$1[0]]),
                      match$1[1]
                    ];
          case 99 :
              var match$2 = parse_int(x[1]);
              var match$3 = parse_adt(match$2[1]);
              var match$4 = parse_value(match$3[1]);
              return /* tuple */[
                      /* Vctor */Block.__(3, [
                          match$2[0],
                          match$3[0],
                          match$4[0]
                        ]),
                      match$4[1]
                    ];
          case 105 :
              var match$5 = parse_int(x[1]);
              return /* tuple */[
                      /* Vint */Block.__(0, [match$5[0]]),
                      match$5[1]
                    ];
          case 112 :
              var match$6 = parse_value(x[1]);
              var match$7 = parse_value(match$6[1]);
              return /* tuple */[
                      /* Vpair */Block.__(2, [
                          match$6[0],
                          match$7[0]
                        ]),
                      match$7[1]
                    ];
          case 100 :
          case 101 :
          case 102 :
          case 103 :
          case 104 :
          case 106 :
          case 107 :
          case 108 :
          case 109 :
          case 110 :
          case 111 :
          case 113 :
          case 114 :
          case 115 :
          case 116 :
              break;
          case 117 :
              return /* tuple */[
                      /* Vunit */0,
                      x[1]
                    ];
          default:
            
        }
      } else if (match !== 61) {
        _x = x[1];
        continue ;
      }
      
    }
    return Pervasives.failwith("Some code generated by parser_generator.py is throwing a parse error:\nWhile parsing a/an value, I got \"" + (implode(x) + "\" which doesn't match any of the expected tags: ['i', 'b', 'u', 'p', 'c']"));
  };
}

function parse_unevalcons(x) {
  parse_token(x);
  return Pervasives.failwith("unevalcons_of_string Not Implemented");
}

function parse_debug_construct(_x) {
  while(true) {
    var x = _x;
    if (x) {
      var match = x[0];
      if (match < 60) {
        var switcher = match - 11 | 0;
        if (switcher > 32 || switcher < 0) {
          if ((switcher + 2 >>> 0) <= 36) {
            _x = x[1];
            continue ;
          }
          
        } else if (switcher >= 21) {
          switch (switcher - 21 | 0) {
            case 0 :
            case 8 :
            case 9 :
                _x = x[1];
                continue ;
            case 1 :
            case 2 :
            case 3 :
            case 4 :
            case 5 :
            case 6 :
            case 7 :
            case 10 :
            case 11 :
                break;
            
          }
        }
        
      } else if (match >= 63) {
        switch (match) {
          case 98 :
              var match$1 = parse_branches(x[1]);
              return /* tuple */[
                      /* Branches */Block.__(17, [match$1[0]]),
                      match$1[1]
                    ];
          case 99 :
              var x$1 = x[1];
              var exit = 0;
              if (x$1 && x$1[0] === 111) {
                var match$2 = x$1[1];
                if (match$2 && match$2[0] === 110) {
                  var match$3 = match$2[1];
                  if (match$3 && match$3[0] === 115) {
                    var match$4 = match$3[1];
                    if (match$4 && match$4[0] === 116) {
                      var match$5 = match$4[1];
                      if (match$5 && match$5[0] === 114) {
                        var match$6 = match$5[1];
                        if (match$6 && match$6[0] === 97) {
                          var match$7 = match$6[1];
                          if (match$7 && match$7[0] === 105) {
                            var match$8 = match$7[1];
                            if (match$8 && match$8[0] === 110) {
                              var match$9 = match$8[1];
                              if (match$9 && match$9[0] === 116) {
                                var match$10 = Pervasives.failwith("parse_constraint_ Not Implemented");
                                return /* tuple */[
                                        /* Constraint_ */Block.__(5, [match$10[0]]),
                                        match$10[1]
                                      ];
                              }
                              exit = 2;
                            } else {
                              exit = 2;
                            }
                          } else {
                            exit = 2;
                          }
                        } else {
                          exit = 2;
                        }
                      } else {
                        exit = 2;
                      }
                    } else {
                      exit = 2;
                    }
                  } else {
                    exit = 2;
                  }
                } else {
                  exit = 2;
                }
              } else {
                exit = 2;
              }
              if (exit === 2) {
                var match$11 = parse_context(x$1);
                return /* tuple */[
                        /* Context */Block.__(6, [match$11[0]]),
                        match$11[1]
                      ];
              }
              break;
          case 100 :
              var match$12 = parse_int(x[1]);
              return /* tuple */[
                      /* DB_Int */Block.__(8, [match$12[0]]),
                      match$12[1]
                    ];
          case 101 :
              var x$2 = x[1];
              var exit$1 = 0;
              if (x$2) {
                var match$13 = x$2[0];
                if (match$13 !== 110) {
                  if (match$13 !== 120) {
                    exit$1 = 2;
                  } else {
                    var x$3 = x$2[1];
                    var exit$2 = 0;
                    if (x$3 && x$3[0] === 99) {
                      var match$14 = x$3[1];
                      if (match$14 && match$14[0] === 111) {
                        var match$15 = match$14[1];
                        if (match$15 && match$15[0] === 110) {
                          var match$16 = match$15[1];
                          if (match$16 && match$16[0] === 115) {
                            var match$17 = parse_excons(match$16[1]);
                            return /* tuple */[
                                    /* Excons */Block.__(15, [match$17[0]]),
                                    match$17[1]
                                  ];
                          }
                          exit$2 = 3;
                        } else {
                          exit$2 = 3;
                        }
                      } else {
                        exit$2 = 3;
                      }
                    } else {
                      exit$2 = 3;
                    }
                    if (exit$2 === 3) {
                      var match$18 = parse_example(x$3);
                      return /* tuple */[
                              /* Example */Block.__(4, [match$18[0]]),
                              match$18[1]
                            ];
                    }
                    
                  }
                } else {
                  var match$19 = x$2[1];
                  if (match$19 && match$19[0] === 118) {
                    var match$20 = parse_environment(match$19[1]);
                    return /* tuple */[
                            /* Environment */Block.__(1, [match$20[0]]),
                            match$20[1]
                          ];
                  }
                  exit$1 = 2;
                }
              } else {
                exit$1 = 2;
              }
              if (exit$1 === 2) {
                var match$21 = parse_exp(x$2);
                return /* tuple */[
                        /* Exp */Block.__(0, [match$21[0]]),
                        match$21[1]
                      ];
              }
              break;
          case 102 :
              var match$22 = parse_filler_output(x[1]);
              return /* tuple */[
                      /* Filler_Output */Block.__(11, [match$22[0]]),
                      match$22[1]
                    ];
          case 103 :
              var match$23 = Pervasives.failwith("parse_guess_output Not Implemented");
              return /* tuple */[
                      /* Guess_Output */Block.__(9, [match$23[0]]),
                      match$23[1]
                    ];
          case 104 :
              var match$24 = x[1];
              if (match$24) {
                switch (match$24[0]) {
                  case 99 :
                      var match$25 = parse_hole_context(match$24[1]);
                      return /* tuple */[
                              /* Hole_Context */Block.__(7, [match$25[0]]),
                              match$25[1]
                            ];
                  case 102 :
                      var match$26 = parse_hole_fillings(match$24[1]);
                      return /* tuple */[
                              /* Hole_Fillings */Block.__(12, [match$26[0]]),
                              match$26[1]
                            ];
                  case 100 :
                  case 101 :
                  case 103 :
                  case 104 :
                      break;
                  case 105 :
                      var match$27 = parse_int(match$24[1]);
                      return /* tuple */[
                              /* Hole_Identifier */Block.__(14, [match$27[0]]),
                              match$27[1]
                            ];
                  default:
                    
                }
              }
              break;
          case 105 :
          case 106 :
          case 107 :
          case 108 :
          case 109 :
          case 110 :
          case 111 :
          case 112 :
          case 113 :
              break;
          case 114 :
              var match$28 = parse_res(x[1]);
              return /* tuple */[
                      /* Res */Block.__(2, [match$28[0]]),
                      match$28[1]
                    ];
          case 115 :
              var match$29 = parse_solver_output(x[1]);
              return /* tuple */[
                      /* Solver_Output */Block.__(10, [match$29[0]]),
                      match$29[1]
                    ];
          case 116 :
              var match$30 = parse_type_(x[1]);
              return /* tuple */[
                      /* Type_ */Block.__(3, [match$30[0]]),
                      match$30[1]
                    ];
          case 117 :
              var x$4 = x[1];
              var exit$3 = 0;
              if (x$4 && x$4[0] === 110) {
                var match$31 = x$4[1];
                if (match$31 && match$31[0] === 101) {
                  var match$32 = match$31[1];
                  if (match$32 && match$32[0] === 118) {
                    var match$33 = match$32[1];
                    if (match$33 && match$33[0] === 97) {
                      var match$34 = match$33[1];
                      if (match$34 && match$34[0] === 108) {
                        var match$35 = match$34[1];
                        if (match$35 && match$35[0] === 99) {
                          var match$36 = match$35[1];
                          if (match$36 && match$36[0] === 111) {
                            var match$37 = match$36[1];
                            if (match$37 && match$37[0] === 110) {
                              var match$38 = match$37[1];
                              if (match$38 && match$38[0] === 115) {
                                var match$39 = parse_unevalcons(match$38[1]);
                                return /* tuple */[
                                        /* Unevalcons */Block.__(16, [match$39[0]]),
                                        match$39[1]
                                      ];
                              }
                              exit$3 = 2;
                            } else {
                              exit$3 = 2;
                            }
                          } else {
                            exit$3 = 2;
                          }
                        } else {
                          exit$3 = 2;
                        }
                      } else {
                        exit$3 = 2;
                      }
                    } else {
                      exit$3 = 2;
                    }
                  } else {
                    exit$3 = 2;
                  }
                } else {
                  exit$3 = 2;
                }
              } else {
                exit$3 = 2;
              }
              if (exit$3 === 2) {
                var match$40 = parse_unfilled_holes(x$4);
                return /* tuple */[
                        /* Unfilled_Holes */Block.__(13, [match$40[0]]),
                        match$40[1]
                      ];
              }
              break;
          default:
            
        }
      } else if (match !== 61) {
        _x = x[1];
        continue ;
      }
      
    }
    return Pervasives.failwith("Some code generated by parser_generator.py is throwing a parse error:\nWhile parsing a/an debug_construct, I got \"" + (implode(x) + "\" which doesn't match any of the expected tags: ['constraint', 'unevalcons', 'excons', 'env', 'ex', 'hc', 'hf', 'hi', 'e', 'r', 't', 'c', 'd', 'g', 's', 'f', 'u', 'b']"));
  };
}

function parse_excons(x) {
  parse_token(x);
  return Pervasives.failwith("excons_of_string Not Implemented");
}

function parse_hole_context(_x) {
  while(true) {
    var x = _x;
    if (!x) {
      return /* tuple */[
              /* [] */0,
              x
            ];
    }
    var match = x[0];
    if (match >= 11) {
      switch (match) {
        case 48 :
        case 49 :
        case 50 :
        case 51 :
        case 52 :
        case 53 :
        case 54 :
        case 55 :
        case 56 :
        case 57 :
            break;
        case 59 :
            return /* tuple */[
                    /* [] */0,
                    x[1]
                  ];
        case 33 :
        case 34 :
        case 35 :
        case 36 :
        case 37 :
        case 38 :
        case 39 :
        case 42 :
        case 43 :
        case 46 :
        case 47 :
        case 58 :
        case 61 :
            return /* tuple */[
                    /* [] */0,
                    x
                  ];
        case 32 :
        case 40 :
        case 41 :
        case 44 :
        case 45 :
        case 60 :
        case 62 :
            _x = x[1];
            continue ;
        default:
          return /* tuple */[
                  /* [] */0,
                  x
                ];
      }
    } else {
      if (match < 9) {
        return /* tuple */[
                /* [] */0,
                x
              ];
      }
      _x = x[1];
      continue ;
    }
    var match$1 = parse_int(x);
    var match$2 = parse_context(match$1[1]);
    var match$3 = parse_type_(match$2[1]);
    var match$4 = parse_hole_context(match$3[1]);
    return /* tuple */[
            /* :: */[
              /* tuple */[
                match$1[0],
                /* tuple */[
                  match$2[0],
                  match$3[0]
                ]
              ],
              match$4[0]
            ],
            match$4[1]
          ];
  };
}

function parse_hole_fillings(x) {
  parse_token(x);
  return Pervasives.failwith("hole_fillings_of_string Not Implemented");
}

function parse_example(_x) {
  while(true) {
    var x = _x;
    if (x) {
      var match = x[0];
      if (match < 60) {
        var switcher = match - 11 | 0;
        if (switcher > 32 || switcher < 0) {
          if ((switcher + 2 >>> 0) <= 36) {
            _x = x[1];
            continue ;
          }
          
        } else if (switcher >= 21) {
          switch (switcher - 21 | 0) {
            case 0 :
            case 8 :
            case 9 :
                _x = x[1];
                continue ;
            case 1 :
            case 2 :
            case 3 :
            case 4 :
            case 5 :
            case 6 :
            case 7 :
            case 10 :
            case 11 :
                break;
            
          }
        }
        
      } else if (match >= 63) {
        switch (match) {
          case 98 :
              var match$1 = parse_bool(x[1]);
              return /* tuple */[
                      /* Ebool */Block.__(1, [match$1[0]]),
                      match$1[1]
                    ];
          case 99 :
              var match$2 = parse_int(x[1]);
              var match$3 = parse_adt(match$2[1]);
              var match$4 = parse_example(match$3[1]);
              return /* tuple */[
                      /* Ector */Block.__(4, [
                          match$2[0],
                          match$3[0],
                          match$4[0]
                        ]),
                      match$4[1]
                    ];
          case 102 :
              var match$5 = parse_value(x[1]);
              var match$6 = parse_example(match$5[1]);
              return /* tuple */[
                      /* Efunc */Block.__(3, [
                          match$5[0],
                          match$6[0]
                        ]),
                      match$6[1]
                    ];
          case 105 :
              var match$7 = parse_int(x[1]);
              return /* tuple */[
                      /* Eint */Block.__(0, [match$7[0]]),
                      match$7[1]
                    ];
          case 112 :
              var match$8 = parse_example(x[1]);
              var match$9 = parse_example(match$8[1]);
              return /* tuple */[
                      /* Epair */Block.__(2, [
                          match$8[0],
                          match$9[0]
                        ]),
                      match$9[1]
                    ];
          case 100 :
          case 101 :
          case 103 :
          case 104 :
          case 106 :
          case 107 :
          case 108 :
          case 109 :
          case 110 :
          case 111 :
          case 113 :
          case 114 :
          case 115 :
              break;
          case 116 :
              return /* tuple */[
                      /* Top */0,
                      x[1]
                    ];
          case 117 :
              return /* tuple */[
                      /* Eunit */1,
                      x[1]
                    ];
          default:
            
        }
      } else if (match !== 61) {
        _x = x[1];
        continue ;
      }
      
    }
    return Pervasives.failwith("Some code generated by parser_generator.py is throwing a parse error:\nWhile parsing a/an example, I got \"" + (implode(x) + "\" which doesn't match any of the expected tags: ['t', 'u', 'i', 'b', 'p', 'f', 'c']"));
  };
}

function parse_filler_output(x) {
  parse_token(x);
  return Pervasives.failwith("filler_output_of_string Not Implemented");
}

function parse_unfilled_holes(x) {
  parse_token(x);
  return Pervasives.failwith("unfilled_holes_of_string Not Implemented");
}

function parse_solver_output(x) {
  parse_token(x);
  return Pervasives.failwith("solver_output_of_string Not Implemented");
}

function parse_constraint_(param) {
  return Pervasives.failwith("parse_constraint_ Not Implemented");
}

function parse_guess_output(param) {
  return Pervasives.failwith("parse_guess_output Not Implemented");
}

exports.make_list = make_list;
exports.explode = explode;
exports.implode = implode;
exports.skip_whitespace = skip_whitespace;
exports.parse_token = parse_token;
exports.parse_adt = parse_adt;
exports.parse_res = parse_res;
exports.parse_ann = parse_ann;
exports.parse_value = parse_value;
exports.parse_debug_construct = parse_debug_construct;
exports.parse_type_ = parse_type_;
exports.parse_exp = parse_exp;
exports.parse_pattern = parse_pattern;
exports.parse_example = parse_example;
exports.parse_int = parse_int;
exports.parse_float = parse_float;
exports.parse_hole_context = parse_hole_context;
exports.parse_excons = parse_excons;
exports.parse_solver_output = parse_solver_output;
exports.parse_environment = parse_environment;
exports.parse_bool = parse_bool;
exports.parse_hole_fillings = parse_hole_fillings;
exports.parse_unfilled_holes = parse_unfilled_holes;
exports.parse_constraint_ = parse_constraint_;
exports.parse_unevalcons = parse_unevalcons;
exports.parse_filler_output = parse_filler_output;
exports.parse_guess_output = parse_guess_output;
exports.parse_branches = parse_branches;
exports.parse_context = parse_context;
/* No side effect */
